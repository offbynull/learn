<!DOCTYPE html><html><head>
            <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
            <meta content="utf-8" http-equiv="encoding">
          <title>Bioinformatics
</title><meta name="viewport" content="width=device-width,initial-scale=1"><link href="/.temp_githib_css/github-markdown.css" rel="stylesheet"><link href="/.temp_highlightjs_css/default.css" rel="stylesheet"></head>
          <body class="markdown-body"><div class="toc">
<ul>
<li><a href="#HEADREF0">Introduction</a></li>
<li><a href="#HEADREF1">K-mers</a></li>
<ul>
<li><a href="#HEADREF2">Reverse Complement of a DNA K-mer</a></li>
<li><a href="#HEADREF3">Hamming Distance Between K-mers</a></li>
<li><a href="#HEADREF4">Hamming Distance Neighbourhood of a DNA K-mer</a></li>
</ul>
<li><a href="#HEADREF5">K-mer Search</a></li>
<ul>
<li><a href="#HEADREF6">Find Locations of a K-mer</a></li>
<li><a href="#HEADREF7">Find Clumps of a K-mer</a></li>
<li><a href="#HEADREF8">Find Repeating K-mers</a></li>
<li><a href="#HEADREF9">Find Repeating K-mers in Window</a></li>
</ul>
<li><a href="#HEADREF10">GC Skew</a></li>
<li><a href="#HEADREF11">Stories</a></li>
<ul>
<li><a href="#HEADREF12">Bacteria Replication</a></li>
<ul>
<li><a href="#HEADREF13">Find Ori and Ter</a></li>
<li><a href="#HEADREF14">Find the DnaA Box</a></li>
</ul>
</ul>
<li><a href="#HEADREF15">Terminology</a></li>
</ul>
</div>
<a name="HEADREF0"></a><h1>Introduction</h1>
<a name="HEADREF1"></a><h1>K-mers</h1>
<p>A <a href="#BOOKMARK1">k-mer</a> is a subsequence of length k within some larger biological sequence (e.g. DNA or amino acid chain). For example, in the DNA sequence <code>GAAATC</code>, the following <a href="#BOOKMARK1">k-mer</a>'s exist:</p>
<table>
<thead>
<tr>
<th>k</th>
<th><a href="#BOOKMARK1">k-mer</a>s</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>G A A A T C</td>
</tr>
<tr>
<td>2</td>
<td>GA AA AA AT TC</td>
</tr>
<tr>
<td>3</td>
<td>GAA AAA AAT ATC</td>
</tr>
<tr>
<td>4</td>
<td>GAAA AAAT AATC</td>
</tr>
<tr>
<td>5</td>
<td>GAAAT AAATC</td>
</tr>
<tr>
<td>6</td>
<td>GAAATC</td>
</tr>
</tbody>
</table>
<p>Often times we'll need to either...</p>
<ul>
<li>search for an exact <a href="#BOOKMARK1">k-mer</a>.</li>
<li>search for an approximate <a href="#BOOKMARK1">k-mer</a> (fuzzy search).</li>
<li>find <a href="#BOOKMARK1">k-mer</a>s of interest in a sequence (e.g. repeating <a href="#BOOKMARK1">k-mer</a>s).</li>
</ul>
<a name="HEADREF2"></a><h2>Reverse Complement of a DNA K-mer</h2>
<p><strong>WHAT</strong>: Given a DNA <a href="#BOOKMARK1">k-mer</a>, calculate its reverse complement.</p>
<p><strong>WHY</strong>: Depending on the type of biological sequence, a <a href="#BOOKMARK1">k-mer</a> may have one or more alternatives. For DNA sequences specifically, a <a href="#BOOKMARK1">k-mer</a> of interest may have an alternate form. Since the DNA molecule comes as 2 strands, where ...</p>
<ul>
<li>each strand's direction is opposite of the other,</li>
<li>each strand position has a nucleotide that complements the nucleotide at that same position on the other stand:
<ul>
<li>A ⟷ T</li>
<li>C ⟷ G</li>
</ul>
</li>
</ul>
<p><img src="svgbob_c44b72fd8e03cfe92b63a0a3b83bfe37c5551666.svg" alt="Kroki diagram output"></p>
<p>, ... the reverse complement of that <a href="#BOOKMARK1">k-mer</a> may be just as valid as the original <a href="#BOOKMARK1">k-mer</a>. For example, if an enzyme is known to bind to a specific DNA <a href="#BOOKMARK1">k-mer</a>, it's possible that it might also bind to the reverse complement of that <a href="#BOOKMARK1">k-mer</a>.</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverse_complement</span><span class="hljs-params">(strand: str)</span>:</span>
    ret = <span class="hljs-string">''</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(strand)):
        base = strand[i]
        <span class="hljs-keyword">if</span> base == <span class="hljs-string">'A'</span> <span class="hljs-keyword">or</span> base == <span class="hljs-string">'a'</span>:
            base = <span class="hljs-string">'T'</span>
        <span class="hljs-keyword">elif</span> base == <span class="hljs-string">'T'</span> <span class="hljs-keyword">or</span> base == <span class="hljs-string">'t'</span>:
            base = <span class="hljs-string">'A'</span>
        <span class="hljs-keyword">elif</span> base == <span class="hljs-string">'C'</span> <span class="hljs-keyword">or</span> base == <span class="hljs-string">'c'</span>:
            base = <span class="hljs-string">'G'</span>
        <span class="hljs-keyword">elif</span> base == <span class="hljs-string">'G'</span> <span class="hljs-keyword">or</span> base == <span class="hljs-string">'g'</span>:
            base = <span class="hljs-string">'C'</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">'Unexpected base: '</span> + base)

        ret += base
    <span class="hljs-keyword">return</span> ret[::<span class="hljs-number">-1</span>]</code></pre><div style="border:1px solid black;">
<p></p>
<p>Original: TAATCCG</p>
<p>Reverse Complement: CGGATTA</p>
</div>
<p></p>
<a name="HEADREF3"></a><h2>Hamming Distance Between K-mers</h2>
<p><strong>WHAT</strong>: Given 2 <a href="#BOOKMARK1">k-mer</a>s, the hamming distance is the number of positional mismatches between them.</p>
<p><strong>WHY</strong>: Imagine an enzyme that looks for a specific DNA <a href="#BOOKMARK1">k-mer</a> pattern to bind to. Since DNA is known to mutate, it may be that that enzyme can also bind to other <a href="#BOOKMARK1">k-mer</a> patterns that are slight variations of the original. For example, that enzyme may be able to bind to both AAACTG and AAAGTG.</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hamming_distance</span><span class="hljs-params">(kmer1: str, kmer2: str)</span> -&gt; int:</span>
    mismatch = <span class="hljs-number">0</span>

    <span class="hljs-keyword">for</span> ch1, ch2 <span class="hljs-keyword">in</span> zip(kmer1, kmer2):
        <span class="hljs-keyword">if</span> ch1 != ch2:
            mismatch += <span class="hljs-number">1</span>

    <span class="hljs-keyword">return</span> mismatch</code></pre><div style="border:1px solid black;">
<p></p>
<p>Kmer1: ACTTTGTT</p>
<p>Kmer2: AGTTTCTT</p>
<p>Hamming Distance: 2</p>
</div>
<p></p>
<a name="HEADREF4"></a><h2>Hamming Distance Neighbourhood of a DNA K-mer</h2>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li>Hamming Distance Between <a href="#BOOKMARK1">K-mer</a>s</li>
</ul>
</div>
<p><strong>WHAT</strong>: Given a source <a href="#BOOKMARK1">k-mer</a> and a minimum hamming distance, find all <a href="#BOOKMARK1">k-mer</a>s such within the hamming distance of the source <a href="#BOOKMARK1">k-mer</a>. In other words, find all <a href="#BOOKMARK1">k-mer</a>s such that <code>hamming_distance(source_kmer, kmer) &lt;= min_distance</code>.</p>
<p><strong>WHY</strong>: Imagine an enzyme that looks for a specific DNA <a href="#BOOKMARK1">k-mer</a> pattern to bind to. Since DNA is known to mutate, it may be that that enzyme can also bind to other <a href="#BOOKMARK1">k-mer</a> patterns that are slight variations of the original. This algorithm finds all such variations.</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_all_dna_kmers_within_hamming_distance</span><span class="hljs-params">(kmer: str, hamming_dist: int)</span> -&gt; set[str]:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recurse</span><span class="hljs-params">(kmer: str, hamming_dist: int, output: set[str])</span> -&gt; <span class="hljs-keyword">None</span>:</span>
        <span class="hljs-keyword">if</span> hamming_dist == <span class="hljs-number">0</span>:
            output.add(kmer)
            <span class="hljs-keyword">return</span>

        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(kmer)):
            <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> <span class="hljs-string">'ACTG'</span>:
                neighbouring_kmer = kmer[:i] + ch + kmer[i + <span class="hljs-number">1</span>:]
                recurse(neighbouring_kmer, hamming_dist - <span class="hljs-number">1</span>, output)

    output = set()
    recurse(kmer, hamming_dist, output)

    <span class="hljs-keyword">return</span> output</code></pre><div style="border:1px solid black;">
<p></p>
<p>Kmers within hamming distance 1 of AAAA: {'AAAA', 'AAAG', 'AGAA', 'AACA', 'AAGA', 'AAAT', 'TAAA', 'AATA', 'ACAA', 'AAAC', 'GAAA', 'CAAA', 'ATAA'}</p>
</div>
<p></p>
<a name="HEADREF5"></a><h1>K-mer Search</h1>
<a name="HEADREF6"></a><h2>Find Locations of a K-mer</h2>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li>Hamming Distance Neighbourhood of a <a href="#BOOKMARK1">K-mer</a></li>
<li>Reverse Complement a DNA <a href="#BOOKMARK1">K-mer</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given a <a href="#BOOKMARK1">k-mer</a>, find where that <a href="#BOOKMARK1">k-mer</a> occurs in some larger sequence. The search may potentially include the <a href="#BOOKMARK1">k-mer</a>'s variants (e.g. reverse complement).</p>
<p><strong>WHY</strong>: Imagine that you know of a specific <a href="#BOOKMARK1">k-mer</a> pattern that serves some function in an organism. If you see that same <a href="#BOOKMARK1">k-mer</a> pattern appearing in some other related organism, it could be a sign that that <a href="#BOOKMARK1">k-mer</a> pattern serves a similar function. For example, the same <a href="#BOOKMARK1">k-mer</a> pattern could be used by 2 related types of bacteria as a <a href="#BOOKMARK0">DnaA box</a>.</p>
<p>The enzyme that operates on that <a href="#BOOKMARK1">k-mer</a> may also operate on its reverse complement as well as slight variations on that <a href="#BOOKMARK1">k-mer</a>. For example, if an enzyme binds to AAAAAAAAA, it may also bind to its...</p>
<ul>
<li>reverse complement: TTTTTTTTT</li>
<li>approximate variants: AAAAAAAAA, AAATAAAAA, AAAAAGAAA, ...</li>
<li>approximate variants of its reverse complements: TTTTTTTTT, TTTTTTATT, TTCTTTTTT, ...</li>
</ul>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Options</span><span class="hljs-params">(NamedTuple)</span>:</span>
    hamming_distance: int = <span class="hljs-number">0</span>
    reverse_complement: bool = <span class="hljs-literal">False</span>


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_kmer_locations</span><span class="hljs-params">(sequence: str, kmer: str, options: Options = Options<span class="hljs-params">()</span>)</span> -&gt; List[int]:</span>
    <span class="hljs-comment"># Construct test kmers</span>
    test_kmers = set()
    test_kmers.add(kmer)
    [test_kmers.add(alt_kmer) <span class="hljs-keyword">for</span> alt_kmer <span class="hljs-keyword">in</span> find_all_dna_kmers_within_hamming_distance(kmer, options.hamming_distance)]
    <span class="hljs-keyword">if</span> options.reverse_complement:
        rc_kmer = reverse_complement(kmer)
        [test_kmers.add(alt_rc_kmer) <span class="hljs-keyword">for</span> alt_rc_kmer <span class="hljs-keyword">in</span> find_all_dna_kmers_within_hamming_distance(rc_kmer, options.hamming_distance)]

    <span class="hljs-comment"># Slide over the sequence's kmers and check for matches against test kmers</span>
    k = len(kmer)
    idxes = []
    <span class="hljs-keyword">for</span> seq_kmer, i <span class="hljs-keyword">in</span> slide_window(sequence, k):
        <span class="hljs-keyword">if</span> seq_kmer <span class="hljs-keyword">in</span> test_kmers:
            idxes.append(i)
    <span class="hljs-keyword">return</span> idxes</code></pre><div style="border:1px solid black;">
<p></p>
<p>Found AAAA in AAAAGAACCTAATCTTAAAGGAGATGATGATTCTAA at index [0, 1, 2, 3, 12, 15, 16, 30]</p>
</div>
<p></p>
<a name="HEADREF7"></a><h2>Find Clumps of a K-mer</h2>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li>Find Locations of a <a href="#BOOKMARK1">K-mer</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given a <a href="#BOOKMARK1">k-mer</a>, find where that <a href="#BOOKMARK1">k-mer</a> clusters in some larger sequence. The search may potentially include the <a href="#BOOKMARK1">k-mer</a>'s variants (e.g. reverse complement).</p>
<p><strong>WHY</strong>: An enzyme may need to bind to a specific region of DNA to begin doing its job. That is, it looks for a specific <a href="#BOOKMARK1">k-mer</a> pattern to bind to, where that <a href="#BOOKMARK1">k-mer</a> represents the beginning of some larger DNA region that it operates on. Since DNA is known to mutate, often times you'll find multiple copies of the same <a href="#BOOKMARK1">k-mer</a> pattern clustered together -- if one copy mutated to become unusable, the other copies are still around.</p>
<p>For example, the <a href="#BOOKMARK0">DnaA box</a> is a special <a href="#BOOKMARK1">k-mer</a> pattern used by enzymes during DNA replication. Since DNA is known to mutate, the <a href="#BOOKMARK0">DnaA box</a> can be found repeating multiple times in the region of DNA known as the <a href="#BOOKMARK9">replication origin</a>. Finding the <a href="#BOOKMARK0">DnaA box</a> clustered in a small region is a good indicator that you've found the <a href="#BOOKMARK9">replication origin</a>.</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_kmer_clusters</span><span class="hljs-params">(sequence: str, kmer: str, min_occurrence_in_cluster: int, cluster_window_size: int, options: Options = Options<span class="hljs-params">()</span>)</span> -&gt; List[int]:</span>
    cluster_locs = []

    locs = find_kmer_locations(sequence, kmer, options)
    start_i = <span class="hljs-number">0</span>
    occurrence_count = <span class="hljs-number">1</span>
    <span class="hljs-keyword">for</span> end_i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(locs)):
        <span class="hljs-keyword">if</span> locs[end_i] - locs[start_i] &lt; cluster_window_size:  <span class="hljs-comment"># within a cluster window?</span>
            occurrence_count += <span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">if</span> occurrence_count &gt;= min_occurrence_in_cluster:  <span class="hljs-comment"># did the last cluster meet the min ocurr requirement?</span>
                cluster_locs.append(locs[start_i])
            start_i = end_i
            occurrence_count = <span class="hljs-number">1</span>

    <span class="hljs-keyword">return</span> cluster_locs</code></pre><div style="border:1px solid black;">
<p></p>
<p>Found clusters of GGG (at least 3 occurrences in window of 13) in GGGACTGAACAAACAAATTTGGGAGGGCACGGGTTAAAGGAGATGATGATTCAAAGGGT at index [19, 37]</p>
</div>
<p></p>
<a name="HEADREF8"></a><h2>Find Repeating K-mers</h2>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li>Hamming Distance Neighbourhood of a <a href="#BOOKMARK1">K-mer</a></li>
<li>Reverse Complement a DNA <a href="#BOOKMARK1">K-mer</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given a sequence, find clusters of unique <a href="#BOOKMARK1">k-mer</a>s within that sequence. In other words, for each unique <a href="#BOOKMARK1">k-mer</a> that exists in the sequence, see if it clusters in the sequence. The search may potentially include variants of <a href="#BOOKMARK1">k-mer</a> variants (e.g. reverse complements of the <a href="#BOOKMARK1">k-mer</a>s).</p>
<p><strong>WHY</strong>: An enzyme may need to bind to a specific region of DNA to begin doing its job. That is, it looks for a specific <a href="#BOOKMARK1">k-mer</a> pattern to bind to, where that <a href="#BOOKMARK1">k-mer</a> represents the beginning of some larger DNA region that it operates on. Since DNA is known to mutate, often times you'll find multiple copies of the same <a href="#BOOKMARK1">k-mer</a> pattern clustered together -- if one copy mutated to become unusable, the other copies are still around.</p>
<p>For example, the <a href="#BOOKMARK0">DnaA box</a> is a special <a href="#BOOKMARK1">k-mer</a> pattern used by enzymes during DNA replication. Since DNA is known to mutate, the <a href="#BOOKMARK0">DnaA box</a> can be found repeating multiple times in the region of DNA known as the <a href="#BOOKMARK9">replication origin</a>. Given that you don't know the <a href="#BOOKMARK1">k-mer</a> pattern for the <a href="#BOOKMARK0">DnaA box</a> but you do know the <a href="#BOOKMARK9">replication origin</a>, you can scan through the <a href="#BOOKMARK9">replication origin</a> for repeating <a href="#BOOKMARK1">k-mer</a> patterns. If a pattern is found to heavily repeat, it's a good candidate that it's the <a href="#BOOKMARK1">k-mer</a> pattern for the <a href="#BOOKMARK0">DnaA box</a>.</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-keyword">from</span> Utils <span class="hljs-keyword">import</span> slide_window


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">count_kmers</span><span class="hljs-params">(data: str, k: int, options: Options = Options<span class="hljs-params">()</span>)</span> -&gt; Counter[str]:</span>
    counter = Counter()
    <span class="hljs-keyword">for</span> kmer, i <span class="hljs-keyword">in</span> slide_window(data, k):
        neighbourhood = find_all_dna_kmers_within_hamming_distance(kmer, options.hamming_distance)
        <span class="hljs-keyword">for</span> neighbouring_kmer <span class="hljs-keyword">in</span> neighbourhood:
            counter[neighbouring_kmer] += <span class="hljs-number">1</span>

        <span class="hljs-keyword">if</span> options.reverse_complement:
            kmer_rc = reverse_complement(kmer)
            neighbourhood = find_all_dna_kmers_within_hamming_distance(kmer_rc, options.hamming_distance)
            <span class="hljs-keyword">for</span> neighbouring_kmer <span class="hljs-keyword">in</span> neighbourhood:
                counter[neighbouring_kmer] += <span class="hljs-number">1</span>

    <span class="hljs-keyword">return</span> counter


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">top_repeating_kmers</span><span class="hljs-params">(data: str, k: int, options: Options = Options<span class="hljs-params">()</span>)</span> -&gt; Set[str]:</span>
    counts = count_kmers(data, k, options)

    _, top_count = counts.most_common(<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]

    top_kmers = set()
    <span class="hljs-keyword">for</span> kmer, count <span class="hljs-keyword">in</span> counts.items():
        <span class="hljs-keyword">if</span> count == top_count:
            top_kmers.add((kmer, count))
    <span class="hljs-keyword">return</span> top_kmers</code></pre><div style="border:1px solid black;">
<p></p>
<p>Top 5-mer frequencies for GGGACTGAACAAACAAATTTGGGAGGGCACGGGTTAAAGGAGATGATGATTCAAAGGGT:</p>
<ul>
<li>CCCTT = 6 occurrences</li>
<li>TTTAA = 6 occurrences</li>
<li>GATCA = 6 occurrences</li>
<li>TTAAA = 6 occurrences</li>
<li>TGATC = 6 occurrences</li>
<li>AAGGG = 6 occurrences</li>
</ul>
</div>
<p></p>
<a name="HEADREF9"></a><h2>Find Repeating K-mers in Window</h2>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li>Find Repeating <a href="#BOOKMARK1">K-mer</a>s</li>
</ul>
</div>
<p><strong>WHAT</strong>: Given a sequence, find regions within that sequence that contain clusters of unique <a href="#BOOKMARK1">k-mer</a>s. In other words, ...</p>
<ul>
<li>slide a window over the cluster.</li>
<li>for each unique <a href="#BOOKMARK1">k-mer</a> that exists in the window, see if it clusters in the sequence.</li>
</ul>
<p>The search may potentially include variants of <a href="#BOOKMARK1">k-mer</a> variants (e.g. reverse complements of the <a href="#BOOKMARK1">k-mer</a>s).</p>
<p><strong>WHY</strong>: An enzyme may need to bind to a specific region of DNA to begin doing its job. That is, it looks for a specific <a href="#BOOKMARK1">k-mer</a> pattern to bind to, where that <a href="#BOOKMARK1">k-mer</a> represents the beginning of some larger DNA region that it operates on. Since DNA is known to mutate, often times you'll find multiple copies of the same <a href="#BOOKMARK1">k-mer</a> pattern clustered together -- if one copy mutated to become unusable, the other copies are still around.</p>
<p>For example, the <a href="#BOOKMARK0">DnaA box</a> is a special <a href="#BOOKMARK1">k-mer</a> pattern used by enzymes during DNA replication. Since DNA is known to mutate, the <a href="#BOOKMARK0">DnaA box</a> can be found repeating multiple times in the region of DNA known as the <a href="#BOOKMARK9">replication origin</a>. Given that you don't know the <a href="#BOOKMARK1">k-mer</a> pattern for the <a href="#BOOKMARK0">DnaA box</a> but you do know the <a href="#BOOKMARK9">replication origin</a>, you can scan through the <a href="#BOOKMARK9">replication origin</a> for repeating <a href="#BOOKMARK1">k-mer</a> patterns. If a pattern is found to heavily repeat, it's a good candidate that it's the <a href="#BOOKMARK1">k-mer</a> pattern for the <a href="#BOOKMARK0">DnaA box</a>.</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">scan_for_repeating_kmers_in_clusters</span><span class="hljs-params">(sequence: str, k: int, min_occurrence_in_cluster: int, cluster_window_size: int, options: Options = Options<span class="hljs-params">()</span>)</span> -&gt; Set[KmerCluster]:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">neighborhood</span><span class="hljs-params">(kmer: str)</span> -&gt; Set[str]:</span>
        neighbourhood = find_all_dna_kmers_within_hamming_distance(kmer, options.hamming_distance)
        <span class="hljs-keyword">if</span> options.reverse_complement:
            kmer_rc = reverse_complement(kmer)
            neighbourhood = find_all_dna_kmers_within_hamming_distance(kmer_rc, options.hamming_distance)
        <span class="hljs-keyword">return</span> neighbourhood

    kmer_counter = {}

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_kmer</span><span class="hljs-params">(kmer: str, loc: int)</span> -&gt; <span class="hljs-keyword">None</span>:</span>
        <span class="hljs-keyword">if</span> kmer <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> kmer_counter:
            kmer_counter[kmer] = set()
        kmer_counter[kmer].add(window_idx + kmer_idx)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove_kmer</span><span class="hljs-params">(kmer: str, loc: int)</span> -&gt; <span class="hljs-keyword">None</span>:</span>
        kmer_counter[kmer].remove(window_idx - <span class="hljs-number">1</span>)
        <span class="hljs-keyword">if</span> len(kmer_counter[kmer]) == <span class="hljs-number">0</span>:
            <span class="hljs-keyword">del</span> kmer_counter[kmer]

    clustered_kmers = set()

    old_first_kmer = <span class="hljs-literal">None</span>
    <span class="hljs-keyword">for</span> window, window_idx <span class="hljs-keyword">in</span> slide_window(sequence, cluster_window_size):
        first_kmer = window[<span class="hljs-number">0</span>:k]
        last_kmer = window[-k:]

        <span class="hljs-comment"># If first iteration, add all kmers</span>
        <span class="hljs-keyword">if</span> window_idx == <span class="hljs-number">0</span>:
            <span class="hljs-keyword">for</span> kmer, kmer_idx <span class="hljs-keyword">in</span> slide_window(window, k):
                <span class="hljs-keyword">for</span> alt_kmer <span class="hljs-keyword">in</span> neighborhood(kmer):
                    add_kmer(alt_kmer, window_idx + kmer_idx)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-comment"># Add kmer that was walked in to</span>
            <span class="hljs-keyword">for</span> new_last_kmer <span class="hljs-keyword">in</span> neighborhood(last_kmer):
                add_kmer(new_last_kmer, window_idx + cluster_window_size - k)
            <span class="hljs-comment"># Remove kmer that was walked out of</span>
            <span class="hljs-keyword">if</span> old_first_kmer <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
                <span class="hljs-keyword">for</span> alt_kmer <span class="hljs-keyword">in</span> neighborhood(old_first_kmer):
                    remove_kmer(alt_kmer, window_idx - <span class="hljs-number">1</span>)

        old_first_kmer = first_kmer

        <span class="hljs-comment"># Find clusters within window -- tuple is k-mer, start_idx, occurrence_count</span>
        [clustered_kmers.add(KmerCluster(k, min(v), len(v))) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> kmer_counter.items() <span class="hljs-keyword">if</span> len(v) &gt;= min_occurrence_in_cluster]

    <span class="hljs-keyword">return</span> clustered_kmers</code></pre><div style="border:1px solid black;">
<p></p>
<p>Found clusters of k=9 (at least 6 occurrences in window of 20) in TTTTTTTTTTTTTCCCTTTTTTTTTCCCTTTTTTTTTTTTT at...</p>
<ul>
<li>KmerCluster(kmer='AGAAAAAAA', start_index=0, occurrence_count=6)</li>
<li>KmerCluster(kmer='CAAAAAAAA', start_index=0, occurrence_count=6)</li>
<li>KmerCluster(kmer='TAAAAAAAA', start_index=0, occurrence_count=6)</li>
<li>KmerCluster(kmer='AAAAAAAAA', start_index=0, occurrence_count=6)</li>
<li>KmerCluster(kmer='GAAAAAAAA', start_index=0, occurrence_count=7)</li>
<li>KmerCluster(kmer='GAAAAAAAA', start_index=1, occurrence_count=6)</li>
<li>KmerCluster(kmer='AAAAAAAGA', start_index=26, occurrence_count=6)</li>
<li>KmerCluster(kmer='AAAAAAAAG', start_index=26, occurrence_count=6)</li>
<li>KmerCluster(kmer='AAAAAAAAG', start_index=26, occurrence_count=7)</li>
<li>KmerCluster(kmer='AAAAAAAAA', start_index=27, occurrence_count=6)</li>
<li>KmerCluster(kmer='AAAAAAAAT', start_index=27, occurrence_count=6)</li>
<li>KmerCluster(kmer='AAAAAAAAC', start_index=27, occurrence_count=6)</li>
</ul>
</div>
<p></p>
<a name="HEADREF10"></a><h1>GC Skew</h1>
<p><strong>WHAT</strong>: Given a sequence, walk over it and ...</p>
<ul>
<li>increment every time you spot a G.</li>
<li>decrement every time you spot a C.</li>
</ul>
<p><strong>WHY</strong>: Given the DNA sequence of an organism, some segments may have lower count of Gs vs Cs.</p>
<p>During replication, some segments of DNA stay single-stranded for a much longer time than other segments. <a href="#BOOKMARK19">Single-stranded DNA</a> is 100 times more susceptible to mutations than <a href="#BOOKMARK20">double-stranded DNA</a>. Specifically, in <a href="#BOOKMARK19">single-stranded DNA</a>, C has a greater tendency to mutate to T. When that <a href="#BOOKMARK19">single-stranded DNA</a> re-binds to a neighbouring strand, the positions of any nucleotides that mutated from C to T will change on the neighbouring strand from G to A.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Recall that the reverse complements of ...</p>
<ul>
<li>C is G</li>
<li>A is T</li>
</ul>
<p>It mutated from C to T. Since its now T, its complement is A.</p>
</div>
<p>Plotting the skew lets you know the rough location of segments that stayed single-stranded for a longer period of time. That information hints at special / useful locations in the organism's DNA sequence (<a href="#BOOKMARK9">replication origin</a> / <a href="#BOOKMARK11">replication terminus</a>).</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gc_skew</span><span class="hljs-params">(seq: str)</span>:</span>
    counter = <span class="hljs-number">0</span>
    skew = [counter]
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(seq)):
        <span class="hljs-keyword">if</span> seq[i] == <span class="hljs-string">'G'</span>:
            counter += <span class="hljs-number">1</span>
            skew.append(counter)
        <span class="hljs-keyword">elif</span> seq[i] == <span class="hljs-string">'C'</span>:
            counter -= <span class="hljs-number">1</span>
            skew.append(counter)
        <span class="hljs-keyword">else</span>:
            skew.append(counter)
    <span class="hljs-keyword">return</span> skew</code></pre><div style="border:1px solid black;">
<p></p>
<p>Calculating skew for: ...</p>
<p>Result: [0, -1, -1,...</p>
<p><img src="skew_babf857bad6dd935f0d1ddbbb8b5005f.png" alt="GC Skew Plot"></p>
</div>
<p></p>
<a name="HEADREF11"></a><h1>Stories</h1>
<a name="HEADREF12"></a><h2>Bacteria Replication</h2>
<p>Bacteria are known to have a single chromosome of circular / looping DNA. On that DNA, the <a href="#BOOKMARK9">replication origin</a> (<a href="#BOOKMARK10">ori</a>) is the region in which DNA replication starts, while the <a href="#BOOKMARK11">replication terminus</a> (<a href="#BOOKMARK12">ter</a>) is where it ends. The <a href="#BOOKMARK10">ori</a> and <a href="#BOOKMARK12">ter</a> and usually placed on opposite ends of each other.</p>
<p><img src="svgbob_308a4af4e5d6864abeb06f6652581aec0ff50fb1.svg" alt="Kroki diagram output"></p>
<p>The replication process begins by a <a href="#BOOKMARK8">replication fork</a> opening at the <a href="#BOOKMARK10">ori</a>. As replication happens, that fork widens until the point it reaches <a href="#BOOKMARK12">ter</a>...</p>
<p><img src="svgbob_fc7cf2c734fa0cab15b5746e25ad07e25f85ec64.svg" alt="Kroki diagram output"></p>
<p>For each forked <a href="#BOOKMARK19">single-stranded DNA</a>, <a href="#BOOKMARK6">DNA polymerase</a>s attach on and synthesize a new reverse complement strand so that it turns back into <a href="#BOOKMARK20">double-stranded DNA</a>....</p>
<p><img src="svgbob_971abfeff166ada9787cd484db9bfbe43120973a.svg" alt="Kroki diagram output"></p>
<p>The process of synthesizing a reverse complement strand is different based on the section of DNA that <a href="#BOOKMARK6">DNA polymerase</a> is operating on. For each <a href="#BOOKMARK19">single-stranded DNA</a>, if the direction of that DNA strand is traveling from ...</p>
<ul>
<li><a href="#BOOKMARK10">ori</a> to <a href="#BOOKMARK12">ter</a>, it's called a <a href="#BOOKMARK13">forward half-strand</a>.</li>
<li><a href="#BOOKMARK12">ter</a> to <a href="#BOOKMARK10">ori</a>, it's called a <a href="#BOOKMARK14">reverse half-strand</a>.</li>
</ul>
<p><img src="svgbob_ad11e0114c63955ab620cbe9a8dee61a85caa1f9.svg" alt="Kroki diagram output"></p>
<p>Since <a href="#BOOKMARK6">DNA polymerase</a> can only walk over DNA in the reverse direction (<a href="#BOOKMARK4">3'</a> to <a href="#BOOKMARK2">5'</a>), the 2 <a href="#BOOKMARK14">reverse half-strand</a>s will quickly get walked over in one shot. A <a href="#BOOKMARK7">primer</a> gets attached to the <a href="#BOOKMARK10">ori</a>, then a <a href="#BOOKMARK6">DNA polymerase</a> attaches to that <a href="#BOOKMARK7">primer</a> to begin synthesis of a new strand. Synthesis continues until the <a href="#BOOKMARK12">ter</a> is reached...</p>
<p><img src="svgbob_83b0a64a4614fa906388ef166341e3fd293c6dc0.svg" alt="Kroki diagram output"></p>
<p>For the <a href="#BOOKMARK13">forward half-strand</a>s, the process is much slower. Since <a href="#BOOKMARK6">DNA polymerase</a> can only walk DNA in the reverse direction, the <a href="#BOOKMARK13">forward half-strand</a>s get replicated in small segments. That is, as the <a href="#BOOKMARK8">replication fork</a> continues to grow, every ~2000 nucleotides a new <a href="#BOOKMARK7">primer</a> attaches to the end of the fork on the forward strands. A new <a href="#BOOKMARK6">DNA polymerase</a> attaches to each <a href="#BOOKMARK7">primer</a> and walks in the reverse direction (towards the <a href="#BOOKMARK10">ori</a>) to synthesize a small segment of DNA. That small segment of DNA is called an <a href="#BOOKMARK17">Okazaki fragment</a>...</p>
<p><img src="svgbob_4c651d9aa100c5b586103bb0d42cc91ff27da474.svg" alt="Kroki diagram output"></p>
<p>The <a href="#BOOKMARK8">replication fork</a> will keep widening until the original 2 strands split off. <a href="#BOOKMARK6">DNA polymerase</a> will have made sure that for each separated strand, a newly synthesized reverse complement is paired to it. The end result is 2 daughter chromosome where each chromosome has gaps...</p>
<p><img src="svgbob_eac405c5709e835b492078d1ea557a7199d8f722.svg" alt="Kroki diagram output"></p>
<p>The <a href="#BOOKMARK17">Okazaki fragment</a>s synthesized on the forward strands end up getting sewn together by <a href="#BOOKMARK18">DNA ligase</a>...</p>
<p><img src="svgbob_5c3304d08cc6bbc226df966d6e1c119636331723.svg" alt="Kroki diagram output"></p>
<p>You now have two complete copies of the DNA.</p>
<a name="HEADREF13"></a><h3>Find Ori and Ter</h3>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li>GC Skew</li>
</ul>
</div>
<p>Since the <a href="#BOOKMARK13">forward half-strand</a> gets its reverse complement synthesized at a much slower rate than the <a href="#BOOKMARK14">reverse half-strand</a>, it stays single stranded for a much longer time. <a href="#BOOKMARK19">Single-stranded DNA</a> is 100 times more susceptible to mutations than <a href="#BOOKMARK20">double-stranded DNA</a>. Specifically, in <a href="#BOOKMARK19">single-stranded DNA</a>, C has a greater tendency to mutate to T. This process of mutation is referred to as deanimation.</p>
<p><img src="svgbob_f52124bb3b29a8388ed6a1fc5f597b26a2514f42.svg" alt="Kroki diagram output"></p>
<p>The <a href="#BOOKMARK14">reverse half-strand</a> spends much less time as a <a href="#BOOKMARK19">single-stranded DNA</a>. As such, it experiences much less C to T mutations.</p>
<p><img src="svgbob_7d778227822729bde64ce4a36b5cc9da206869c1.svg" alt="Kroki diagram output"></p>
<p>Ultimately, that means that a single strand will have a different nucleotide distribution between its <a href="#BOOKMARK13">forward half-strand</a> vs its <a href="#BOOKMARK14">backward half-strand</a>. If the half-strand being targeted for replication is the ...</p>
<ul>
<li><a href="#BOOKMARK13">forward half-strand</a>, some Cs get replaced with Ts. As such, its synthesized <a href="#BOOKMARK14">reverse half-strand</a> will have less Gs.</li>
<li><a href="#BOOKMARK14">reverse half-strand</a>, most Cs are kept. As such, its synthesized <a href="#BOOKMARK13">forward half-strand</a> will keep its Gs.</li>
</ul>
<p>To simplify, the ...</p>
<ul>
<li><a href="#BOOKMARK13">forward half-strand</a>: loses Cs, keeps Gs.</li>
<li><a href="#BOOKMARK14">reverse half-strand</a>: keeps Cs, loses Gs.</li>
</ul>
<p>You can use a GC skew diagram to help pinpoint where the <a href="#BOOKMARK10">ori</a> and <a href="#BOOKMARK12">ter</a> might be. The plot will typically form a peak where the <a href="#BOOKMARK12">ter</a> is (more G vs C) and form a valley where the <a href="#BOOKMARK10">ori</a> is (less G vs C). For example, the GC skew diagram for E. coli bacteria shows a distinct peak and distinct valley.</p>
<div style="border:1px solid black;">
<p></p>
<p>Calculating skew for: ...</p>
<p>Result: [0, 0, 1, 0,...</p>
<p><img src="skew_3b3ef8e0e7ef6297fdc10c525d5b0fbc.png" alt="GC Skew Plot"></p>
<p>Min position (ori): 4719166</p>
<p>Max position (ter): 2073768</p>
</div>
<p></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The material talks about how not all bacteria have a single peak and single valley. Some may have multiple. The reasoning for this still hasn't been discovered. It was speculated at one point that some bacteria may have multiple <a href="#BOOKMARK10">ori</a> / <a href="#BOOKMARK12">ter</a> regions.</p>
</div>
<a name="HEADREF14"></a><h3>Find the DnaA Box</h3>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li>Find <a href="#BOOKMARK10">Ori</a> and <a href="#BOOKMARK12">Ter</a></li>
<li>Find Repeating <a href="#BOOKMARK1">K-mer</a>s in Window</li>
</ul>
</div>
<p>Within the <a href="#BOOKMARK10">ori</a> region, there exists several copies of some <a href="#BOOKMARK1">k-mer</a> pattern. These copies are referred to as <a name="BOOKMARK0"></a><strong>DnaA box</strong>es.</p>
<p><img src="svgbob_d3e7c213995dec8a967fa89f40ebae73ed6e53ac.svg" alt="Kroki diagram output"></p>
<p>The DnaA protein binds to a <a href="#BOOKMARK0">DnaA box</a> to activate the process of DNA replication. Through experiments, biologists have determined that <a href="#BOOKMARK0">DnaA box</a>es are typical 9-mers.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The reason why multiple copies of the same <a href="#BOOKMARK1">k-mer</a> exist (<a href="#BOOKMARK0">DnaA box</a>) probably has to do with DNA mutation. If one of the copies mutates to a point where the DnaA protein no longer binds to it, it can still bind to the other copies.</p>
</div>
<p>For some bacterial organism, given that we've found the general vicinity of the <a href="#BOOKMARK10">ori</a> for that organism, we can search that vicinity for repeating 9-mers instances. The 9-mers may not match exactly -- the DnaA protein may bind to ...</p>
<ul>
<li>the 9-mer itself.</li>
<li>slight variations of the 9-mer.</li>
<li>the reverse complement of the 9-mer.</li>
<li>slight variations of the reverse complement of the 9-mer.</li>
</ul>
<p>The repeating <a href="#BOOKMARK1">k-mer</a>s found are potential <a href="#BOOKMARK0">DnaA box</a> candidates.</p>
<p>For example, we know where the general vicinity of the <a href="#BOOKMARK10">ori</a> is in E. coli given its GC skew. We can search the vicinity of the <a href="#BOOKMARK10">ori</a> for repeating <a href="#BOOKMARK1">k-mer</a>s.</p>
<div style="border:1px solid black;">
<p></p>
<p>Calculating skew for: ...</p>
<p>Result: [0, 0, 1, 0,...</p>
<p><img src="skew_3b3ef8e0e7ef6297fdc10c525d5b0fbc.png" alt="GC Skew Plot"></p>
<p>Ori vicinity (min pos): 4719166</p>
<p>In the ori vicinity, found clusters of k=9 (at least 3 occurrences in window of 500) in ... at...</p>
<ul>
<li>KmerCluster(kmer='CGGTGCTGG', start_index=9, occurrence_count=3)</li>
<li>KmerCluster(kmer='CCGCGCTGG', start_index=9, occurrence_count=3)</li>
<li>KmerCluster(kmer='TCGGCGGTA', start_index=52, occurrence_count=3)</li>
<li>KmerCluster(kmer='CTCGGCGGT', start_index=53, occurrence_count=3)</li>
<li>KmerCluster(kmer='CTGAAGATC', start_index=98, occurrence_count=3)</li>
<li>KmerCluster(kmer='AGGCGGTTC', start_index=160, occurrence_count=3)</li>
<li>KmerCluster(kmer='CAGGCGGAT', start_index=161, occurrence_count=3)</li>
<li>KmerCluster(kmer='CAGGCGGCT', start_index=161, occurrence_count=3)</li>
<li>KmerCluster(kmer='CAGGCGGGT', start_index=161, occurrence_count=3)</li>
<li>KmerCluster(kmer='CAGGCGGTT', start_index=161, occurrence_count=4)</li>
<li>KmerCluster(kmer='TCAGGCGGT', start_index=162, occurrence_count=4)</li>
<li>KmerCluster(kmer='ATCAGGCGG', start_index=163, occurrence_count=4)</li>
<li>KmerCluster(kmer='CATCAGGCG', start_index=164, occurrence_count=3)</li>
<li>KmerCluster(kmer='CCATCAGGC', start_index=165, occurrence_count=3)</li>
<li>KmerCluster(kmer='CGGCGATGG', start_index=199, occurrence_count=3)</li>
<li>KmerCluster(kmer='GGCGGTTCG', start_index=210, occurrence_count=3)</li>
<li>KmerCluster(kmer='GGCAGTACG', start_index=210, occurrence_count=3)</li>
<li>KmerCluster(kmer='GGCGGTATG', start_index=210, occurrence_count=3)</li>
<li>KmerCluster(kmer='CAGGCGGTT', start_index=212, occurrence_count=3)</li>
<li>KmerCluster(kmer='TCAGGCGGG', start_index=213, occurrence_count=3)</li>
<li>KmerCluster(kmer='TCAGGCGGC', start_index=213, occurrence_count=3)</li>
<li>KmerCluster(kmer='TCAGGCGGT', start_index=213, occurrence_count=3)</li>
<li>KmerCluster(kmer='TCAGGCGGA', start_index=213, occurrence_count=3)</li>
<li>KmerCluster(kmer='CTCAGGCGG', start_index=214, occurrence_count=3)</li>
<li>KmerCluster(kmer='TTCAGGCGG', start_index=214, occurrence_count=3)</li>
<li>KmerCluster(kmer='GTCAGGCGG', start_index=214, occurrence_count=3)</li>
<li>KmerCluster(kmer='ATCAGGCGG', start_index=214, occurrence_count=3)</li>
<li>KmerCluster(kmer='GGTCAGGCG', start_index=215, occurrence_count=3)</li>
<li>KmerCluster(kmer='CGGATCGTT', start_index=232, occurrence_count=3)</li>
<li>KmerCluster(kmer='CGGATCCTG', start_index=232, occurrence_count=3)</li>
<li>KmerCluster(kmer='CCGGATCGT', start_index=233, occurrence_count=3)</li>
<li>KmerCluster(kmer='GCGGATCCT', start_index=233, occurrence_count=3)</li>
<li>KmerCluster(kmer='AGCCGGATC', start_index=235, occurrence_count=3)</li>
<li>KmerCluster(kmer='GATCCTAAA', start_index=282, occurrence_count=3)</li>
<li>KmerCluster(kmer='TTTTGATAC', start_index=427, occurrence_count=3)</li>
<li>KmerCluster(kmer='TTCTTTTGA', start_index=430, occurrence_count=3)</li>
<li>KmerCluster(kmer='TGGCTGGGG', start_index=460, occurrence_count=3)</li>
<li>KmerCluster(kmer='ATCACCATT', start_index=500, occurrence_count=3)</li>
<li>KmerCluster(kmer='TCCTTTTTA', start_index=513, occurrence_count=3)</li>
<li>KmerCluster(kmer='ATCCTTTTT', start_index=514, occurrence_count=3)</li>
<li>KmerCluster(kmer='GATCCTTAT', start_index=515, occurrence_count=3)</li>
<li>KmerCluster(kmer='GATCCTTTT', start_index=515, occurrence_count=3)</li>
<li>KmerCluster(kmer='GGATCCTTT', start_index=516, occurrence_count=3)</li>
<li>KmerCluster(kmer='CTGATCCTT', start_index=517, occurrence_count=3)</li>
<li>KmerCluster(kmer='CCGATCCTT', start_index=517, occurrence_count=3)</li>
<li>KmerCluster(kmer='CGGATCATT', start_index=517, occurrence_count=3)</li>
<li>KmerCluster(kmer='AGGATCCTT', start_index=517, occurrence_count=3)</li>
<li>KmerCluster(kmer='CCGGATCCC', start_index=518, occurrence_count=3)</li>
<li>KmerCluster(kmer='CAGGATCCT', start_index=518, occurrence_count=3)</li>
<li>KmerCluster(kmer='CCCGGATCC', start_index=519, occurrence_count=3)</li>
<li>KmerCluster(kmer='TTATCCAGA', start_index=522, occurrence_count=3)</li>
<li>KmerCluster(kmer='CCAGGTTTT', start_index=529, occurrence_count=3)</li>
<li>KmerCluster(kmer='TCATTCTCA', start_index=611, occurrence_count=3)</li>
<li>KmerCluster(kmer='TCCCAGGTT', start_index=618, occurrence_count=3)</li>
<li>KmerCluster(kmer='ACAGATCTT', start_index=644, occurrence_count=3)</li>
<li>KmerCluster(kmer='AAACAGATC', start_index=646, occurrence_count=3)</li>
<li>KmerCluster(kmer='TCCAAATAA', start_index=653, occurrence_count=3)</li>
<li>KmerCluster(kmer='TTATTGATC', start_index=730, occurrence_count=3)</li>
<li>KmerCluster(kmer='GTTGTTGAG', start_index=731, occurrence_count=3)</li>
<li>KmerCluster(kmer='AGGATCAAC', start_index=769, occurrence_count=3)</li>
<li>KmerCluster(kmer='AGATCAACC', start_index=836, occurrence_count=3)</li>
</ul>
</div>
<p></p>
<p>TODO: RUN CODE TO LIST OUT THE <a href="#BOOKMARK1">KMER</a>S IN THE <a href="#BOOKMARK10">ORI</a></p>
<p>TODO: RUN CODE TO LIST OUT THE <a href="#BOOKMARK1">KMER</a>S IN THE <a href="#BOOKMARK10">ORI</a></p>
<p>TODO: RUN CODE TO LIST OUT THE <a href="#BOOKMARK1">KMER</a>S IN THE <a href="#BOOKMARK10">ORI</a></p>
<p>TODO: RUN CODE TO LIST OUT THE <a href="#BOOKMARK1">KMER</a>S IN THE <a href="#BOOKMARK10">ORI</a></p>
<p>TODO: RUN CODE TO LIST OUT THE <a href="#BOOKMARK1">KMER</a>S IN THE <a href="#BOOKMARK10">ORI</a></p>
<p>TODO: RUN CODE TO LIST OUT THE <a href="#BOOKMARK1">KMER</a>S IN THE <a href="#BOOKMARK10">ORI</a></p>
<p>TODO: RUN CODE TO LIST OUT THE <a href="#BOOKMARK1">KMER</a>S IN THE <a href="#BOOKMARK10">ORI</a></p>
<p>TODO: RUN CODE TO LIST OUT THE <a href="#BOOKMARK1">KMER</a>S IN THE <a href="#BOOKMARK10">ORI</a></p>
<a name="HEADREF15"></a><h1>Terminology</h1>
<ul>
<li>
<p>A <a name="BOOKMARK1"></a><strong>k-mer</strong> is a subsequence of length k within some larger biological sequence (e.g. DNA or amino acid chain). For example, in the DNA sequence <code>GAAATC</code>, the following <a href="#BOOKMARK1">k-mer</a>'s exist:</p>
<table>
<thead>
<tr>
<th>k</th>
<th><a href="#BOOKMARK1">k-mer</a>s</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>G A A A T C</td>
</tr>
<tr>
<td>2</td>
<td>GA AA AA AT TC</td>
</tr>
<tr>
<td>3</td>
<td>GAA AAA AAT ATC</td>
</tr>
<tr>
<td>4</td>
<td>GAAA AAAT AATC</td>
</tr>
<tr>
<td>5</td>
<td>GAAAT AAATC</td>
</tr>
<tr>
<td>6</td>
<td>GAAATC</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><a name="BOOKMARK2"></a><strong>5'</strong> (<a name="BOOKMARK3"></a><strong>5 prime</strong>) / <a name="BOOKMARK4"></a><strong>3'</strong> (<a name="BOOKMARK5"></a><strong>3 prime</strong>) - <a href="#BOOKMARK2">5'</a> (<a href="#BOOKMARK3">5 prime</a>) and <a href="#BOOKMARK4">3'</a> (<a href="#BOOKMARK5">3 prime</a>) describe the opposite ends of DNA. The chemical structure at each end is what defines if it's <a href="#BOOKMARK2">5'</a> or <a href="#BOOKMARK4">3'</a> -- each end is guaranteed to be different from the other. The forward direction on DNA is defined as <a href="#BOOKMARK2">5'</a> to <a href="#BOOKMARK4">3'</a>, while the backwards direction is <a href="#BOOKMARK4">3'</a> to <a href="#BOOKMARK2">5'</a>.</p>
<p>Two complementing DNA strands will always be attached in opposite directions.</p>
<p><img src="svgbob_a2c87a8f72a4ea21f474350dc6a429e386ae8222.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BOOKMARK6"></a><strong>DNA polymerase</strong> - An enzyme that replicates a strand of DNA. That is, <a href="#BOOKMARK6">DNA polymerase</a> walks over a single strand of DNA bases (not the strand of base pairs) and  generates a strand of complements. Before <a href="#BOOKMARK6">DNA polymerase</a> can attach itself and start replicating DNA, it requires a <a href="#BOOKMARK7">primer</a>.</p>
<p><img src="svgbob_971abfeff166ada9787cd484db9bfbe43120973a.svg" alt="Kroki diagram output"></p>
<p><a href="#BOOKMARK6">DNA polymerase</a> is unidirectional, meaning that it can only walk a DNA strand in one direction: reverse (<a href="#BOOKMARK4">3'</a> to <a href="#BOOKMARK2">5'</a>)</p>
</li>
<li>
<p><a name="BOOKMARK7"></a><strong>primer</strong> - A <a href="#BOOKMARK7">primer</a> is a short strand of RNA that binds to some larger strand of DNA (single bases, not a strand of base pairs) and allows DNA synthesis to  happen. That is, the <a href="#BOOKMARK7">primer</a> acts as the entry point for special enzymes <a href="#BOOKMARK6">DNA polymerase</a>s. <a href="#BOOKMARK6">DNA polymerase</a>s bind to the <a href="#BOOKMARK7">primer</a> to get access to the strand.</p>
</li>
<li>
<p><a name="BOOKMARK8"></a><strong>replication fork</strong> - The process of DNA replication requires that DNA's 2 complementing strands be unwound and split open. The area where the DNA starts to  split is called the <a href="#BOOKMARK8">replication fork</a>. In bacteria, the <a href="#BOOKMARK8">replication fork</a> starts at the <a href="#BOOKMARK9">replication origin</a> and keeps expanding until it reaches the <a href="#BOOKMARK11">replication terminus</a>.  Special enzymes called <a href="#BOOKMARK6">DNA polymerase</a>s walk over each unwound strand and create complementing strands.</p>
<p><img src="svgbob_fc7cf2c734fa0cab15b5746e25ad07e25f85ec64.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BOOKMARK9"></a><strong>replication origin</strong> (<a name="BOOKMARK10"></a><strong>ori</strong>) - The point in DNA at which replication starts.</p>
</li>
<li>
<p><a name="BOOKMARK11"></a><strong>replication terminus</strong> (<a name="BOOKMARK12"></a><strong>ter</strong>) - The point in DNA at which replication ends.</p>
</li>
<li>
<p><a name="BOOKMARK13"></a><strong>forward half-strand</strong> / <a name="BOOKMARK14"></a><strong>reverse half-strand</strong> - Bacteria are known to have a single chromosome of circular / looping DNA. In this DNA, the <a href="#BOOKMARK9">replication origin</a> (<a href="#BOOKMARK10">ori</a>) is the region of DNA where replication starts, while the <a href="#BOOKMARK11">replication terminus</a> (<a href="#BOOKMARK12">ter</a>) is where replication ends.</p>
<p><img src="svgbob_fb9438945a109c884df7ccc79d1d8051fd358a87.svg" alt="Kroki diagram output"></p>
<p>If you split up the DNA based on <a href="#BOOKMARK10">ori</a> and <a href="#BOOKMARK12">ter</a> being cutting points, you end up with 4 distinct strands. Given that the direction of a strand is <a href="#BOOKMARK2">5'</a> to <a href="#BOOKMARK4">3'</a>, if the direction of the strand starts at...</p>
<ul>
<li>
<p><a href="#BOOKMARK10">ori</a> and ends at <a href="#BOOKMARK12">ter</a>, it's called the <a href="#BOOKMARK13">forward half-strand</a>.</p>
<p><img src="svgbob_d97cf1f12de4bd77dbaf9eca708b0e9120e50b33.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a href="#BOOKMARK12">ter</a> and ends at <a href="#BOOKMARK10">ori</a>, it's called the <a href="#BOOKMARK14">reverse half-strand</a>.</p>
<p><img src="svgbob_0016146d0b3f1f6edf2724e9978d52de7057f5f4.svg" alt="Kroki diagram output"></p>
</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<ul>
<li><a href="#BOOKMARK13">Forward half-strand</a> is the same as <a href="#BOOKMARK16">lagging half-strand</a>.</li>
<li><a href="#BOOKMARK14">Reverse half-strand</a> is the same as <a href="#BOOKMARK15">leading half-strand</a>.</li>
</ul>
</div>
</li>
<li>
<p><a name="BOOKMARK15"></a><strong>leading half-strand</strong> / <a name="BOOKMARK16"></a><strong>lagging half-strand</strong> - Given the 2 strands tha make up a DNA molecule, the strand that goes in the...</p>
<ul>
<li>reverse direction (<a href="#BOOKMARK4">3'</a> to <a href="#BOOKMARK2">5'</a>) is called the <a href="#BOOKMARK15">leading half-strand</a>.</li>
<li>forward direction (<a href="#BOOKMARK2">5'</a> to <a href="#BOOKMARK4">3'</a>) is called the <a href="#BOOKMARK16">lagging half-strand</a>.</li>
</ul>
<p>This nomenclature has to do with <a href="#BOOKMARK6">DNA polymerase</a>. Since <a href="#BOOKMARK6">DNA polymerase</a> can only walk in the reverse direction (<a href="#BOOKMARK4">3'</a> to <a href="#BOOKMARK2">5'</a>), it synthesizes the <a href="#BOOKMARK15">leading half-strand</a> in one shot. For the <a href="#BOOKMARK16">lagging half-strand</a> (<a href="#BOOKMARK2">5'</a> to <a href="#BOOKMARK4">3'</a>), multiple <a href="#BOOKMARK6">DNA polymerase</a>s have to used to synthesize DNA, each binding to the lagging strand and walking backwards a small amount to generate a small fragment of DNA (<a href="#BOOKMARK17">Okazaki fragment</a>). the process is much slower for the <a href="#BOOKMARK16">lagging half-strand</a>, that's why it's called lagging.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<ul>
<li><a href="#BOOKMARK15">Leading half-strand</a> is the same as <a href="#BOOKMARK14">reverse half-strand</a>.</li>
<li><a href="#BOOKMARK16">Lagging half-strand</a> is the same as <a href="#BOOKMARK13">forward half-strand</a>.</li>
</ul>
</div>
</li>
<li>
<p><a name="BOOKMARK17"></a><strong>Okazaki fragment</strong> - A small fragment of DNA generated by <a href="#BOOKMARK6">DNA polymerase</a> for <a href="#BOOKMARK13">forward half-strand</a>s. DNA synthesis for the <a href="#BOOKMARK13">forward half-strand</a>s can only happen in small pieces. As the fork open ups every ~2000 nucleotides, <a href="#BOOKMARK6">DNA polymerase</a> attaches to the end of the fork on the <a href="#BOOKMARK13">forward half-strand</a> and walks in reverse to generate that small segment (<a href="#BOOKMARK6">DNA polymerase</a> can only walk in the reverse direction).</p>
</li>
<li>
<p><a name="BOOKMARK18"></a><strong>DNA ligase</strong> - An enzyme that sews together short segments of DNA called <a href="#BOOKMARK17">Okazaki fragment</a>s by binding the phosphate group on the end of one strand with the deoxyribose group on the other strand.</p>
</li>
<li>
<p><a name="BOOKMARK19"></a><strong>single stranded DNA</strong> - A single strand of DNA, not bound to a strand of its reverse complements.</p>
<p><img src="svgbob_03d83c0a0dd86c50ead48a0a8bc87eebf4353039.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BOOKMARK20"></a><strong>double stranded DNA</strong> - Two strands of DNA bound together, where each strand is the reverse complement of the other.</p>
<p><img src="svgbob_804f85f6da997959a08fd48d0e4d8356c8d476dd.svg" alt="Kroki diagram output"></p>
</li>
</ul>

        </body></html>