<!DOCTYPE html><html><head>
            <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
            <meta content="utf-8" http-equiv="encoding">
          <title>Bioinformatics
</title><link href="/.datadir_65c4776c20884922953aa28351b977e2/katex.min.css" rel="stylesheet"><meta name="viewport" content="width=device-width,initial-scale=1"><link href="/.temp_githib_css/github-markdown.css" rel="stylesheet"><link href="/.temp_highlightjs_css/default.css" rel="stylesheet"></head>
          <body class="markdown-body"><div class="toc">
<ul>
<li><a href="#HEADREF0">Introduction</a></li>
<li><a href="#HEADREF1">K-mer</a></li>
<ul>
<li><a href="#HEADREF2">Reverse Complement</a></li>
<li><a href="#HEADREF3">Hamming Distance</a></li>
<li><a href="#HEADREF4">Hamming Distance Neighbourhood</a></li>
<li><a href="#HEADREF5">Find Locations</a></li>
<li><a href="#HEADREF6">Find Clumps</a></li>
<li><a href="#HEADREF7">Find Repeating</a></li>
<li><a href="#HEADREF8">Find Repeating in Window</a></li>
<li><a href="#HEADREF9">Probability of Appearance</a></li>
<ul>
<li><a href="#HEADREF10">Bruteforce Algorithm</a></li>
<li><a href="#HEADREF11">Selection Estimate Algorithm</a></li>
</ul>
</ul>
<li><a href="#HEADREF12">GC Skew</a></li>
<li><a href="#HEADREF13">Motif</a></li>
<ul>
<li><a href="#HEADREF14">Consensus String</a></li>
<li><a href="#HEADREF15">Score Motif</a></li>
<ul>
<li><a href="#HEADREF16">Popularity Algorithm</a></li>
<li><a href="#HEADREF17">Entropy Algorithm</a></li>
</ul>
<li><a href="#HEADREF18">Find Motif</a></li>
<ul>
<li><a href="#HEADREF19">Bruteforce Algorithm</a></li>
<li><a href="#HEADREF20">Monte Carlo Search Algorithm</a></li>
<li><a href="#HEADREF21">Gibbs Sampling Search Algorithm</a></li>
</ul>
</ul>
<li><a href="#HEADREF22">Stories</a></li>
<ul>
<li><a href="#HEADREF23">Bacteria Replication</a></li>
<ul>
<li><a href="#HEADREF24">Find Ori and Ter</a></li>
<li><a href="#HEADREF25">Find the DnaA Box</a></li>
</ul>
</ul>
<li><a href="#HEADREF26">Terminology</a></li>
</ul>
</div>
<a name="HEADREF0"></a><h1>Introduction</h1>
<p>Bioinformatics is the science of transforming and processing biological data to gain new insights, particularly omics data: genomics, proteomics, metabolomics, etc.. Bioinformatics is mostly a mix of biology, computer science, and statistics / data science.</p>
<a name="HEADREF1"></a><h1>K-mer</h1>
<p><a name="BOOKMARK0"></a><strong></strong></p>
<p>A <a href="#BOOKMARK14">k-mer</a> is a subsequence of length k within some larger biological sequence (e.g. DNA or amino acid chain). For example, in the DNA sequence <code>GAAATC</code>, the following <a href="#BOOKMARK14">k-mer</a>'s exist:</p>
<table>
<thead>
<tr>
<th>k</th>
<th><a href="#BOOKMARK14">k-mer</a>s</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>G A A A T C</td>
</tr>
<tr>
<td>2</td>
<td>GA AA AA AT TC</td>
</tr>
<tr>
<td>3</td>
<td>GAA AAA AAT ATC</td>
</tr>
<tr>
<td>4</td>
<td>GAAA AAAT AATC</td>
</tr>
<tr>
<td>5</td>
<td>GAAAT AAATC</td>
</tr>
<tr>
<td>6</td>
<td>GAAATC</td>
</tr>
</tbody>
</table>
<p>Often times we'll need to either...</p>
<ul>
<li>search for an exact <a href="#BOOKMARK14">k-mer</a>.</li>
<li>search for an approximate <a href="#BOOKMARK14">k-mer</a> (fuzzy search).</li>
<li>find <a href="#BOOKMARK14">k-mer</a>s of interest in a sequence (e.g. repeating <a href="#BOOKMARK14">k-mer</a>s).</li>
</ul>
<a name="HEADREF2"></a><h2>Reverse Complement</h2>
<p><a name="BOOKMARK1"></a><strong></strong></p>
<p><strong>WHAT</strong>: Given a DNA <a href="#BOOKMARK14">k-mer</a>, calculate its reverse complement.</p>
<p><strong>WHY</strong>: Depending on the type of biological sequence, a <a href="#BOOKMARK14">k-mer</a> may have one or more alternatives. For DNA sequences specifically, a <a href="#BOOKMARK14">k-mer</a> of interest may have an alternate form. Since the DNA molecule comes as 2 strands, where ...</p>
<ul>
<li>each strand's direction is opposite of the other,</li>
<li>each strand position has a nucleotide that complements the nucleotide at that same position on the other stand:
<ul>
<li>A ⟷ T</li>
<li>C ⟷ G</li>
</ul>
</li>
</ul>
<p><img src="svgbob_c44b72fd8e03cfe92b63a0a3b83bfe37c5551666.svg" alt="Kroki diagram output"></p>
<p>, ... the reverse complement of that <a href="#BOOKMARK14">k-mer</a> may be just as valid as the original <a href="#BOOKMARK14">k-mer</a>. For example, if an enzyme is known to bind to a specific DNA <a href="#BOOKMARK14">k-mer</a>, it's possible that it might also bind to the reverse complement of that <a href="#BOOKMARK14">k-mer</a>.</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverse_complement</span>(<span class="hljs-params">strand: str</span>):</span>
    ret = <span class="hljs-string">''</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(strand)):
        base = strand[i]
        <span class="hljs-keyword">if</span> base == <span class="hljs-string">'A'</span> <span class="hljs-keyword">or</span> base == <span class="hljs-string">'a'</span>:
            base = <span class="hljs-string">'T'</span>
        <span class="hljs-keyword">elif</span> base == <span class="hljs-string">'T'</span> <span class="hljs-keyword">or</span> base == <span class="hljs-string">'t'</span>:
            base = <span class="hljs-string">'A'</span>
        <span class="hljs-keyword">elif</span> base == <span class="hljs-string">'C'</span> <span class="hljs-keyword">or</span> base == <span class="hljs-string">'c'</span>:
            base = <span class="hljs-string">'G'</span>
        <span class="hljs-keyword">elif</span> base == <span class="hljs-string">'G'</span> <span class="hljs-keyword">or</span> base == <span class="hljs-string">'g'</span>:
            base = <span class="hljs-string">'C'</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">'Unexpected base: '</span> + base)

        ret += base
    <span class="hljs-keyword">return</span> ret[::<span class="hljs-number">-1</span>]</code></pre><div style="border:1px solid black;">
<p></p>
<p>Original: TAATCCG</p>
<p>Reverse Complement: CGGATTA</p>
</div>
<p></p>
<a name="HEADREF3"></a><h2>Hamming Distance</h2>
<p><a name="BOOKMARK2"></a><strong></strong></p>
<p><strong>WHAT</strong>: Given 2 <a href="#BOOKMARK14">k-mer</a>s, the hamming distance is the number of positional mismatches between them.</p>
<p><strong>WHY</strong>: Imagine an enzyme that looks for a specific DNA <a href="#BOOKMARK14">k-mer</a> pattern to bind to. Since DNA is known to mutate, it may be that that enzyme can also bind to other <a href="#BOOKMARK14">k-mer</a> patterns that are slight variations of the original. For example, that enzyme may be able to bind to both AAACTG and AAAGTG.</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hamming_distance</span>(<span class="hljs-params">kmer1: str, kmer2: str</span>) -&gt; int:</span>
    mismatch = <span class="hljs-number">0</span>

    <span class="hljs-keyword">for</span> ch1, ch2 <span class="hljs-keyword">in</span> zip(kmer1, kmer2):
        <span class="hljs-keyword">if</span> ch1 != ch2:
            mismatch += <span class="hljs-number">1</span>

    <span class="hljs-keyword">return</span> mismatch</code></pre><div style="border:1px solid black;">
<p></p>
<p>Kmer1: ACTTTGTT</p>
<p>Kmer2: AGTTTCTT</p>
<p>Hamming Distance: 2</p>
</div>
<p></p>
<a name="HEADREF4"></a><h2>Hamming Distance Neighbourhood</h2>
<p><a name="BOOKMARK3"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BOOKMARK2">K-mer/Hamming Distance</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given a source <a href="#BOOKMARK14">k-mer</a> and a minimum hamming distance, find all <a href="#BOOKMARK14">k-mer</a>s such within the hamming distance of the source <a href="#BOOKMARK14">k-mer</a>. In other words, find all <a href="#BOOKMARK14">k-mer</a>s such that <code>hamming_distance(source_kmer, kmer) &lt;= min_distance</code>.</p>
<p><strong>WHY</strong>: Imagine an enzyme that looks for a specific DNA <a href="#BOOKMARK14">k-mer</a> pattern to bind to. Since DNA is known to mutate, it may be that that enzyme can also bind to other <a href="#BOOKMARK14">k-mer</a> patterns that are slight variations of the original. This algorithm finds all such variations.</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_all_dna_kmers_within_hamming_distance</span>(<span class="hljs-params">kmer: str, hamming_dist: int</span>) -&gt; set[str]:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recurse</span>(<span class="hljs-params">kmer: str, hamming_dist: int, output: set[str]</span>) -&gt; <span class="hljs-keyword">None</span>:</span>
        <span class="hljs-keyword">if</span> hamming_dist == <span class="hljs-number">0</span>:
            output.add(kmer)
            <span class="hljs-keyword">return</span>

        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(kmer)):
            <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> <span class="hljs-string">'ACTG'</span>:
                neighbouring_kmer = kmer[:i] + ch + kmer[i + <span class="hljs-number">1</span>:]
                recurse(neighbouring_kmer, hamming_dist - <span class="hljs-number">1</span>, output)

    output = set()
    recurse(kmer, hamming_dist, output)

    <span class="hljs-keyword">return</span> output</code></pre><div style="border:1px solid black;">
<p></p>
<p>Kmers within hamming distance 1 of AAAA: {'ACAA', 'ATAA', 'AGAA', 'AAGA', 'AAAC', 'AAAT', 'AATA', 'AACA', 'CAAA', 'AAAG', 'GAAA', 'TAAA', 'AAAA'}</p>
</div>
<p></p>
<a name="HEADREF5"></a><h2>Find Locations</h2>
<p><a name="BOOKMARK4"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BOOKMARK2">K-mer/Hamming Distance</a></li>
<li><a href="#BOOKMARK1">K-mer/Reverse Complement</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given a <a href="#BOOKMARK14">k-mer</a>, find where that <a href="#BOOKMARK14">k-mer</a> occurs in some larger sequence. The search may potentially include the <a href="#BOOKMARK14">k-mer</a>'s variants (e.g. reverse complement).</p>
<p><strong>WHY</strong>: Imagine that you know of a specific <a href="#BOOKMARK14">k-mer</a> pattern that serves some function in an organism. If you see that same <a href="#BOOKMARK14">k-mer</a> pattern appearing in some other related organism, it could be a sign that that <a href="#BOOKMARK14">k-mer</a> pattern serves a similar function. For example, the same <a href="#BOOKMARK14">k-mer</a> pattern could be used by 2 related types of bacteria as a <a href="#BOOKMARK13">DnaA box</a>.</p>
<p>The enzyme that operates on that <a href="#BOOKMARK14">k-mer</a> may also operate on its reverse complement as well as slight variations on that <a href="#BOOKMARK14">k-mer</a>. For example, if an enzyme binds to AAAAAAAAA, it may also bind to its...</p>
<ul>
<li>reverse complement: TTTTTTTTT</li>
<li>approximate variants: AAAAAAAAA, AAATAAAAA, AAAAAGAAA, ...</li>
<li>approximate variants of its reverse complements: TTTTTTTTT, TTTTTTATT, TTCTTTTTT, ...</li>
</ul>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Options</span>(<span class="hljs-params">NamedTuple</span>):</span>
    hamming_distance: int = <span class="hljs-number">0</span>
    reverse_complement: bool = <span class="hljs-literal">False</span>


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_kmer_locations</span>(<span class="hljs-params">sequence: str, kmer: str, options: Options = Options(<span class="hljs-params"></span>)</span>) -&gt; List[int]:</span>
    <span class="hljs-comment"># Construct test kmers</span>
    test_kmers = set()
    test_kmers.add(kmer)
    [test_kmers.add(alt_kmer) <span class="hljs-keyword">for</span> alt_kmer <span class="hljs-keyword">in</span> find_all_dna_kmers_within_hamming_distance(kmer, options.hamming_distance)]
    <span class="hljs-keyword">if</span> options.reverse_complement:
        rc_kmer = reverse_complement(kmer)
        [test_kmers.add(alt_rc_kmer) <span class="hljs-keyword">for</span> alt_rc_kmer <span class="hljs-keyword">in</span> find_all_dna_kmers_within_hamming_distance(rc_kmer, options.hamming_distance)]

    <span class="hljs-comment"># Slide over the sequence's kmers and check for matches against test kmers</span>
    k = len(kmer)
    idxes = []
    <span class="hljs-keyword">for</span> seq_kmer, i <span class="hljs-keyword">in</span> slide_window(sequence, k):
        <span class="hljs-keyword">if</span> seq_kmer <span class="hljs-keyword">in</span> test_kmers:
            idxes.append(i)
    <span class="hljs-keyword">return</span> idxes</code></pre><div style="border:1px solid black;">
<p></p>
<p>Found AAAA in AAAAGAACCTAATCTTAAAGGAGATGATGATTCTAA at index [0, 1, 2, 3, 12, 15, 16, 30]</p>
</div>
<p></p>
<a name="HEADREF6"></a><h2>Find Clumps</h2>
<p><a name="BOOKMARK5"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BOOKMARK4">K-mer/Find Locations</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given a <a href="#BOOKMARK14">k-mer</a>, find where that <a href="#BOOKMARK14">k-mer</a> clusters in some larger sequence. The search may potentially include the <a href="#BOOKMARK14">k-mer</a>'s variants (e.g. reverse complement).</p>
<p><strong>WHY</strong>: An enzyme may need to bind to a specific region of DNA to begin doing its job. That is, it looks for a specific <a href="#BOOKMARK14">k-mer</a> pattern to bind to, where that <a href="#BOOKMARK14">k-mer</a> represents the beginning of some larger DNA region that it operates on. Since DNA is known to mutate, often times you'll find multiple copies of the same <a href="#BOOKMARK14">k-mer</a> pattern clustered together -- if one copy mutated to become unusable, the other copies are still around.</p>
<p>For example, the <a href="#BOOKMARK13">DnaA box</a> is a special <a href="#BOOKMARK14">k-mer</a> pattern used by enzymes during DNA replication. Since DNA is known to mutate, the <a href="#BOOKMARK13">DnaA box</a> can be found repeating multiple times in the region of DNA known as the <a href="#BOOKMARK22">replication origin</a>. Finding the <a href="#BOOKMARK13">DnaA box</a> clustered in a small region is a good indicator that you've found the <a href="#BOOKMARK22">replication origin</a>.</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_kmer_clusters</span>(<span class="hljs-params">sequence: str, kmer: str, min_occurrence_in_cluster: int, cluster_window_size: int, options: Options = Options(<span class="hljs-params"></span>)</span>) -&gt; List[int]:</span>
    cluster_locs = []

    locs = find_kmer_locations(sequence, kmer, options)
    start_i = <span class="hljs-number">0</span>
    occurrence_count = <span class="hljs-number">1</span>
    <span class="hljs-keyword">for</span> end_i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(locs)):
        <span class="hljs-keyword">if</span> locs[end_i] - locs[start_i] &lt; cluster_window_size:  <span class="hljs-comment"># within a cluster window?</span>
            occurrence_count += <span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">if</span> occurrence_count &gt;= min_occurrence_in_cluster:  <span class="hljs-comment"># did the last cluster meet the min ocurr requirement?</span>
                cluster_locs.append(locs[start_i])
            start_i = end_i
            occurrence_count = <span class="hljs-number">1</span>

    <span class="hljs-keyword">return</span> cluster_locs</code></pre><div style="border:1px solid black;">
<p></p>
<p>Found clusters of GGG (at least 3 occurrences in window of 13) in GGGACTGAACAAACAAATTTGGGAGGGCACGGGTTAAAGGAGATGATGATTCAAAGGGT at index [19, 37]</p>
</div>
<p></p>
<a name="HEADREF7"></a><h2>Find Repeating</h2>
<p><a name="BOOKMARK6"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BOOKMARK1">K-mer/Reverse Complement</a></li>
<li><a href="#BOOKMARK3">K-mer/Hamming Distance Neighbourhood</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given a sequence, find clusters of unique <a href="#BOOKMARK14">k-mer</a>s within that sequence. In other words, for each unique <a href="#BOOKMARK14">k-mer</a> that exists in the sequence, see if it clusters in the sequence. The search may potentially include variants of <a href="#BOOKMARK14">k-mer</a> variants (e.g. reverse complements of the <a href="#BOOKMARK14">k-mer</a>s).</p>
<p><strong>WHY</strong>: An enzyme may need to bind to a specific region of DNA to begin doing its job. That is, it looks for a specific <a href="#BOOKMARK14">k-mer</a> pattern to bind to, where that <a href="#BOOKMARK14">k-mer</a> represents the beginning of some larger DNA region that it operates on. Since DNA is known to mutate, often times you'll find multiple copies of the same <a href="#BOOKMARK14">k-mer</a> pattern clustered together -- if one copy mutated to become unusable, the other copies are still around.</p>
<p>For example, the <a href="#BOOKMARK13">DnaA box</a> is a special <a href="#BOOKMARK14">k-mer</a> pattern used by enzymes during DNA replication. Since DNA is known to mutate, the <a href="#BOOKMARK13">DnaA box</a> can be found repeating multiple times in the region of DNA known as the <a href="#BOOKMARK22">replication origin</a>. Given that you don't know the <a href="#BOOKMARK14">k-mer</a> pattern for the <a href="#BOOKMARK13">DnaA box</a> but you do know the <a href="#BOOKMARK22">replication origin</a>, you can scan through the <a href="#BOOKMARK22">replication origin</a> for repeating <a href="#BOOKMARK14">k-mer</a> patterns. If a pattern is found to heavily repeat, it's a good candidate that it's the <a href="#BOOKMARK14">k-mer</a> pattern for the <a href="#BOOKMARK13">DnaA box</a>.</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-keyword">from</span> Utils <span class="hljs-keyword">import</span> slide_window


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">count_kmers</span>(<span class="hljs-params">data: str, k: int, options: Options = Options(<span class="hljs-params"></span>)</span>) -&gt; Counter[str]:</span>
    counter = Counter()
    <span class="hljs-keyword">for</span> kmer, i <span class="hljs-keyword">in</span> slide_window(data, k):
        neighbourhood = find_all_dna_kmers_within_hamming_distance(kmer, options.hamming_distance)
        <span class="hljs-keyword">for</span> neighbouring_kmer <span class="hljs-keyword">in</span> neighbourhood:
            counter[neighbouring_kmer] += <span class="hljs-number">1</span>

        <span class="hljs-keyword">if</span> options.reverse_complement:
            kmer_rc = reverse_complement(kmer)
            neighbourhood = find_all_dna_kmers_within_hamming_distance(kmer_rc, options.hamming_distance)
            <span class="hljs-keyword">for</span> neighbouring_kmer <span class="hljs-keyword">in</span> neighbourhood:
                counter[neighbouring_kmer] += <span class="hljs-number">1</span>

    <span class="hljs-keyword">return</span> counter


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">top_repeating_kmers</span>(<span class="hljs-params">data: str, k: int, options: Options = Options(<span class="hljs-params"></span>)</span>) -&gt; Set[str]:</span>
    counts = count_kmers(data, k, options)

    _, top_count = counts.most_common(<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]

    top_kmers = set()
    <span class="hljs-keyword">for</span> kmer, count <span class="hljs-keyword">in</span> counts.items():
        <span class="hljs-keyword">if</span> count == top_count:
            top_kmers.add((kmer, count))
    <span class="hljs-keyword">return</span> top_kmers</code></pre><div style="border:1px solid black;">
<p></p>
<p>Top 5-mer frequencies for GGGACTGAACAAACAAATTTGGGAGGGCACGGGTTAAAGGAGATGATGATTCAAAGGGT:</p>
<ul>
<li>AAGGG = 6 occurrences</li>
<li>CCCTT = 6 occurrences</li>
<li>GATCA = 6 occurrences</li>
<li>TTTAA = 6 occurrences</li>
<li>TTAAA = 6 occurrences</li>
<li>TGATC = 6 occurrences</li>
</ul>
</div>
<p></p>
<a name="HEADREF8"></a><h2>Find Repeating in Window</h2>
<p><a name="BOOKMARK7"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BOOKMARK6">K-mer/Find Repeating</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given a sequence, find regions within that sequence that contain clusters of unique <a href="#BOOKMARK14">k-mer</a>s. In other words, ...</p>
<ul>
<li>slide a window over the cluster.</li>
<li>for each unique <a href="#BOOKMARK14">k-mer</a> that exists in the window, see if it clusters in the sequence.</li>
</ul>
<p>The search may potentially include variants of <a href="#BOOKMARK14">k-mer</a> variants (e.g. reverse complements of the <a href="#BOOKMARK14">k-mer</a>s).</p>
<p><strong>WHY</strong>: An enzyme may need to bind to a specific region of DNA to begin doing its job. That is, it looks for a specific <a href="#BOOKMARK14">k-mer</a> pattern to bind to, where that <a href="#BOOKMARK14">k-mer</a> represents the beginning of some larger DNA region that it operates on. Since DNA is known to mutate, often times you'll find multiple copies of the same <a href="#BOOKMARK14">k-mer</a> pattern clustered together -- if one copy mutated to become unusable, the other copies are still around.</p>
<p>For example, the <a href="#BOOKMARK13">DnaA box</a> is a special <a href="#BOOKMARK14">k-mer</a> pattern used by enzymes during DNA replication. Since DNA is known to mutate, the <a href="#BOOKMARK13">DnaA box</a> can be found repeating multiple times in the region of DNA known as the <a href="#BOOKMARK22">replication origin</a>. Given that you don't know the <a href="#BOOKMARK14">k-mer</a> pattern for the <a href="#BOOKMARK13">DnaA box</a> but you do know the <a href="#BOOKMARK22">replication origin</a>, you can scan through the <a href="#BOOKMARK22">replication origin</a> for repeating <a href="#BOOKMARK14">k-mer</a> patterns. If a pattern is found to heavily repeat, it's a good candidate that it's the <a href="#BOOKMARK14">k-mer</a> pattern for the <a href="#BOOKMARK13">DnaA box</a>.</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">scan_for_repeating_kmers_in_clusters</span>(<span class="hljs-params">sequence: str, k: int, min_occurrence_in_cluster: int, cluster_window_size: int, options: Options = Options(<span class="hljs-params"></span>)</span>) -&gt; Set[KmerCluster]:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">neighborhood</span>(<span class="hljs-params">kmer: str</span>) -&gt; Set[str]:</span>
        neighbourhood = find_all_dna_kmers_within_hamming_distance(kmer, options.hamming_distance)
        <span class="hljs-keyword">if</span> options.reverse_complement:
            kmer_rc = reverse_complement(kmer)
            neighbourhood = find_all_dna_kmers_within_hamming_distance(kmer_rc, options.hamming_distance)
        <span class="hljs-keyword">return</span> neighbourhood

    kmer_counter = {}

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_kmer</span>(<span class="hljs-params">kmer: str, loc: int</span>) -&gt; <span class="hljs-keyword">None</span>:</span>
        <span class="hljs-keyword">if</span> kmer <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> kmer_counter:
            kmer_counter[kmer] = set()
        kmer_counter[kmer].add(window_idx + kmer_idx)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove_kmer</span>(<span class="hljs-params">kmer: str, loc: int</span>) -&gt; <span class="hljs-keyword">None</span>:</span>
        kmer_counter[kmer].remove(window_idx - <span class="hljs-number">1</span>)
        <span class="hljs-keyword">if</span> len(kmer_counter[kmer]) == <span class="hljs-number">0</span>:
            <span class="hljs-keyword">del</span> kmer_counter[kmer]

    clustered_kmers = set()

    old_first_kmer = <span class="hljs-literal">None</span>
    <span class="hljs-keyword">for</span> window, window_idx <span class="hljs-keyword">in</span> slide_window(sequence, cluster_window_size):
        first_kmer = window[<span class="hljs-number">0</span>:k]
        last_kmer = window[-k:]

        <span class="hljs-comment"># If first iteration, add all kmers</span>
        <span class="hljs-keyword">if</span> window_idx == <span class="hljs-number">0</span>:
            <span class="hljs-keyword">for</span> kmer, kmer_idx <span class="hljs-keyword">in</span> slide_window(window, k):
                <span class="hljs-keyword">for</span> alt_kmer <span class="hljs-keyword">in</span> neighborhood(kmer):
                    add_kmer(alt_kmer, window_idx + kmer_idx)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-comment"># Add kmer that was walked in to</span>
            <span class="hljs-keyword">for</span> new_last_kmer <span class="hljs-keyword">in</span> neighborhood(last_kmer):
                add_kmer(new_last_kmer, window_idx + cluster_window_size - k)
            <span class="hljs-comment"># Remove kmer that was walked out of</span>
            <span class="hljs-keyword">if</span> old_first_kmer <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
                <span class="hljs-keyword">for</span> alt_kmer <span class="hljs-keyword">in</span> neighborhood(old_first_kmer):
                    remove_kmer(alt_kmer, window_idx - <span class="hljs-number">1</span>)

        old_first_kmer = first_kmer

        <span class="hljs-comment"># Find clusters within window -- tuple is k-mer, start_idx, occurrence_count</span>
        [clustered_kmers.add(KmerCluster(k, min(v), len(v))) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> kmer_counter.items() <span class="hljs-keyword">if</span> len(v) &gt;= min_occurrence_in_cluster]

    <span class="hljs-keyword">return</span> clustered_kmers</code></pre><div style="border:1px solid black;">
<p></p>
<p>Found clusters of k=9 (at least 6 occurrences in window of 20) in TTTTTTTTTTTTTCCCTTTTTTTTTCCCTTTTTTTTTTTTT at...</p>
<ul>
<li>KmerCluster(kmer='AGAAAAAAA', start_index=0, occurrence_count=6)</li>
<li>KmerCluster(kmer='CAAAAAAAA', start_index=0, occurrence_count=6)</li>
<li>KmerCluster(kmer='AAAAAAAAA', start_index=0, occurrence_count=6)</li>
<li>KmerCluster(kmer='TAAAAAAAA', start_index=0, occurrence_count=6)</li>
<li>KmerCluster(kmer='GAAAAAAAA', start_index=0, occurrence_count=7)</li>
<li>KmerCluster(kmer='GAAAAAAAA', start_index=1, occurrence_count=6)</li>
<li>KmerCluster(kmer='AAAAAAAGA', start_index=26, occurrence_count=6)</li>
<li>KmerCluster(kmer='AAAAAAAAG', start_index=26, occurrence_count=6)</li>
<li>KmerCluster(kmer='AAAAAAAAG', start_index=26, occurrence_count=7)</li>
<li>KmerCluster(kmer='AAAAAAAAC', start_index=27, occurrence_count=6)</li>
<li>KmerCluster(kmer='AAAAAAAAT', start_index=27, occurrence_count=6)</li>
<li>KmerCluster(kmer='AAAAAAAAA', start_index=27, occurrence_count=6)</li>
</ul>
</div>
<p></p>
<a name="HEADREF9"></a><h2>Probability of Appearance</h2>
<p><a name="BOOKMARK8"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BOOKMARK4">K-mer/Find Locations</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given ...</p>
<ul>
<li>the length of a sequence (n)</li>
<li>a <a href="#BOOKMARK14">k-mer</a></li>
<li>a count (c)</li>
</ul>
<p>... find the probability of that <a href="#BOOKMARK14">k-mer</a> appearing at least c times within an arbitrary sequence of length n. For example, the probability that the 2-mer AA appears at least 2 times in a sequence of length 4:</p>
<ul>
<li>AAAA - yes</li>
<li>AAAT - yes</li>
<li>AAAC - yes</li>
<li>AAAG - yes</li>
<li>AATA - no</li>
<li>AATT - no</li>
<li>AATC - no</li>
<li>AATG - no</li>
<li>...</li>
<li>TAAA - yes</li>
<li>...</li>
<li>CAAA - yes</li>
<li>...</li>
<li>GAAA - yes</li>
<li>...</li>
<li>GGGA - no</li>
<li>GGGT - no</li>
<li>GGGC - no</li>
<li>GGGG - no</li>
</ul>
<p>The probability is 7/256.</p>
<p>This isn't trivial to accurately compute because the occurrences of a <a href="#BOOKMARK14">k-mer</a> within a sequence may overlap. For example, the number of times AA appears in AAAA is 3 while in CAAA it's 2.</p>
<p><strong>WHY</strong>: When a <a href="#BOOKMARK14">k-mer</a> is found within a sequence, knowing the probability of that <a href="#BOOKMARK14">k-mer</a> being found within an arbitrary sequence of the same length hints at the significance of the find. For example, if some 10-mer has a 0.2 chance of appearing in an arbitrary sequence of length 50, that's too high of a chance to consider it a significant find -- 0.2 means 1 in 5 chance that the 10-mer just randomly happens to appear.</p>
<a name="HEADREF10"></a><h3>Bruteforce Algorithm</h3>
<p><strong>ALGORITHM</strong>:</p>
<p>This algorithm tries every possible combination of sequence to find the probability. It falls over once the length of the sequence extends into the double digits. It's intended to help conceptualize what's going on.</p>
<pre class="hljs"><code><span class="hljs-comment"># Of the X sequence combinations tried, Y had the k-mer. The probability is Y/X.</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bruteforce_probability</span>(<span class="hljs-params">searchspace_len: int, searchspace_symbol_count: int, search_for: List[int], min_occurrence: int</span>) -&gt; (int, int):</span>
    found = <span class="hljs-number">0</span>
    found_max = searchspace_symbol_count ** searchspace_len

    str_to_search = [<span class="hljs-number">0</span>] * searchspace_len

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">count_instances</span>():</span>
        ret = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, searchspace_len - len(search_for) + <span class="hljs-number">1</span>):
            <span class="hljs-keyword">if</span> str_to_search[i:i + len(search_for)] == search_for:
                ret += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> ret

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">walk</span>(<span class="hljs-params">idx: int</span>):</span>
        <span class="hljs-keyword">nonlocal</span> found

        <span class="hljs-keyword">if</span> idx == searchspace_len:
            count = count_instances()
            <span class="hljs-keyword">if</span> count &gt;= min_occurrence:
                found += <span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, searchspace_symbol_count):
                walk(idx + <span class="hljs-number">1</span>)
                str_to_search[idx] += <span class="hljs-number">1</span>
            str_to_search[idx] = <span class="hljs-number">0</span>

    walk(<span class="hljs-number">0</span>)

    <span class="hljs-keyword">return</span> found, found_max</code></pre><div style="border:1px solid black;">
<p></p>
<p>Brute-forcing probability of ACTG in arbitrary sequence of length 8</p>
<p>Probability: 0.0195159912109375 (1279/65536)</p>
</div>
<p></p>
<a name="HEADREF11"></a><h3>Selection Estimate Algorithm</h3>
<p><strong>ALGORITHM</strong>:</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The explanation in the comments below are a bastardization of "1.13 Detour: Probabilities of Patterns in a String" in the Pevzner book...</p>
</div>
<p>This algorithm tries estimating the probability by ignoring the fact that the occurrences of a <a href="#BOOKMARK14">k-mer</a> in a sequence may overlap. For example, searching for the 2-mer AA in the sequence AAAT yields 2 instances of AA:</p>
<ul>
<li>[AA]AT</li>
<li>A[AA]T</li>
</ul>
<p>If we go ahead and ignore overlaps, we can think of the <a href="#BOOKMARK14">k-mer</a>s occurring in a string as insertions. For example, imagine a sequence of length 7 and the 2-mer AA. If we were to inject 2 instances of AA into the sequence to get it to reach length 7, how would that look?</p>
<p>2 instances of a 2-mer is 4 characters has a length of 5. To get the sequence to end up with a length of 7 after the insertions, the sequence needs to start with a length of 3:</p>
<pre><code>SSS
</code></pre>
<p>Given that we're changing reality to say that the instances WON'T overlap in the sequence, we can treat each instance of the 2-mer AA as a single entity being inserted. The number of ways that these 2 instances can be inserted into the sequence is 10:</p>
<pre><code>I = insertion of AA, S = arbitrary sequence character

IISSS  ISISS  ISSIS  ISSSI
SIISS  SISIS  SISSI
SSIIS  SSISI
SSSII
</code></pre>
<p>Another way to think of the above insertions is that they aren't insertions. Rather, we have 5 items in total and we're selecting 2 of them. How many ways can we select 2 of those 5 items? 10.</p>
<p>The number of ways to insert can be counted via the "binomial coefficient": <code>bc(m, k) = m!/(k!(m-k)!)</code>, where m is the total number of items (5 in the example above) and k is the number of selections (2 in the example above). For the example above:</p>
<pre><code>bc(5, 2) = 5!/(2!(5-2)!) = 10
</code></pre>
<p>Since the SSS can be any arbitrary nucleotide sequence of 3, we count the number of different representations that are possible for SSS: <code>4^3 = 4*4*4 = 64</code> (4^3, 4 because a nucleotide can be one of ACTG, 3 because the length is 3). In each of these representations, the 2-mer AA can be inserted in 10 different ways:</p>
<pre><code>64*10 = 640
</code></pre>
<p>Since the total length of the sequence is 7, we count the number of different representations that are possible:</p>
<pre><code>4^7 = 4*4*4*4*4*4*4 = 16384
</code></pre>
<p>The estimated probability is 640/16384. For non-overlapping <a href="#BOOKMARK14">k-mer</a>s the estimation will actually be "relatively accurate", while for overlapping <a href="#BOOKMARK14">k-mer</a>s not so much. Maybe try training a deep learning model to see if it can provide better estimates?</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">estimate_probability</span>(<span class="hljs-params">searchspace_len: int, searchspace_symbol_count: int, search_for: List[int], min_occurrence: int</span>) -&gt; float:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">factorial</span>(<span class="hljs-params">num</span>):</span>
        <span class="hljs-keyword">if</span> num == <span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> num
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> num * factorial(num - <span class="hljs-number">1</span>)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bc</span>(<span class="hljs-params">m, k</span>):</span>
        <span class="hljs-keyword">return</span> factorial(m) / (factorial(k) * factorial(m - k))

    k = len(search_for)
    n = (searchspace_len - min_occurrence * k)
    <span class="hljs-keyword">return</span> bc(n + min_occurrence, min_occurrence) * (searchspace_symbol_count ** n) / searchspace_symbol_count ** searchspace_len</code></pre><div style="border:1px solid black;">
<p></p>
<p>Estimating probability of ACTG in arbitrary sequence of length 8</p>
<p>Probability: 0.01953125</p>
</div>
<p></p>
<a name="HEADREF12"></a><h1>GC Skew</h1>
<p><strong>WHAT</strong>: Given a sequence, walk over it and ...</p>
<ul>
<li>increment every time you spot a G.</li>
<li>decrement every time you spot a C.</li>
</ul>
<p><strong>WHY</strong>: Given the DNA sequence of an organism, some segments may have lower count of Gs vs Cs.</p>
<p>During replication, some segments of DNA stay single-stranded for a much longer time than other segments. <a href="#BOOKMARK32">Single-stranded DNA</a> is 100 times more susceptible to mutations than <a href="#BOOKMARK33">double-stranded DNA</a>. Specifically, in <a href="#BOOKMARK32">single-stranded DNA</a>, C has a greater tendency to mutate to T. When that <a href="#BOOKMARK32">single-stranded DNA</a> re-binds to a neighbouring strand, the positions of any nucleotides that mutated from C to T will change on the neighbouring strand from G to A.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Recall that the reverse complements of ...</p>
<ul>
<li>C is G</li>
<li>A is T</li>
</ul>
<p>It mutated from C to T. Since its now T, its complement is A.</p>
</div>
<p>Plotting the skew lets you know the rough location of segments that stayed single-stranded for a longer period of time. That information hints at special / useful locations in the organism's DNA sequence (<a href="#BOOKMARK22">replication origin</a> / <a href="#BOOKMARK24">replication terminus</a>).</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gc_skew</span>(<span class="hljs-params">seq: str</span>):</span>
    counter = <span class="hljs-number">0</span>
    skew = [counter]
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(seq)):
        <span class="hljs-keyword">if</span> seq[i] == <span class="hljs-string">'G'</span>:
            counter += <span class="hljs-number">1</span>
            skew.append(counter)
        <span class="hljs-keyword">elif</span> seq[i] == <span class="hljs-string">'C'</span>:
            counter -= <span class="hljs-number">1</span>
            skew.append(counter)
        <span class="hljs-keyword">else</span>:
            skew.append(counter)
    <span class="hljs-keyword">return</span> skew</code></pre><div style="border:1px solid black;">
<p></p>
<p>Calculating skew for: ...</p>
<p>Result: [0, -1, -1,...</p>
<p><img src="skew_babf857bad6dd935f0d1ddbbb8b5005f.png" alt="GC Skew Plot"></p>
</div>
<p></p>
<a name="HEADREF13"></a><h1>Motif</h1>
<p><a name="BOOKMARK9"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BOOKMARK0">K-mer</a></li>
</ul>
</div>
<p>A <a href="#BOOKMARK47">motif</a> is a pattern that matches many different <a href="#BOOKMARK14">k-mer</a>s, where those matched <a href="#BOOKMARK14">k-mer</a>s have some shared biological significance. The pattern matches a fixed k where each position may have alternate forms. The simplest way to think of a <a href="#BOOKMARK47">motif</a> is a regex pattern without quantifiers. For example, the regex <code>[AT]TT[GC]C</code> may match to <code>ATTGC</code>, <code>ATTCC</code>, <code>TTTGC</code>, and <code>TTTCC</code>.</p>
<p>Often times we'll have identified a set of biological sequences where each sequence, we suspect, contains a <a href="#BOOKMARK14">k-mer</a> that matches some <a href="#BOOKMARK47">motif</a>. We'll need to find the <a href="#BOOKMARK14">k-mer</a>s and the <a href="#BOOKMARK47">motif</a> they match. For example, each of the following sequences contains a <a href="#BOOKMARK14">k-mer</a> that matches some <a href="#BOOKMARK47">motif</a>:</p>
<table>
<thead>
<tr>
<th>Sequences</th>
</tr>
</thead>
<tbody>
<tr>
<td>ATTGTTACCATAACCTTATTGCTAG</td>
</tr>
<tr>
<td>ATTCCTTTAGGACCACCCCAAACCC</td>
</tr>
<tr>
<td>CCCCAGGAGGGAACCTTTGCACACA</td>
</tr>
<tr>
<td>TATATATTTCCCACCCCAAGGGGGG</td>
</tr>
</tbody>
</table>
<p>The <a href="#BOOKMARK47">motif</a> is the one described above (<code>[AT]TT[GC]C</code>):</p>
<table>
<thead>
<tr>
<th>Sequences</th>
</tr>
</thead>
<tbody>
<tr>
<td>ATTGTTACCATAACCTT<strong>ATTGC</strong>TAG</td>
</tr>
<tr>
<td><strong>ATTCC</strong>TTTAGGACCACCCCAAACCC</td>
</tr>
<tr>
<td>CCCCAGGAGGGAACC<strong>TTTGC</strong>ACACA</td>
</tr>
<tr>
<td>TATATA<strong>TTTCC</strong>CACCCCAAGGGGGG</td>
</tr>
</tbody>
</table>
<p>A <a href="#BOOKMARK48">motif matrix</a> is a matrix of <a href="#BOOKMARK14">k-mer</a>s that are suspected to be part of a <a href="#BOOKMARK47">motif</a>. In the example sequences above, the <a href="#BOOKMARK48">motif matrix</a> would be:</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>T</td>
<td>T</td>
<td>G</td>
<td>C</td>
</tr>
<tr>
<td>A</td>
<td>T</td>
<td>T</td>
<td>C</td>
<td>C</td>
</tr>
<tr>
<td>T</td>
<td>T</td>
<td>T</td>
<td>G</td>
<td>C</td>
</tr>
<tr>
<td>T</td>
<td>T</td>
<td>T</td>
<td>C</td>
<td>C</td>
</tr>
</tbody>
</table>
<a name="HEADREF14"></a><h2>Consensus String</h2>
<p><a name="BOOKMARK10"></a><strong></strong></p>
<p><strong>WHAT</strong>: Given a <a href="#BOOKMARK48">motif matrix</a>, generate a <a href="#BOOKMARK14">k-mer</a> where each position is the nucleotide most abundant at that column of the matrix.</p>
<p><strong>WHY</strong>: Given a set of <a href="#BOOKMARK14">k-mer</a>s that are suspected to be part of a <a href="#BOOKMARK47">motif</a> (<a href="#BOOKMARK48">motif matrix</a>), the <a href="#BOOKMARK14">k-mer</a> generated by selecting the most abundant column at each index is the "ideal" <a href="#BOOKMARK14">k-mer</a> for the <a href="#BOOKMARK47">motif</a>. It's a concise way of describing the <a href="#BOOKMARK47">motif</a>, especially if the columns in the <a href="#BOOKMARK48">motif matrix</a> are highly conserved.</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_consensus_string</span>(<span class="hljs-params">kmers: List[str]</span>) -&gt; str:</span>
    count = len(kmers[<span class="hljs-number">0</span>]);
    out = <span class="hljs-string">''</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, count):
        c = Counter()
        <span class="hljs-keyword">for</span> kmer <span class="hljs-keyword">in</span> kmers:
            c[kmer[i]] += <span class="hljs-number">1</span>
        ch = c.most_common(<span class="hljs-number">1</span>)
        out += ch[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]
    <span class="hljs-keyword">return</span> out</code></pre><div style="border:1px solid black;">
<p></p>
<p>Consensus is TTTCC in <br><br> ATTGC<br>ATTCC<br>TTTGC<br>TTTCC<br>TTTCA</p>
</div>
<p></p>
<a name="HEADREF15"></a><h2>Score Motif</h2>
<p><a name="BOOKMARK11"></a><strong></strong></p>
<p><strong>WHAT</strong>: Given a <a href="#BOOKMARK48">motif matrix</a>, assign it a score based on how similar the <a href="#BOOKMARK14">k-mer</a>s that make up the matrix are to each other. Specifically, how conserved the nucleotides at each column are.</p>
<p><strong>WHY</strong>: Given a set of <a href="#BOOKMARK14">k-mer</a>s that are suspected to be part of a <a href="#BOOKMARK47">motif</a> (<a href="#BOOKMARK48">motif matrix</a>), the more similar those <a href="#BOOKMARK14">k-mer</a>s are to each other the more likely it is that those <a href="#BOOKMARK14">k-mer</a>s are members of the same <a href="#BOOKMARK47">motif</a>. This seems to be the case for many enzymes that bind to DNA based on a <a href="#BOOKMARK47">motif</a> (e.g. <a href="#BOOKMARK46">transcription factor</a>s).</p>
<a name="HEADREF16"></a><h3>Popularity Algorithm</h3>
<p><strong>ALGORITHM</strong>:</p>
<p>This algorithm scores a <a href="#BOOKMARK47">motif</a> by summing up the number of unpopular items in a column. For example, imagine a column has 7 Ts, 2 Cs, and 1A. The Ts are the most popular (7 items), meaning that the 3 items (2 Cs and 1 A) are unpopular -- the score for the column is 3.</p>
<p>Sum up each of the column scores to the get the final score for the <a href="#BOOKMARK48">motif matrix</a>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">score_motif</span>(<span class="hljs-params">motif_matrix: List[str]</span>) -&gt; int:</span>
    rows = len(motif_matrix)
    cols = len(motif_matrix[<span class="hljs-number">0</span>])

    <span class="hljs-comment"># count up each column</span>
    counter_per_col = []
    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, cols):
        counter = Counter()
        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, rows):
            counter[motif_matrix[r][c]] += <span class="hljs-number">1</span>
        counter_per_col.append(counter)

    <span class="hljs-comment"># sum counts for each column AFTER removing the top-most count -- that is, consider the top-most count as the</span>
    <span class="hljs-comment"># most popular char, so you're summing the counts of all the UNPOPULAR chars</span>
    unpopular_sums = []
    <span class="hljs-keyword">for</span> counter <span class="hljs-keyword">in</span> counter_per_col:
        most_popular_item = counter.most_common(<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]
        <span class="hljs-keyword">del</span> counter[most_popular_item]
        unpopular_sum = sum(counter.values())
        unpopular_sums.append(unpopular_sum)

    <span class="hljs-keyword">return</span> sum(unpopular_sums)</code></pre><div style="border:1px solid black;">
<p></p>
<p>Scoring...</p>
<p>ATTGC<br>TTTGC<br>TTTGG<br>ATTGC</p>
<p>3</p>
</div>
<p></p>
<a name="HEADREF17"></a><h3>Entropy Algorithm</h3>
<p><strong>ALGORITHM</strong>:</p>
<p>TODO FILL ME IN</p>
<p>TODO FILL ME IN</p>
<p>TODO FILL ME IN</p>
<p>TODO FILL ME IN</p>
<p>TODO FILL ME IN</p>
<p>TODO FILL ME IN</p>
<p>TODO FILL ME IN</p>
<p>TODO FILL ME IN</p>
<p>TODO FILL ME IN</p>
<p>TODO FILL ME IN</p>
<p>TODO FILL ME IN</p>
<p>TODO FILL ME IN</p>
<p>TODO FILL ME IN</p>
<p>TODO FILL ME IN</p>
<p>TODO FILL ME IN</p>
<a name="HEADREF18"></a><h2>Find Motif</h2>
<p><a name="BOOKMARK12"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BOOKMARK3">K-mer/Hamming Distance Neighbourhood</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given a set of sequences, identify <a href="#BOOKMARK14">k-mer</a>s in those sequences that may be members of the same <a href="#BOOKMARK47">motif</a>.</p>
<p><strong>WHY</strong>: A <a href="#BOOKMARK46">transcription factor</a> is an enzyme that either increases or decreases a <a href="#BOOKMARK34">gene</a>'s <a href="#BOOKMARK36">transcription</a> rate. It does so by binding to a specific part of the <a href="#BOOKMARK34">gene</a>'s upstream region called the <a href="#BOOKMARK50">transcription factor binding site</a>. That <a href="#BOOKMARK50">transcription factor binding site</a> consists of a <a href="#BOOKMARK14">k-mer</a> that matches the <a href="#BOOKMARK47">motif</a> expected by that <a href="#BOOKMARK46">transcription factor</a>, called a <a href="#BOOKMARK49">regulatory motif</a>.</p>
<p>A single <a href="#BOOKMARK46">transcription factor</a> may operate on many different <a href="#BOOKMARK34">genes</a>. Often times a scientist will identify a set of <a href="#BOOKMARK34">genes</a> that are suspected to be regulated by a single <a href="#BOOKMARK46">transcription factor</a>, but that scientist won't know ...</p>
<ul>
<li>what the <a href="#BOOKMARK49">regulatory motif</a> is (the pattern expected by the enzyme).</li>
<li>where the <a href="#BOOKMARK50">transcription factor binding site</a>s are (which <a href="#BOOKMARK14">k-mer</a>s the enzyme is targeting).</li>
<li>how long the <a href="#BOOKMARK50">transcription factor binding site</a>s are (which k the enzyme is targeting).</li>
</ul>
<p>The <a href="#BOOKMARK49">regulatory motif</a> expected by a <a href="#BOOKMARK46">transcription factor</a> typically expects <a href="#BOOKMARK14">k-mer</a>s that have the same length and are similar to each other (short hamming distance). As such, potential <a href="#BOOKMARK47">motif</a> candidates can be derived by identifying <a href="#BOOKMARK14">k-mer</a>s across the set of sequences that are similar to each other.</p>
<a name="HEADREF19"></a><h3>Bruteforce Algorithm</h3>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BOOKMARK3">K-mer/Hamming Distance Neighbourhood</a></li>
<li><a href="#BOOKMARK11">Motif/Score Motif</a></li>
</ul>
</div>
<p><strong>ALGORITHM</strong>:</p>
<p>This algorithm scans over all <a href="#BOOKMARK14">k-mer</a>s in a set of sequences, enumerates the hamming distance neighbourhood of each <a href="#BOOKMARK14">k-mer</a>, and uses the <a href="#BOOKMARK14">k-mer</a>s from the hamming distance neighbourhood to build out possible <a href="#BOOKMARK48">motif matrices</a>. Of all the <a href="#BOOKMARK48">motif matrices</a> built, it selects the one with the lowest score.</p>
<p>Neither k nor the mismatches allowed by the <a href="#BOOKMARK47">motif</a> is known. As such, the algorithm may need to be repeated multiple times with different value combinations.</p>
<p>Even for trivial inputs, this algorithm falls over very quickly. It's intended to help conceptualize the problem of <a href="#BOOKMARK47">motif</a> finding.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">enumerate_hamming_distance_neighbourhood_for_all_kmer</span>(<span class="hljs-params">
        dna: str,             <span class="hljs-comment"># dna strings to search in for motif</span>
        k: int,               <span class="hljs-comment"># k-mer length</span>
        max_mismatches: int   <span class="hljs-comment"># max num of mismatches for motif (hamming dist)</span>
</span>) -&gt; Set[str]:</span>
    kmers_to_check = set()
    <span class="hljs-keyword">for</span> kmer, _ <span class="hljs-keyword">in</span> slide_window(dna, k):
        neighbouring_kmers = find_all_dna_kmers_within_hamming_distance(kmer, max_mismatches)
        kmers_to_check |= neighbouring_kmers

    <span class="hljs-keyword">return</span> kmers_to_check

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exhaustive_motif_search</span>(<span class="hljs-params">dnas: List[str], k: int, max_mismatches: int</span>):</span>
    kmers_for_dnas = [enumerate_hamming_distance_neighbourhood_for_all_kmer(dna, k, max_mismatches) <span class="hljs-keyword">for</span> dna <span class="hljs-keyword">in</span> dnas]

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">build_next_matrix</span>(<span class="hljs-params">out_matrix: List[str]</span>):</span>
        idx = len(out_matrix)
        <span class="hljs-keyword">if</span> len(kmers_for_dnas) == idx:
            <span class="hljs-keyword">yield</span> out_matrix[:]
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">for</span> kmer <span class="hljs-keyword">in</span> kmers_for_dnas[idx]:
                out_matrix.append(kmer)
                <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> build_next_matrix(out_matrix)
                out_matrix.pop()

    best_motif = <span class="hljs-literal">None</span>
    <span class="hljs-keyword">for</span> next_motif <span class="hljs-keyword">in</span> build_next_matrix([]):
        <span class="hljs-keyword">if</span> best_motif <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> score_motif(next_motif) &lt; score_motif(best_motif):
            best_motif = next_motif

    <span class="hljs-keyword">return</span> best_motif</code></pre><div style="border:1px solid black;">
<p></p>
<p>Searching for motif of k=5 and a max of 1 mismatches in the following...</p>
<p>ATAAAGGGATA<br>ACAGAAATGAT<br>TGAAATAACCT</p>
<p>Found the motif matrix...</p>
<p>ATAAT<br>ATAAT<br>ATAAT</p>
</div>
<p></p>
<a name="HEADREF20"></a><h3>Monte Carlo Search Algorithm</h3>
<a name="HEADREF21"></a><h3>Gibbs Sampling Search Algorithm</h3>
<a name="HEADREF22"></a><h1>Stories</h1>
<a name="HEADREF23"></a><h2>Bacteria Replication</h2>
<p>Bacteria are known to have a single chromosome of circular / looping DNA. On that DNA, the <a href="#BOOKMARK22">replication origin</a> (<a href="#BOOKMARK23">ori</a>) is the region in which DNA replication starts, while the <a href="#BOOKMARK24">replication terminus</a> (<a href="#BOOKMARK25">ter</a>) is where it ends. The <a href="#BOOKMARK23">ori</a> and <a href="#BOOKMARK25">ter</a> and usually placed on opposite ends of each other.</p>
<p><img src="svgbob_308a4af4e5d6864abeb06f6652581aec0ff50fb1.svg" alt="Kroki diagram output"></p>
<p>The replication process begins by a <a href="#BOOKMARK21">replication fork</a> opening at the <a href="#BOOKMARK23">ori</a>. As replication happens, that fork widens until the point it reaches <a href="#BOOKMARK25">ter</a>...</p>
<p><img src="svgbob_fc7cf2c734fa0cab15b5746e25ad07e25f85ec64.svg" alt="Kroki diagram output"></p>
<p>For each forked <a href="#BOOKMARK32">single-stranded DNA</a>, <a href="#BOOKMARK19">DNA polymerase</a>s attach on and synthesize a new reverse complement strand so that it turns back into <a href="#BOOKMARK33">double-stranded DNA</a>....</p>
<p><img src="svgbob_971abfeff166ada9787cd484db9bfbe43120973a.svg" alt="Kroki diagram output"></p>
<p>The process of synthesizing a reverse complement strand is different based on the section of DNA that <a href="#BOOKMARK19">DNA polymerase</a> is operating on. For each <a href="#BOOKMARK32">single-stranded DNA</a>, if the direction of that DNA strand is traveling from ...</p>
<ul>
<li><a href="#BOOKMARK23">ori</a> to <a href="#BOOKMARK25">ter</a>, it's called a <a href="#BOOKMARK26">forward half-strand</a>.</li>
<li><a href="#BOOKMARK25">ter</a> to <a href="#BOOKMARK23">ori</a>, it's called a <a href="#BOOKMARK27">reverse half-strand</a>.</li>
</ul>
<p><img src="svgbob_ad11e0114c63955ab620cbe9a8dee61a85caa1f9.svg" alt="Kroki diagram output"></p>
<p>Since <a href="#BOOKMARK19">DNA polymerase</a> can only walk over DNA in the reverse direction (<a href="#BOOKMARK17">3'</a> to <a href="#BOOKMARK15">5'</a>), the 2 <a href="#BOOKMARK27">reverse half-strand</a>s will quickly get walked over in one shot. A <a href="#BOOKMARK20">primer</a> gets attached to the <a href="#BOOKMARK23">ori</a>, then a <a href="#BOOKMARK19">DNA polymerase</a> attaches to that <a href="#BOOKMARK20">primer</a> to begin synthesis of a new strand. Synthesis continues until the <a href="#BOOKMARK25">ter</a> is reached...</p>
<p><img src="svgbob_83b0a64a4614fa906388ef166341e3fd293c6dc0.svg" alt="Kroki diagram output"></p>
<p>For the <a href="#BOOKMARK26">forward half-strand</a>s, the process is much slower. Since <a href="#BOOKMARK19">DNA polymerase</a> can only walk DNA in the reverse direction, the <a href="#BOOKMARK26">forward half-strand</a>s get replicated in small segments. That is, as the <a href="#BOOKMARK21">replication fork</a> continues to grow, every ~2000 nucleotides a new <a href="#BOOKMARK20">primer</a> attaches to the end of the fork on the forward strands. A new <a href="#BOOKMARK19">DNA polymerase</a> attaches to each <a href="#BOOKMARK20">primer</a> and walks in the reverse direction (towards the <a href="#BOOKMARK23">ori</a>) to synthesize a small segment of DNA. That small segment of DNA is called an <a href="#BOOKMARK30">Okazaki fragment</a>...</p>
<p><img src="svgbob_4c651d9aa100c5b586103bb0d42cc91ff27da474.svg" alt="Kroki diagram output"></p>
<p>The <a href="#BOOKMARK21">replication fork</a> will keep widening until the original 2 strands split off. <a href="#BOOKMARK19">DNA polymerase</a> will have made sure that for each separated strand, a newly synthesized reverse complement is paired to it. The end result is 2 daughter chromosome where each chromosome has gaps...</p>
<p><img src="svgbob_eac405c5709e835b492078d1ea557a7199d8f722.svg" alt="Kroki diagram output"></p>
<p>The <a href="#BOOKMARK30">Okazaki fragment</a>s synthesized on the forward strands end up getting sewn together by <a href="#BOOKMARK31">DNA ligase</a>...</p>
<p><img src="svgbob_5c3304d08cc6bbc226df966d6e1c119636331723.svg" alt="Kroki diagram output"></p>
<p>You now have two complete copies of the DNA.</p>
<a name="HEADREF24"></a><h3>Find Ori and Ter</h3>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li>GC Skew</li>
</ul>
</div>
<p>Since the <a href="#BOOKMARK26">forward half-strand</a> gets its reverse complement synthesized at a much slower rate than the <a href="#BOOKMARK27">reverse half-strand</a>, it stays single stranded for a much longer time. <a href="#BOOKMARK32">Single-stranded DNA</a> is 100 times more susceptible to mutations than <a href="#BOOKMARK33">double-stranded DNA</a>. Specifically, in <a href="#BOOKMARK32">single-stranded DNA</a>, C has a greater tendency to mutate to T. This process of mutation is referred to as deanimation.</p>
<p><img src="svgbob_f52124bb3b29a8388ed6a1fc5f597b26a2514f42.svg" alt="Kroki diagram output"></p>
<p>The <a href="#BOOKMARK27">reverse half-strand</a> spends much less time as a <a href="#BOOKMARK32">single-stranded DNA</a>. As such, it experiences much less C to T mutations.</p>
<p><img src="svgbob_7d778227822729bde64ce4a36b5cc9da206869c1.svg" alt="Kroki diagram output"></p>
<p>Ultimately, that means that a single strand will have a different nucleotide distribution between its <a href="#BOOKMARK26">forward half-strand</a> vs its <a href="#BOOKMARK27">backward half-strand</a>. If the half-strand being targeted for replication is the ...</p>
<ul>
<li><a href="#BOOKMARK26">forward half-strand</a>, some Cs get replaced with Ts. As such, its synthesized <a href="#BOOKMARK27">reverse half-strand</a> will have less Gs.</li>
<li><a href="#BOOKMARK27">reverse half-strand</a>, most Cs are kept. As such, its synthesized <a href="#BOOKMARK26">forward half-strand</a> will keep its Gs.</li>
</ul>
<p>To simplify, the ...</p>
<ul>
<li><a href="#BOOKMARK26">forward half-strand</a>: loses Cs, keeps Gs.</li>
<li><a href="#BOOKMARK27">reverse half-strand</a>: keeps Cs, loses Gs.</li>
</ul>
<p>You can use a GC skew diagram to help pinpoint where the <a href="#BOOKMARK23">ori</a> and <a href="#BOOKMARK25">ter</a> might be. The plot will typically form a peak where the <a href="#BOOKMARK25">ter</a> is (more G vs C) and form a valley where the <a href="#BOOKMARK23">ori</a> is (less G vs C). For example, the GC skew diagram for E. coli bacteria shows a distinct peak and distinct valley.</p>
<div style="border:1px solid black;">
<p></p>
<p>Calculating skew for: ...</p>
<p>Result: [0, 0, 1, 0,...</p>
<p><img src="skew_3b3ef8e0e7ef6297fdc10c525d5b0fbc.png" alt="GC Skew Plot"></p>
<p>Min position (ori): 4719166</p>
<p>Max position (ter): 2073768</p>
</div>
<p></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The material talks about how not all bacteria have a single peak and single valley. Some may have multiple. The reasoning for this still hasn't been discovered. It was speculated at one point that some bacteria may have multiple <a href="#BOOKMARK23">ori</a> / <a href="#BOOKMARK25">ter</a> regions.</p>
</div>
<a name="HEADREF25"></a><h3>Find the DnaA Box</h3>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li>Find <a href="#BOOKMARK23">Ori</a> and <a href="#BOOKMARK25">Ter</a></li>
<li>Find Repeating <a href="#BOOKMARK14">K-mer</a>s in Window</li>
</ul>
</div>
<p>Within the <a href="#BOOKMARK23">ori</a> region, there exists several copies of some <a href="#BOOKMARK14">k-mer</a> pattern. These copies are referred to as <a name="BOOKMARK13"></a><strong>DnaA box</strong>es.</p>
<p><img src="svgbob_d3e7c213995dec8a967fa89f40ebae73ed6e53ac.svg" alt="Kroki diagram output"></p>
<p>The DnaA protein binds to a <a href="#BOOKMARK13">DnaA box</a> to activate the process of DNA replication. Through experiments, biologists have determined that <a href="#BOOKMARK13">DnaA box</a>es are typical 9-mers.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The reason why multiple copies of the same <a href="#BOOKMARK14">k-mer</a> exist (<a href="#BOOKMARK13">DnaA box</a>) probably has to do with DNA mutation. If one of the copies mutates to a point where the DnaA protein no longer binds to it, it can still bind to the other copies.</p>
</div>
<p>For some bacterial organism, given that we've found the general vicinity of the <a href="#BOOKMARK23">ori</a> for that organism, we can search that vicinity for repeating 9-mers instances. The 9-mers may not match exactly -- the DnaA protein may bind to ...</p>
<ul>
<li>the 9-mer itself.</li>
<li>slight variations of the 9-mer.</li>
<li>the reverse complement of the 9-mer.</li>
<li>slight variations of the reverse complement of the 9-mer.</li>
</ul>
<p>The repeating <a href="#BOOKMARK14">k-mer</a>s found are potential <a href="#BOOKMARK13">DnaA box</a> candidates.</p>
<p>For example, we know where the general vicinity of the <a href="#BOOKMARK23">ori</a> is in E. coli given its GC skew. We can search the vicinity of the <a href="#BOOKMARK23">ori</a> for repeating <a href="#BOOKMARK14">k-mer</a>s.</p>
<div style="border:1px solid black;">
<p></p>
<p>Calculating skew for: ...</p>
<p>Result: [0, 0, 1, 0,...</p>
<p><img src="skew_3b3ef8e0e7ef6297fdc10c525d5b0fbc.png" alt="GC Skew Plot"></p>
<p>Ori vicinity (min pos): 4719166</p>
<p>In the ori vicinity, found clusters of k=9 (at least 3 occurrences in window of 500) in ... at...</p>
<ul>
<li>KmerCluster(kmer='CCGCGCTGG', start_index=9, occurrence_count=3)</li>
<li>KmerCluster(kmer='CGGTGCTGG', start_index=9, occurrence_count=3)</li>
<li>KmerCluster(kmer='TCGGCGGTA', start_index=52, occurrence_count=3)</li>
<li>KmerCluster(kmer='CTCGGCGGT', start_index=53, occurrence_count=3)</li>
<li>KmerCluster(kmer='CTGAAGATC', start_index=98, occurrence_count=3)</li>
<li>KmerCluster(kmer='AGGCGGTTC', start_index=160, occurrence_count=3)</li>
<li>KmerCluster(kmer='CAGGCGGAT', start_index=161, occurrence_count=3)</li>
<li>KmerCluster(kmer='CAGGCGGCT', start_index=161, occurrence_count=3)</li>
<li>KmerCluster(kmer='CAGGCGGGT', start_index=161, occurrence_count=3)</li>
<li>KmerCluster(kmer='CAGGCGGTT', start_index=161, occurrence_count=4)</li>
<li>KmerCluster(kmer='TCAGGCGGT', start_index=162, occurrence_count=4)</li>
<li>KmerCluster(kmer='ATCAGGCGG', start_index=163, occurrence_count=4)</li>
<li>KmerCluster(kmer='CATCAGGCG', start_index=164, occurrence_count=3)</li>
<li>KmerCluster(kmer='CCATCAGGC', start_index=165, occurrence_count=3)</li>
<li>KmerCluster(kmer='CGGCGATGG', start_index=199, occurrence_count=3)</li>
<li>KmerCluster(kmer='GGCAGTACG', start_index=210, occurrence_count=3)</li>
<li>KmerCluster(kmer='GGCGGTTCG', start_index=210, occurrence_count=3)</li>
<li>KmerCluster(kmer='GGCGGTATG', start_index=210, occurrence_count=3)</li>
<li>KmerCluster(kmer='CAGGCGGTT', start_index=212, occurrence_count=3)</li>
<li>KmerCluster(kmer='TCAGGCGGT', start_index=213, occurrence_count=3)</li>
<li>KmerCluster(kmer='TCAGGCGGG', start_index=213, occurrence_count=3)</li>
<li>KmerCluster(kmer='TCAGGCGGC', start_index=213, occurrence_count=3)</li>
<li>KmerCluster(kmer='TCAGGCGGA', start_index=213, occurrence_count=3)</li>
<li>KmerCluster(kmer='ATCAGGCGG', start_index=214, occurrence_count=3)</li>
<li>KmerCluster(kmer='TTCAGGCGG', start_index=214, occurrence_count=3)</li>
<li>KmerCluster(kmer='CTCAGGCGG', start_index=214, occurrence_count=3)</li>
<li>KmerCluster(kmer='GTCAGGCGG', start_index=214, occurrence_count=3)</li>
<li>KmerCluster(kmer='GGTCAGGCG', start_index=215, occurrence_count=3)</li>
<li>KmerCluster(kmer='CGGATCCTG', start_index=232, occurrence_count=3)</li>
<li>KmerCluster(kmer='CGGATCGTT', start_index=232, occurrence_count=3)</li>
<li>KmerCluster(kmer='GCGGATCCT', start_index=233, occurrence_count=3)</li>
<li>KmerCluster(kmer='CCGGATCGT', start_index=233, occurrence_count=3)</li>
<li>KmerCluster(kmer='AGCCGGATC', start_index=235, occurrence_count=3)</li>
<li>KmerCluster(kmer='GATCCTAAA', start_index=282, occurrence_count=3)</li>
<li>KmerCluster(kmer='TTTTGATAC', start_index=427, occurrence_count=3)</li>
<li>KmerCluster(kmer='TTCTTTTGA', start_index=430, occurrence_count=3)</li>
<li>KmerCluster(kmer='TGGCTGGGG', start_index=460, occurrence_count=3)</li>
<li>KmerCluster(kmer='ATCACCATT', start_index=500, occurrence_count=3)</li>
<li>KmerCluster(kmer='TCCTTTTTA', start_index=513, occurrence_count=3)</li>
<li>KmerCluster(kmer='ATCCTTTTT', start_index=514, occurrence_count=3)</li>
<li>KmerCluster(kmer='GATCCTTAT', start_index=515, occurrence_count=3)</li>
<li>KmerCluster(kmer='GATCCTTTT', start_index=515, occurrence_count=3)</li>
<li>KmerCluster(kmer='GGATCCTTT', start_index=516, occurrence_count=3)</li>
<li>KmerCluster(kmer='CCGATCCTT', start_index=517, occurrence_count=3)</li>
<li>KmerCluster(kmer='AGGATCCTT', start_index=517, occurrence_count=3)</li>
<li>KmerCluster(kmer='CGGATCATT', start_index=517, occurrence_count=3)</li>
<li>KmerCluster(kmer='CTGATCCTT', start_index=517, occurrence_count=3)</li>
<li>KmerCluster(kmer='CAGGATCCT', start_index=518, occurrence_count=3)</li>
<li>KmerCluster(kmer='CCGGATCCC', start_index=518, occurrence_count=3)</li>
<li>KmerCluster(kmer='CCCGGATCC', start_index=519, occurrence_count=3)</li>
<li>KmerCluster(kmer='TTATCCAGA', start_index=522, occurrence_count=3)</li>
<li>KmerCluster(kmer='CCAGGTTTT', start_index=529, occurrence_count=3)</li>
<li>KmerCluster(kmer='TCATTCTCA', start_index=611, occurrence_count=3)</li>
<li>KmerCluster(kmer='TCCCAGGTT', start_index=618, occurrence_count=3)</li>
<li>KmerCluster(kmer='ACAGATCTT', start_index=644, occurrence_count=3)</li>
<li>KmerCluster(kmer='AAACAGATC', start_index=646, occurrence_count=3)</li>
<li>KmerCluster(kmer='TCCAAATAA', start_index=653, occurrence_count=3)</li>
<li>KmerCluster(kmer='TTATTGATC', start_index=730, occurrence_count=3)</li>
<li>KmerCluster(kmer='GTTGTTGAG', start_index=731, occurrence_count=3)</li>
<li>KmerCluster(kmer='AGGATCAAC', start_index=769, occurrence_count=3)</li>
<li>KmerCluster(kmer='AGATCAACC', start_index=836, occurrence_count=3)</li>
</ul>
</div>
<p></p>
<a name="HEADREF26"></a><h1>Terminology</h1>
<ul>
<li>
<p>A <a name="BOOKMARK14"></a><strong>k-mer</strong> is a subsequence of length k within some larger biological sequence (e.g. DNA or amino acid chain). For example, in the DNA sequence <code>GAAATC</code>, the following <a href="#BOOKMARK14">k-mer</a>'s exist:</p>
<table>
<thead>
<tr>
<th>k</th>
<th><a href="#BOOKMARK14">k-mer</a>s</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>G A A A T C</td>
</tr>
<tr>
<td>2</td>
<td>GA AA AA AT TC</td>
</tr>
<tr>
<td>3</td>
<td>GAA AAA AAT ATC</td>
</tr>
<tr>
<td>4</td>
<td>GAAA AAAT AATC</td>
</tr>
<tr>
<td>5</td>
<td>GAAAT AAATC</td>
</tr>
<tr>
<td>6</td>
<td>GAAATC</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><a name="BOOKMARK15"></a><strong>5'</strong> (<a name="BOOKMARK16"></a><strong>5 prime</strong>) / <a name="BOOKMARK17"></a><strong>3'</strong> (<a name="BOOKMARK18"></a><strong>3 prime</strong>) - <a href="#BOOKMARK15">5'</a> (<a href="#BOOKMARK16">5 prime</a>) and <a href="#BOOKMARK17">3'</a> (<a href="#BOOKMARK18">3 prime</a>) describe the opposite ends of DNA. The chemical structure at each end is what defines if it's <a href="#BOOKMARK15">5'</a> or <a href="#BOOKMARK17">3'</a> -- each end is guaranteed to be different from the other. The forward direction on DNA is defined as <a href="#BOOKMARK15">5'</a> to <a href="#BOOKMARK17">3'</a>, while the backwards direction is <a href="#BOOKMARK17">3'</a> to <a href="#BOOKMARK15">5'</a>.</p>
<p>Two complementing DNA strands will always be attached in opposite directions.</p>
<p><img src="svgbob_a2c87a8f72a4ea21f474350dc6a429e386ae8222.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BOOKMARK19"></a><strong>DNA polymerase</strong> - An enzyme that replicates a strand of DNA. That is, <a href="#BOOKMARK19">DNA polymerase</a> walks over a single strand of DNA bases (not the strand of base pairs) and  generates a strand of complements. Before <a href="#BOOKMARK19">DNA polymerase</a> can attach itself and start replicating DNA, it requires a <a href="#BOOKMARK20">primer</a>.</p>
<p><img src="svgbob_ac1f3f5c9441e395290e542abbc9256bed49302f.svg" alt="Kroki diagram output"></p>
<p><a href="#BOOKMARK19">DNA polymerase</a> is unidirectional, meaning that it can only walk a DNA strand in one direction: reverse (<a href="#BOOKMARK17">3'</a> to <a href="#BOOKMARK15">5'</a>)</p>
</li>
<li>
<p><a name="BOOKMARK20"></a><strong>primer</strong> - A <a href="#BOOKMARK20">primer</a> is a short strand of RNA that binds to some larger strand of DNA (single bases, not a strand of base pairs) and allows DNA synthesis to  happen. That is, the <a href="#BOOKMARK20">primer</a> acts as the entry point for special enzymes <a href="#BOOKMARK19">DNA polymerase</a>s. <a href="#BOOKMARK19">DNA polymerase</a>s bind to the <a href="#BOOKMARK20">primer</a> to get access to the strand.</p>
</li>
<li>
<p><a name="BOOKMARK21"></a><strong>replication fork</strong> - The process of DNA replication requires that DNA's 2 complementing strands be unwound and split open. The area where the DNA starts to  split is called the <a href="#BOOKMARK21">replication fork</a>. In bacteria, the <a href="#BOOKMARK21">replication fork</a> starts at the <a href="#BOOKMARK22">replication origin</a> and keeps expanding until it reaches the <a href="#BOOKMARK24">replication terminus</a>.  Special enzymes called <a href="#BOOKMARK19">DNA polymerase</a>s walk over each unwound strand and create complementing strands.</p>
<p><img src="svgbob_fc7cf2c734fa0cab15b5746e25ad07e25f85ec64.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BOOKMARK22"></a><strong>replication origin</strong> (<a name="BOOKMARK23"></a><strong>ori</strong>) - The point in DNA at which replication starts.</p>
</li>
<li>
<p><a name="BOOKMARK24"></a><strong>replication terminus</strong> (<a name="BOOKMARK25"></a><strong>ter</strong>) - The point in DNA at which replication ends.</p>
</li>
<li>
<p><a name="BOOKMARK26"></a><strong>forward half-strand</strong> / <a name="BOOKMARK27"></a><strong>reverse half-strand</strong> - Bacteria are known to have a single chromosome of circular / looping DNA. In this DNA, the <a href="#BOOKMARK22">replication origin</a> (<a href="#BOOKMARK23">ori</a>) is the region of DNA where replication starts, while the <a href="#BOOKMARK24">replication terminus</a> (<a href="#BOOKMARK25">ter</a>) is where replication ends.</p>
<p><img src="svgbob_fb9438945a109c884df7ccc79d1d8051fd358a87.svg" alt="Kroki diagram output"></p>
<p>If you split up the DNA based on <a href="#BOOKMARK23">ori</a> and <a href="#BOOKMARK25">ter</a> being cutting points, you end up with 4 distinct strands. Given that the direction of a strand is <a href="#BOOKMARK15">5'</a> to <a href="#BOOKMARK17">3'</a>, if the direction of the strand starts at...</p>
<ul>
<li>
<p><a href="#BOOKMARK23">ori</a> and ends at <a href="#BOOKMARK25">ter</a>, it's called the <a href="#BOOKMARK26">forward half-strand</a>.</p>
<p><img src="svgbob_d97cf1f12de4bd77dbaf9eca708b0e9120e50b33.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a href="#BOOKMARK25">ter</a> and ends at <a href="#BOOKMARK23">ori</a>, it's called the <a href="#BOOKMARK27">reverse half-strand</a>.</p>
<p><img src="svgbob_0016146d0b3f1f6edf2724e9978d52de7057f5f4.svg" alt="Kroki diagram output"></p>
</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<ul>
<li><a href="#BOOKMARK26">Forward half-strand</a> is the same as <a href="#BOOKMARK29">lagging half-strand</a>.</li>
<li><a href="#BOOKMARK27">Reverse half-strand</a> is the same as <a href="#BOOKMARK28">leading half-strand</a>.</li>
</ul>
</div>
</li>
<li>
<p><a name="BOOKMARK28"></a><strong>leading half-strand</strong> / <a name="BOOKMARK29"></a><strong>lagging half-strand</strong> - Given the 2 strands tha make up a DNA molecule, the strand that goes in the...</p>
<ul>
<li>reverse direction (<a href="#BOOKMARK17">3'</a> to <a href="#BOOKMARK15">5'</a>) is called the <a href="#BOOKMARK28">leading half-strand</a>.</li>
<li>forward direction (<a href="#BOOKMARK15">5'</a> to <a href="#BOOKMARK17">3'</a>) is called the <a href="#BOOKMARK29">lagging half-strand</a>.</li>
</ul>
<p>This nomenclature has to do with <a href="#BOOKMARK19">DNA polymerase</a>. Since <a href="#BOOKMARK19">DNA polymerase</a> can only walk in the reverse direction (<a href="#BOOKMARK17">3'</a> to <a href="#BOOKMARK15">5'</a>), it synthesizes the <a href="#BOOKMARK28">leading half-strand</a> in one shot. For the <a href="#BOOKMARK29">lagging half-strand</a> (<a href="#BOOKMARK15">5'</a> to <a href="#BOOKMARK17">3'</a>), multiple <a href="#BOOKMARK19">DNA polymerase</a>s have to used to synthesize DNA, each binding to the lagging strand and walking backwards a small amount to generate a small fragment of DNA (<a href="#BOOKMARK30">Okazaki fragment</a>). the process is much slower for the <a href="#BOOKMARK29">lagging half-strand</a>, that's why it's called lagging.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<ul>
<li><a href="#BOOKMARK28">Leading half-strand</a> is the same as <a href="#BOOKMARK27">reverse half-strand</a>.</li>
<li><a href="#BOOKMARK29">Lagging half-strand</a> is the same as <a href="#BOOKMARK26">forward half-strand</a>.</li>
</ul>
</div>
</li>
<li>
<p><a name="BOOKMARK30"></a><strong>Okazaki fragment</strong> - A small fragment of DNA generated by <a href="#BOOKMARK19">DNA polymerase</a> for <a href="#BOOKMARK26">forward half-strand</a>s. DNA synthesis for the <a href="#BOOKMARK26">forward half-strand</a>s can only happen in small pieces. As the fork open ups every ~2000 nucleotides, <a href="#BOOKMARK19">DNA polymerase</a> attaches to the end of the fork on the <a href="#BOOKMARK26">forward half-strand</a> and walks in reverse to generate that small segment (<a href="#BOOKMARK19">DNA polymerase</a> can only walk in the reverse direction).</p>
</li>
<li>
<p><a name="BOOKMARK31"></a><strong>DNA ligase</strong> - An enzyme that sews together short segments of DNA called <a href="#BOOKMARK30">Okazaki fragment</a>s by binding the phosphate group on the end of one strand with the deoxyribose group on the other strand.</p>
</li>
<li>
<p><a name="BOOKMARK32"></a><strong>single stranded DNA</strong> - A single strand of DNA, not bound to a strand of its reverse complements.</p>
<p><img src="svgbob_03d83c0a0dd86c50ead48a0a8bc87eebf4353039.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BOOKMARK33"></a><strong>double stranded DNA</strong> - Two strands of DNA bound together, where each strand is the reverse complement of the other.</p>
<p><img src="svgbob_b05df825cb791aaf67d96b4e629e42c02b75f509.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BOOKMARK34"></a><strong>gene</strong> - A segment of DNA that contains the instructions for either a protein or functional RNA.</p>
</li>
<li>
<p><a name="BOOKMARK35"></a><strong>gene product</strong> - The final synthesized material resulting from the instructions that make up a <a href="#BOOKMARK34">gene</a>. That synthesized material either being a protein or functional RNA.</p>
</li>
<li>
<p><a name="BOOKMARK36"></a><strong>transcription</strong> - The process of transcribing a <a href="#BOOKMARK34">gene</a> to RNA. Specifically, the enzyme RNA polymerase copies the segment of DNA that makes up that <a href="#BOOKMARK34">gene</a> to a strand of RNA.</p>
<p><img src="svgbob_0fed5f4215fb0a5da3d93da589650b84df3f9c09.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BOOKMARK37"></a><strong>translation</strong> - The process of translating mRNA to protein. Specifically, a ribosome takes in the mRNA generated by <a href="#BOOKMARK36">transcription</a> and outputs the protein that it codes for.</p>
<p><img src="svgbob_aeaffd032a869fcce0f71f969f22f2191880a88c.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BOOKMARK38"></a><strong>gene expression</strong> - The process by which a <a href="#BOOKMARK34">gene</a> is synthesized into a <a href="#BOOKMARK35">gene product</a>. When the <a href="#BOOKMARK35">gene product</a> is...</p>
<ul>
<li>a protein, the <a href="#BOOKMARK34">gene</a> is <a href="#BOOKMARK36">transcribed</a> to mRNA and <a href="#BOOKMARK37">translated</a> to a protein.</li>
<li>functional RNA, the <a href="#BOOKMARK34">gene</a> is <a href="#BOOKMARK36">transcribed</a> to a type of RNA that isn't mRNA (only mRNA is <a href="#BOOKMARK37">translated</a> to a protein).</li>
</ul>
<p><img src="svgbob_78b3833e37ddc45358bf3ebf79daba1a9e2604eb.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BOOKMARK39"></a><strong>regulatory gene</strong> / <a name="BOOKMARK40"></a><strong>regulatory protein</strong> - The proteins encoded by these <a href="#BOOKMARK34">genes</a> effect <a href="#BOOKMARK38">gene expression</a> for certain other <a href="#BOOKMARK34">genes</a>. That is, a <a href="#BOOKMARK40">regulatory protein</a> can cause certain other <a href="#BOOKMARK34">genes</a> to be expressed more (promote <a href="#BOOKMARK38">gene expression</a>) or less (repress <a href="#BOOKMARK38">gene expression</a>).</p>
<p><a href="#BOOKMARK39">Regulatory gene</a>s are often controlled by external factors (e.g. sunlight, nutrients, temperature, etc..)</p>
</li>
<li>
<p><a name="BOOKMARK41"></a><strong>feedback loop</strong> / <a name="BOOKMARK42"></a><strong>negative feedback loop</strong> / <a name="BOOKMARK43"></a><strong>positive feedback loop</strong> - A <a href="#BOOKMARK41">feedback loop</a> is a system where the output (or some part of the output) is fed back into the system to either promote or repress further outputs.</p>
<p><img src="svgbob_3ba8fa4d05a4b9ef40e13dd6d9c7d60ecb9705ad.svg" alt="Kroki diagram output"></p>
<p>A <a href="#BOOKMARK43">positive feedback loop</a> amplifies the output while a <a href="#BOOKMARK42">negative feedback loop</a> regulates the output. <a href="#BOOKMARK42">Negative feedback loop</a>s in particular are important in biology because they allow organisms to maintain homeostasis / equilibrium (keep a consistent internal state). For example, the system that regulates core temperatures in a human is a <a href="#BOOKMARK42">negative feedback loop</a>. If a human's core temperature gets too...</p>
<ul>
<li>low, they shiver to drive the temperature up.</li>
<li>high, they sweat to drive the temperature down.</li>
</ul>
<p>In the example above, the output is the core temperature. The body monitors its core temperature and employs mechanisms to bring it back to normal if it goes out of range (e.g. sweat, shiver). The outside temperature is influencing the body's core temperature as well as the internal shivering / sweating mechanisms the body employs.</p>
<p><img src="svgbob_894d108e9621a523aaed2c3a3d5d13d20871f1f3.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BOOKMARK44"></a><strong>circadian clock</strong> / <a name="BOOKMARK45"></a><strong>circadian oscillator</strong> - A biological clock that synchronizes roughly around the earth's day-night cycle. This internal clock helps many species regulate their physical and behavioural attributes. For example, hunt during the night vs sleep during the day (e.g. nocturnal owls).</p>
</li>
<li>
<p><a name="BOOKMARK46"></a><strong>transcription factor</strong> - A <a href="#BOOKMARK40">regulatory protein</a> that controls the rate of <a href="#BOOKMARK36">transcription</a> for some <a href="#BOOKMARK34">gene</a> that it has influence over (the copying of DNA to mRNA). The protein binds to a specific sequence in the <a href="#BOOKMARK34">gene</a>'s upstream region.</p>
</li>
<li>
<p><a name="BOOKMARK47"></a><strong>motif</strong> - A pattern that matches against many different <a href="#BOOKMARK14">k-mer</a>s, where those matched <a href="#BOOKMARK14">k-mer</a>s have some shared biological significance. The pattern matches a fixed k where each position may have alternate forms. The simplest way to think of a <a href="#BOOKMARK47">motif</a> is a regex pattern without quantifiers. For example, the regex <code>[AT]TT[GC]C</code> may match to <code>ATTGC</code>, <code>ATTCC</code>, <code>TTTGC</code>, and <code>TTTCC</code>.</p>
</li>
<li>
<p><a name="BOOKMARK48"></a><strong>motif matrix</strong> - A set of <a href="#BOOKMARK14">k-mer</a>s that form a <a href="#BOOKMARK47">motif</a>. For example, the <a href="#BOOKMARK47">motif</a> <code>[AT]TT[GC]C</code> has the following matrix:</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>T</td>
<td>T</td>
<td>G</td>
<td>C</td>
</tr>
<tr>
<td>A</td>
<td>T</td>
<td>T</td>
<td>C</td>
<td>C</td>
</tr>
<tr>
<td>T</td>
<td>T</td>
<td>T</td>
<td>G</td>
<td>C</td>
</tr>
<tr>
<td>T</td>
<td>T</td>
<td>T</td>
<td>C</td>
<td>C</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><a name="BOOKMARK49"></a><strong>regulatory motif</strong> / <a name="BOOKMARK50"></a><strong>transcription factor binding site</strong> - The binding site of a <a href="#BOOKMARK46">transcription factor</a>. A <a href="#BOOKMARK34">gene</a> that's regulated by a <a href="#BOOKMARK46">transcription factor</a> needs a sequence located in its upstream region that the <a href="#BOOKMARK46">transcription factor</a> can bind to. This sequence can take one of many forms, all of which are similar to each other but not exact (<a href="#BOOKMARK47">motif</a>). For example, the sequence being bound to could be either AAAACCCCT, AAAACCCCG, AAATCCCCT, etc..</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>A <a href="#BOOKMARK34">gene</a>'s upstream region is the 600 to 1000 nucleotides preceding the start of the <a href="#BOOKMARK34">gene</a>.</p>
</div>
</li>
<li>
<p><a name="BOOKMARK51"></a><strong>cDNA</strong> - A single strand of DNA generated from mRNA. The enzyme reverse transcriptase scans over the mRNA and creates the complementing single DNA strand.</p>
<p><img src="svgbob_97c5d076bf0a1cd98b75bbb88b72fc29c3b1b93d.svg" alt="Kroki diagram output"></p>
<p>The mRNA portion breaks off, leaving the <a href="#BOOKMARK32">single-stranded DNA</a>.</p>
<p><img src="svgbob_97e71090d31bdaa40278b0e705aef4e3555be8e3.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BOOKMARK52"></a><strong>DNA microarray</strong> / <a name="BOOKMARK53"></a><strong>DNA array</strong> - A device used to compare <a href="#BOOKMARK38">gene expression</a>. This works by measuring 2 mRNA samples against each other: a control sample and an experimental sample. The samples could be from...</p>
<ul>
<li>the same organism but at different times.</li>
<li>diseased and healthy versions of the same organism.</li>
<li>etc..</li>
</ul>
<p>Both mRNA samples are converted to <a href="#BOOKMARK51">cDNA</a> and are given fluorescent dyes. The control sample gets dyed green while the experimental sample gets dyed red.</p>
<p><img src="svgbob_6ce607591d81d0fd6c7507408e97fb8146e83baf.svg" alt="Kroki diagram output"></p>
<p>A sheet is broken up into multiple regions, where each region has the <a href="#BOOKMARK51">cDNA</a> for one specific <a href="#BOOKMARK34">gene</a> from the control sample printed.</p>
<p><img src="svgbob_421210658cf3b4d0040b4815e879948ebfd7ccc5.svg" alt="Kroki diagram output"></p>
<p>The idea is that once the experimental <a href="#BOOKMARK51">cDNA</a> is introduced to that region, it should bind to the control <a href="#BOOKMARK51">cDNA</a> that's been printed to form <a href="#BOOKMARK33">double-stranded DNA</a>. The color emitted in a region should correspond to the amount of <a href="#BOOKMARK38">gene expression</a> for the <a href="#BOOKMARK34">gene</a> that region represents. For example, if a region on the sheet is fully yellow, it means that the <a href="#BOOKMARK38">gene expression</a> for that <a href="#BOOKMARK34">gene</a> is roughly equal (red mixed with green is yellow).</p>
</li>
<li>
<p><a name="BOOKMARK54"></a><strong>greedy algorithm</strong> - An algorithm that tries to speed things up by taking the locally optimum choice at each step. That is, the algorithm doesn't look more than 1 step ahead.</p>
<p>For example, imagine a chess playing AI that had a strategy of trying to eliminate the other player's most valuable piece at each turn. It would be considered greedy because it only looks 1 move ahead before taking action. Normal chess AIs / players look many moves ahead before taking action. As such, the greedy AI may be fast but it would very likely lose most matches.</p>
</li>
<li>
<p><a name="BOOKMARK55"></a><strong>Cromwell's rule</strong> - When a probability is based off past events, 0.0 and 1.0 shouldn't be used. That is, if you've...</p>
<ul>
<li>never seen an even occur in the past, it doesn't mean that there's a 0.0 probability of it occurring next.</li>
<li>always seen an event occur in the past, it doesn't mean that there's a 1.0 probability of it occurring next.</li>
</ul>
<p>Unless you're dealing with hard logical statements where prior occurrences don't come in to play (e.g. 1+1=2), you should include a small chance that some extremely unlikely event may happen. The example tossed around is "the probability that the sun will not rise tomorrow." Prior recorded observations show that that sun has always risen, but that doesn't mean that there's a 1.0 probability of the sun rising tomorrow (e.g. some extremely unlikely cataclysmic event may prevent the sun from rising).</p>
</li>
<li>
<p><a name="BOOKMARK56"></a><strong>Laplace's rule of succession</strong> - If some independent true/false event occurs n times, and s of those n times were successes, it's natural for people to assume the probability of success is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>s</mi><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{s}{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>. However, if the number of successes is 0, the probability would be 0.0. <a href="#BOOKMARK55">Cromwell's rule</a> states that when a probability is based off past events, 0.0 and 1.0 shouldn't be used. As such, a more appropriate / meaningful measure of probability is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow><mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{s+1}{n+2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2484389999999999em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>.</p>
<p>For example, imagine you're sitting on a park bench having lunch. Of the 8 birds you've seen since starting your lunch, all have been pigeons. If you were to calculate the probability that the next bird you'll see a crow, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>0</mn><mn>8</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{0}{8}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> would be flawed because it states that there's no chance that the next bird will be a crow (there obviously is a chance, but it may be a small chance). Instead, applying <a href="#BOOKMARK56">Laplace's rule</a> allows for the small probability that a crow may be seen next: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mn>0</mn><mo>+</mo><mn>1</mn></mrow><mrow><mn>8</mn><mo>+</mo><mn>2</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{0+1}{8+2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2484389999999999em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>.</p>
<p><a href="#BOOKMARK56">Laplace's rule of succession</a> is more meaningful when the number of trials (n) is small.</p>
</li>
<li>
<p><a name="BOOKMARK57"></a><strong>pseudocount</strong> - When a zero is replaced with a small number to prevent unfair scoring. See <a href="#BOOKMARK56">Laplace's rule of succession</a>.</p>
</li>
<li>
<p><a name="BOOKMARK58"></a><strong>randomized algorithm</strong> - An algorithm that uses a source of randomness as part of its logic. <a href="#BOOKMARK58">Randomized algorithm</a>s come in two forms: <a href="#BOOKMARK59">Las Vegas algorithm</a>s and <a href="#BOOKMARK60">Monte Carlo algorithm</a>s</p>
</li>
<li>
<p><a name="BOOKMARK59"></a><strong>Las Vegas algorithm</strong> - A <a href="#BOOKMARK58">randomized algorithm</a> that delivers a guaranteed exact solution. That is, even though the algorithm makes random decisions it is guaranteed to converge on the exact solution to the problem its trying to solve (not an approximate solution).</p>
<p>An example of a <a href="#BOOKMARK59">Las Vegas algorithm</a> is randomized quicksort (randomness is applied when choosing the pivot).</p>
</li>
<li>
<p><a name="BOOKMARK60"></a><strong>Monte Carlo algorithm</strong> - A <a href="#BOOKMARK58">randomized algorithm</a> that delivers an approximate solution. Because these algorithms are quick, they're typically run many times. The approximation considered the best out of all runs is the one that gets chosen as the solution.</p>
<p>An example of a <a href="#BOOKMARK60">Monte Carlo algorithm</a> is a genetic algorithm to optimize the weights of a deep neural network. That is, a step of the optimization requires running n different neural networks to see which gives the best result, then replacing those n networks with n copies of the best performing network where each copy has randomly tweaked weights. At some point the algorithm will stop producing incrementally better results.</p>
<p>Perform the optimization (the entire thing, not just a single step) thousands of times and pick the best network.</p>
</li>
<li>
<p><a name="BOOKMARK61"></a><strong>consensus string</strong> - The <a href="#BOOKMARK14">k-mer</a> generated by selecting the most abundant column at each index of a <a href="#BOOKMARK48">motif matrix</a>.</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#BOOKMARK14">k-mer</a> 1</td>
<td>A</td>
<td>T</td>
<td>T</td>
<td>G</td>
<td>C</td>
</tr>
<tr>
<td><a href="#BOOKMARK14">k-mer</a> 2</td>
<td>A</td>
<td>T</td>
<td>T</td>
<td>C</td>
<td>C</td>
</tr>
<tr>
<td><a href="#BOOKMARK14">k-mer</a> 3</td>
<td>T</td>
<td>T</td>
<td>T</td>
<td>G</td>
<td>C</td>
</tr>
<tr>
<td><a href="#BOOKMARK14">k-mer</a> 4</td>
<td>T</td>
<td>T</td>
<td>T</td>
<td>C</td>
<td>C</td>
</tr>
<tr>
<td><a href="#BOOKMARK14">k-mer</a> 5</td>
<td>A</td>
<td>T</td>
<td>T</td>
<td>C</td>
<td>G</td>
</tr>
<tr>
<td>consensus</td>
<td>A</td>
<td>T</td>
<td>T</td>
<td>C</td>
<td>C</td>
</tr>
</tbody>
</table>
</li>
</ul>

        </body></html>