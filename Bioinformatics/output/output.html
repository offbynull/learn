<!DOCTYPE html><html><head>
            <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
            <meta content="utf-8" http-equiv="encoding">
          <title>Bioinformatics
</title><link href="/.datadir_65c4776c20884922953aa28351b977e2/katex.min.css" rel="stylesheet"><meta name="viewport" content="width=device-width,initial-scale=1"><link href="/.temp_githib_css/github-markdown.css" rel="stylesheet"><link href="/.temp_highlightjs_css/default.css" rel="stylesheet"></head>
          <body class="markdown-body"><div class="toc">
<ul>
<li><a href="#H_Introduction">Introduction</a></li>
<li><a href="#H_Algorithms">Algorithms</a></li>
<ul>
<li><a href="#H_K-mer">K-mer</a></li>
<ul>
<li><a href="#H_Reverse%20Complement">Reverse Complement</a></li>
<li><a href="#H_Hamming%20Distance">Hamming Distance</a></li>
<li><a href="#H_Hamming%20Distance%20Neighbourhood">Hamming Distance Neighbourhood</a></li>
<li><a href="#H_Find%20Locations">Find Locations</a></li>
<li><a href="#H_Find%20Clumps">Find Clumps</a></li>
<li><a href="#H_Find%20Repeating">Find Repeating</a></li>
<li><a href="#H_Find%20Repeating%20in%20Window">Find Repeating in Window</a></li>
<li><a href="#H_Probability%20of%20Appearance">Probability of Appearance</a></li>
<ul>
<li><a href="#H_Bruteforce%20Algorithm">Bruteforce Algorithm</a></li>
<li><a href="#H_Selection%20Estimate%20Algorithm">Selection Estimate Algorithm</a></li>
</ul>
</ul>
<li><a href="#H_GC%20Skew">GC Skew</a></li>
<li><a href="#H_Motif">Motif</a></li>
<ul>
<li><a href="#H_Consensus%20String">Consensus String</a></li>
<li><a href="#H_Motif%20Matrix%20Count">Motif Matrix Count</a></li>
<li><a href="#H_Motif%20Matrix%20Profile">Motif Matrix Profile</a></li>
<li><a href="#H_Motif%20Matrix%20Score">Motif Matrix Score</a></li>
<ul>
<li><a href="#H_Popularity%20Algorithm">Popularity Algorithm</a></li>
<li><a href="#H_Entropy%20Algorithm">Entropy Algorithm</a></li>
<li><a href="#H_Relative%20Entropy%20Algorithm">Relative Entropy Algorithm</a></li>
</ul>
<li><a href="#H_Motif%20Logo">Motif Logo</a></li>
<li><a href="#H_K-mer%20Match%20Probability">K-mer Match Probability</a></li>
<li><a href="#H_Find%20Motif%20Matrix">Find Motif Matrix</a></li>
<ul>
<li><a href="#H1_Bruteforce%20Algorithm">Bruteforce Algorithm</a></li>
<li><a href="#H_Median%20String%20Algorithm">Median String Algorithm</a></li>
<li><a href="#H_Greedy%20Algorithm">Greedy Algorithm</a></li>
<li><a href="#H_Randomized%20Algorithm">Randomized Algorithm</a></li>
<li><a href="#H_Gibbs%20Sampling%20Algorithm">Gibbs Sampling Algorithm</a></li>
</ul>
<li><a href="#H_Motif%20Matrix%20Hybrid%20Alphabet">Motif Matrix Hybrid Alphabet</a></li>
</ul>
<li><a href="#H_Assembly">Assembly</a></li>
<ul>
<li><a href="#H_Stitch%20Reads">Stitch Reads</a></li>
<li><a href="#H_Stitch%20Read-Pairs">Stitch Read-Pairs</a></li>
<li><a href="#H_Break%20Reads">Break Reads</a></li>
<li><a href="#H_Break%20Read-Pairs">Break Read-Pairs</a></li>
<li><a href="#H_Probability%20of%20Fragment%20Occurrence">Probability of Fragment Occurrence</a></li>
<li><a href="#H_Overlap%20Graph">Overlap Graph</a></li>
<li><a href="#H_De%20Bruijn%20Graph">De Bruijn Graph</a></li>
<li><a href="#H_Find%20Bubbles">Find Bubbles</a></li>
<li><a href="#H_Find%20Contigs">Find Contigs</a></li>
</ul>
</ul>
<li><a href="#H_Stories">Stories</a></li>
<ul>
<li><a href="#H_Bacteria%20Replication">Bacteria Replication</a></li>
<ul>
<li><a href="#H_Find%20Ori%20and%20Ter">Find Ori and Ter</a></li>
<li><a href="#H_Find%20the%20DnaA%20Box">Find the DnaA Box</a></li>
</ul>
<li><a href="#H_Transcription%20Factors">Transcription Factors</a></li>
<ul>
<li><a href="#H_Find%20Regulatory%20Motif">Find Regulatory Motif</a></li>
</ul>
</ul>
<li><a href="#H_Terminology">Terminology</a></li>
</ul>
</div>
<a name="H_Introduction"></a><h1>Introduction</h1>
<p>Bioinformatics is the science of transforming and processing biological data to gain new insights, particularly omics data: genomics, proteomics, metabolomics, etc.. Bioinformatics is mostly a mix of biology, computer science, and statistics / data science.</p>
<a name="H_Algorithms"></a><h1>Algorithms</h1>
<a name="H_K-mer"></a><h2>K-mer</h2>
<p><a name="BM_(Algorithms%5C%2FK-mer)_TOPIC%2F"></a><strong></strong></p>
<p>A <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> is a sub<a href="#BM_(sequence)%2Fi">sequence</a> of length k within some larger biological <a href="#BM_(sequence)%2Fi">sequence</a> (e.g. DNA or <a href="#BM_(amino%20acid)%2Fi">amino acid</a> chain). For example, in the DNA <a href="#BM_(sequence)%2Fi">sequence</a> GAAATC, the following <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>'s exist:</p>
<table>
<thead>
<tr>
<th>k</th>
<th><a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>G A A A T C</td>
</tr>
<tr>
<td>2</td>
<td>GA AA AA AT TC</td>
</tr>
<tr>
<td>3</td>
<td>GAA AAA AAT ATC</td>
</tr>
<tr>
<td>4</td>
<td>GAAA AAAT AATC</td>
</tr>
<tr>
<td>5</td>
<td>GAAAT AAATC</td>
</tr>
<tr>
<td>6</td>
<td>GAAATC</td>
</tr>
</tbody>
</table>
<p>Common scenarios involving <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s:</p>
<ul>
<li>Search for an exact <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>.</li>
<li>Search for an approximate <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> (fuzzy search).</li>
<li>Find <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s of interest in a <a href="#BM_(sequence)%2Fi">sequence</a> (e.g. repeating <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s).</li>
</ul>
<a name="H_Reverse%20Complement"></a><h3>Reverse Complement</h3>
<p><a name="BM_(Algorithms%5C%2FK-mer%2FReverse%20Complement)_TOPIC%2F"></a><strong></strong></p>
<p><strong>WHAT</strong>: Given a DNA <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>, calculate its reverse complement.</p>
<p><strong>WHY</strong>: Depending on the type of biological <a href="#BM_(sequence)%2Fi">sequence</a>, a <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> may have one or more alternatives. For DNA <a href="#BM_(sequence)%2Fi">sequence</a>s specifically, a <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> of interest may have an alternate form. Since the DNA molecule comes as 2 strands, where ...</p>
<ul>
<li>each strand's direction is opposite of the other,</li>
<li>each strand position has a nucleotide that complements the nucleotide at that same position on the other stand:
<ul>
<li>A ⟷ T</li>
<li>C ⟷ G</li>
</ul>
</li>
</ul>
<p><img src="svgbob_c44b72fd8e03cfe92b63a0a3b83bfe37c5551666.svg" alt="Kroki diagram output"></p>
<p>, ... the reverse complement of that <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> may be just as valid as the original <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>. For example, if an enzyme is known to bind to a specific DNA <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>, it's possible that it might also bind to the reverse complement of that <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>.</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverse_complement</span>(<span class="hljs-params">strand: str</span>):</span>
    ret = <span class="hljs-string">''</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(strand)):
        base = strand[i]
        <span class="hljs-keyword">if</span> base == <span class="hljs-string">'A'</span> <span class="hljs-keyword">or</span> base == <span class="hljs-string">'a'</span>:
            base = <span class="hljs-string">'T'</span>
        <span class="hljs-keyword">elif</span> base == <span class="hljs-string">'T'</span> <span class="hljs-keyword">or</span> base == <span class="hljs-string">'t'</span>:
            base = <span class="hljs-string">'A'</span>
        <span class="hljs-keyword">elif</span> base == <span class="hljs-string">'C'</span> <span class="hljs-keyword">or</span> base == <span class="hljs-string">'c'</span>:
            base = <span class="hljs-string">'G'</span>
        <span class="hljs-keyword">elif</span> base == <span class="hljs-string">'G'</span> <span class="hljs-keyword">or</span> base == <span class="hljs-string">'g'</span>:
            base = <span class="hljs-string">'C'</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">'Unexpected base: '</span> + base)

        ret += base
    <span class="hljs-keyword">return</span> ret[::<span class="hljs-number">-1</span>]</code></pre><div style="border:1px solid black;">
<p></p>
<p>Original: TAATCCG</p>
<p>Reverse Complement: CGGATTA</p>
</div>
<p></p>
<a name="H_Hamming%20Distance"></a><h3>Hamming Distance</h3>
<p><a name="BM_(Algorithms%5C%2FK-mer%2FHamming%20Distance)_TOPIC%2F"></a><strong></strong></p>
<p><strong>WHAT</strong>: Given 2 <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s, the hamming distance is the number of positional mismatches between them.</p>
<p><strong>WHY</strong>: Imagine an enzyme that looks for a specific DNA <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> pattern to bind to. Since DNA is known to mutate, it may be that enzyme can also bind to other <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> patterns that are slight variations of the original. For example, that enzyme may be able to bind to both AAACTG and AAAGTG.</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hamming_distance</span>(<span class="hljs-params">kmer1: str, kmer2: str</span>) -&gt; int:</span>
    mismatch = <span class="hljs-number">0</span>

    <span class="hljs-keyword">for</span> ch1, ch2 <span class="hljs-keyword">in</span> zip(kmer1, kmer2):
        <span class="hljs-keyword">if</span> ch1 != ch2:
            mismatch += <span class="hljs-number">1</span>

    <span class="hljs-keyword">return</span> mismatch</code></pre><div style="border:1px solid black;">
<p></p>
<p>Kmer1: ACTTTGTT</p>
<p>Kmer2: AGTTTCTT</p>
<p>Hamming Distance: 2</p>
</div>
<p></p>
<a name="H_Hamming%20Distance%20Neighbourhood"></a><h3>Hamming Distance Neighbourhood</h3>
<p><a name="BM_(Algorithms%5C%2FK-mer%2FHamming%20Distance%20Neighbourhood)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FK-mer%2FHamming%20Distance)_TOPIC%2F">Algorithms/K-mer/Hamming Distance</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given a source <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> and a minimum hamming distance, find all <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s such within the hamming distance of the source <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>. In other words, find all <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s such that <code>hamming_distance(source_kmer, kmer) &lt;= min_distance</code>.</p>
<p><strong>WHY</strong>: Imagine an enzyme that looks for a specific DNA <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> pattern to bind to. Since DNA is known to mutate, it may be that enzyme can also bind to other <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> patterns that are slight variations of the original. This algorithm finds all such variations.</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_all_dna_kmers_within_hamming_distance</span>(<span class="hljs-params">kmer: str, hamming_dist: int</span>) -&gt; set[str]:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recurse</span>(<span class="hljs-params">kmer: str, hamming_dist: int, output: set[str]</span>) -&gt; <span class="hljs-keyword">None</span>:</span>
        <span class="hljs-keyword">if</span> hamming_dist == <span class="hljs-number">0</span>:
            output.add(kmer)
            <span class="hljs-keyword">return</span>

        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(kmer)):
            <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> <span class="hljs-string">'ACTG'</span>:
                neighbouring_kmer = kmer[:i] + ch + kmer[i + <span class="hljs-number">1</span>:]
                recurse(neighbouring_kmer, hamming_dist - <span class="hljs-number">1</span>, output)

    output = set()
    recurse(kmer, hamming_dist, output)

    <span class="hljs-keyword">return</span> output</code></pre><div style="border:1px solid black;">
<p></p>
<p>Kmers within hamming distance 1 of AAAA: {'AAAT', 'TAAA', 'AACA', 'AAGA', 'AGAA', 'ATAA', 'AATA', 'AAAG', 'ACAA', 'AAAC', 'AAAA', 'CAAA', 'GAAA'}</p>
</div>
<p></p>
<a name="H_Find%20Locations"></a><h3>Find Locations</h3>
<p><a name="BM_(Algorithms%5C%2FK-mer%2FFind%20Locations)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FK-mer%2FHamming%20Distance)_TOPIC%2F">Algorithms/K-mer/Hamming Distance</a></li>
<li><a href="#BM_(Algorithms%5C%2FK-mer%2FReverse%20Complement)_TOPIC%2F">Algorithms/K-mer/Reverse Complement</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given a <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>, find where that <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> occurs in some larger <a href="#BM_(sequence)%2Fi">sequence</a>. The search may potentially include the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>'s variants (e.g. reverse complement).</p>
<p><strong>WHY</strong>: Imagine that you know of a specific <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> pattern that serves some function in an organism. If you see that same <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> pattern appearing in some other related organism, it could be a sign that <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> pattern serves a similar function. For example, the same <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> pattern could be used by 2 related types of bacteria as a <a href="#BM_(DnaA%20box)%2Fi">DnaA box</a>.</p>
<p>The enzyme that operates on that <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> may also operate on its reverse complement as well as slight variations on that <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>. For example, if an enzyme binds to AAAAAAAAA, it may also bind to its...</p>
<ul>
<li>reverse complement: TTTTTTTTT</li>
<li>approximate variants: AAAAAAAAA, AAATAAAAA, AAAAAGAAA, ...</li>
<li>approximate variants of its reverse complements: TTTTTTTTT, TTTTTTATT, TTCTTTTTT, ...</li>
</ul>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Options</span>(<span class="hljs-params">NamedTuple</span>):</span>
    hamming_distance: int = <span class="hljs-number">0</span>
    reverse_complement: bool = <span class="hljs-literal">False</span>


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_kmer_locations</span>(<span class="hljs-params">sequence: str, kmer: str, options: Options = Options(<span class="hljs-params"></span>)</span>) -&gt; List[int]:</span>
    <span class="hljs-comment"># Construct test kmers</span>
    test_kmers = set()
    test_kmers.add(kmer)
    [test_kmers.add(alt_kmer) <span class="hljs-keyword">for</span> alt_kmer <span class="hljs-keyword">in</span> find_all_dna_kmers_within_hamming_distance(kmer, options.hamming_distance)]
    <span class="hljs-keyword">if</span> options.reverse_complement:
        rc_kmer = reverse_complement(kmer)
        [test_kmers.add(alt_rc_kmer) <span class="hljs-keyword">for</span> alt_rc_kmer <span class="hljs-keyword">in</span> find_all_dna_kmers_within_hamming_distance(rc_kmer, options.hamming_distance)]

    <span class="hljs-comment"># Slide over the sequence's kmers and check for matches against test kmers</span>
    k = len(kmer)
    idxes = []
    <span class="hljs-keyword">for</span> seq_kmer, i <span class="hljs-keyword">in</span> slide_window(sequence, k):
        <span class="hljs-keyword">if</span> seq_kmer <span class="hljs-keyword">in</span> test_kmers:
            idxes.append(i)
    <span class="hljs-keyword">return</span> idxes</code></pre><div style="border:1px solid black;">
<p></p>
<p>Found AAAA in AAAAGAACCTAATCTTAAAGGAGATGATGATTCTAA at index [0, 1, 2, 3, 12, 15, 16, 30]</p>
</div>
<p></p>
<a name="H_Find%20Clumps"></a><h3>Find Clumps</h3>
<p><a name="BM_(Algorithms%5C%2FK-mer%2FFind%20Clumps)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FK-mer%2FFind%20Locations)_TOPIC%2F">Algorithms/K-mer/Find Locations</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given a <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>, find where that <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> clusters in some larger <a href="#BM_(sequence)%2Fi">sequence</a>. The search may potentially include the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>'s variants (e.g. reverse complement).</p>
<p><strong>WHY</strong>: An enzyme may need to bind to a specific region of DNA to begin doing its job. That is, it looks for a specific <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> pattern to bind to, where that <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> represents the beginning of some larger DNA region that it operates on. Since DNA is known to mutate, often times you'll find multiple copies of the same <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> pattern clustered together -- if one copy mutated to become unusable, the other copies are still around.</p>
<p>For example, the <a href="#BM_(DnaA%20box)%2Fi">DnaA box</a> is a special <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> pattern used by enzymes during DNA replication. Since DNA is known to mutate, the <a href="#BM_(DnaA%20box)%2Fi">DnaA box</a> can be found repeating multiple times in the region of DNA known as the <a href="#BM_(replication%20origin)%2Fi">replication origin</a>. Finding the <a href="#BM_(DnaA%20box)%2Fi">DnaA box</a> clustered in a small region is a good indicator that you've found the <a href="#BM_(replication%20origin)%2Fi">replication origin</a>.</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_kmer_clusters</span>(<span class="hljs-params">sequence: str, kmer: str, min_occurrence_in_cluster: int, cluster_window_size: int, options: Options = Options(<span class="hljs-params"></span>)</span>) -&gt; List[int]:</span>
    cluster_locs = []

    locs = find_kmer_locations(sequence, kmer, options)
    start_i = <span class="hljs-number">0</span>
    occurrence_count = <span class="hljs-number">1</span>
    <span class="hljs-keyword">for</span> end_i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(locs)):
        <span class="hljs-keyword">if</span> locs[end_i] - locs[start_i] &lt; cluster_window_size:  <span class="hljs-comment"># within a cluster window?</span>
            occurrence_count += <span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">if</span> occurrence_count &gt;= min_occurrence_in_cluster:  <span class="hljs-comment"># did the last cluster meet the min ocurr requirement?</span>
                cluster_locs.append(locs[start_i])
            start_i = end_i
            occurrence_count = <span class="hljs-number">1</span>

    <span class="hljs-keyword">return</span> cluster_locs</code></pre><div style="border:1px solid black;">
<p></p>
<p>Found clusters of GGG (at least 3 occurrences in window of 13) in GGGACTGAACAAACAAATTTGGGAGGGCACGGGTTAAAGGAGATGATGATTCAAAGGGT at index [19, 37]</p>
</div>
<p></p>
<a name="H_Find%20Repeating"></a><h3>Find Repeating</h3>
<p><a name="BM_(Algorithms%5C%2FK-mer%2FFind%20Repeating)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FK-mer%2FReverse%20Complement)_TOPIC%2F">Algorithms/K-mer/Reverse Complement</a></li>
<li><a href="#BM_(Algorithms%5C%2FK-mer%2FHamming%20Distance%20Neighbourhood)_TOPIC%2F">Algorithms/K-mer/Hamming Distance Neighbourhood</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given a <a href="#BM_(sequence)%2Fi">sequence</a>, find clusters of unique <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s within that <a href="#BM_(sequence)%2Fi">sequence</a>. In other words, for each unique <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> that exists in the <a href="#BM_(sequence)%2Fi">sequence</a>, see if it clusters in the <a href="#BM_(sequence)%2Fi">sequence</a>. The search may potentially include variants of <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> variants (e.g. reverse complements of the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s).</p>
<p><strong>WHY</strong>: An enzyme may need to bind to a specific region of DNA to begin doing its job. That is, it looks for a specific <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> pattern to bind to, where that <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> represents the beginning of some larger DNA region that it operates on. Since DNA is known to mutate, often times you'll find multiple copies of the same <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> pattern clustered together -- if one copy mutated to become unusable, the other copies are still around.</p>
<p>For example, the <a href="#BM_(DnaA%20box)%2Fi">DnaA box</a> is a special <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> pattern used by enzymes during DNA replication. Since DNA is known to mutate, the <a href="#BM_(DnaA%20box)%2Fi">DnaA box</a> can be found repeating multiple times in the region of DNA known as the <a href="#BM_(replication%20origin)%2Fi">replication origin</a>. Given that you don't know the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> pattern for the <a href="#BM_(DnaA%20box)%2Fi">DnaA box</a> but you do know the <a href="#BM_(replication%20origin)%2Fi">replication origin</a>, you can scan through the <a href="#BM_(replication%20origin)%2Fi">replication origin</a> for repeating <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> patterns. If a pattern is found to heavily repeat, it's a good candidate that it's the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> pattern for the <a href="#BM_(DnaA%20box)%2Fi">DnaA box</a>.</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-keyword">from</span> Utils <span class="hljs-keyword">import</span> slide_window


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">count_kmers</span>(<span class="hljs-params">data: str, k: int, options: Options = Options(<span class="hljs-params"></span>)</span>) -&gt; Counter[str]:</span>
    counter = Counter()
    <span class="hljs-keyword">for</span> kmer, i <span class="hljs-keyword">in</span> slide_window(data, k):
        neighbourhood = find_all_dna_kmers_within_hamming_distance(kmer, options.hamming_distance)
        <span class="hljs-keyword">for</span> neighbouring_kmer <span class="hljs-keyword">in</span> neighbourhood:
            counter[neighbouring_kmer] += <span class="hljs-number">1</span>

        <span class="hljs-keyword">if</span> options.reverse_complement:
            kmer_rc = reverse_complement(kmer)
            neighbourhood = find_all_dna_kmers_within_hamming_distance(kmer_rc, options.hamming_distance)
            <span class="hljs-keyword">for</span> neighbouring_kmer <span class="hljs-keyword">in</span> neighbourhood:
                counter[neighbouring_kmer] += <span class="hljs-number">1</span>

    <span class="hljs-keyword">return</span> counter


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">top_repeating_kmers</span>(<span class="hljs-params">data: str, k: int, options: Options = Options(<span class="hljs-params"></span>)</span>) -&gt; Set[str]:</span>
    counts = count_kmers(data, k, options)

    _, top_count = counts.most_common(<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]

    top_kmers = set()
    <span class="hljs-keyword">for</span> kmer, count <span class="hljs-keyword">in</span> counts.items():
        <span class="hljs-keyword">if</span> count == top_count:
            top_kmers.add((kmer, count))
    <span class="hljs-keyword">return</span> top_kmers</code></pre><div style="border:1px solid black;">
<p></p>
<p>Top 5-mer frequencies for GGGACTGAACAAACAAATTTGGGAGGGCACGGGTTAAAGGAGATGATGATTCAAAGGGT:</p>
<ul>
<li>TTAAA = 6 occurrences</li>
<li>AAGGG = 6 occurrences</li>
<li>GATCA = 6 occurrences</li>
<li>TTTAA = 6 occurrences</li>
<li>CCCTT = 6 occurrences</li>
<li>TGATC = 6 occurrences</li>
</ul>
</div>
<p></p>
<a name="H_Find%20Repeating%20in%20Window"></a><h3>Find Repeating in Window</h3>
<p><a name="BM_(Algorithms%5C%2FK-mer%2FFind%20Repeating%20in%20Window)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FK-mer%2FFind%20Repeating)_TOPIC%2F">Algorithms/K-mer/Find Repeating</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given a <a href="#BM_(sequence)%2Fi">sequence</a>, find regions within that <a href="#BM_(sequence)%2Fi">sequence</a> that contain clusters of unique <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s. In other words, ...</p>
<ul>
<li>slide a window over the cluster.</li>
<li>for each unique <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> that exists in the window, see if it clusters in the <a href="#BM_(sequence)%2Fi">sequence</a>.</li>
</ul>
<p>The search may potentially include variants of <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> variants (e.g. reverse complements of the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s).</p>
<p><strong>WHY</strong>: An enzyme may need to bind to a specific region of DNA to begin doing its job. That is, it looks for a specific <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> pattern to bind to, where that <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> represents the beginning of some larger DNA region that it operates on. Since DNA is known to mutate, often times you'll find multiple copies of the same <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> pattern clustered together -- if one copy mutated to become unusable, the other copies are still around.</p>
<p>For example, the <a href="#BM_(DnaA%20box)%2Fi">DnaA box</a> is a special <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> pattern used by enzymes during DNA replication. Since DNA is known to mutate, the <a href="#BM_(DnaA%20box)%2Fi">DnaA box</a> can be found repeating multiple times in the region of DNA known as the <a href="#BM_(replication%20origin)%2Fi">replication origin</a>. Given that you don't know the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> pattern for the <a href="#BM_(DnaA%20box)%2Fi">DnaA box</a> but you do know the <a href="#BM_(replication%20origin)%2Fi">replication origin</a>, you can scan through the <a href="#BM_(replication%20origin)%2Fi">replication origin</a> for repeating <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> patterns. If a pattern is found to heavily repeat, it's a good candidate that it's the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> pattern for the <a href="#BM_(DnaA%20box)%2Fi">DnaA box</a>.</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">scan_for_repeating_kmers_in_clusters</span>(<span class="hljs-params">sequence: str, k: int, min_occurrence_in_cluster: int, cluster_window_size: int, options: Options = Options(<span class="hljs-params"></span>)</span>) -&gt; Set[KmerCluster]:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">neighborhood</span>(<span class="hljs-params">kmer: str</span>) -&gt; Set[str]:</span>
        neighbourhood = find_all_dna_kmers_within_hamming_distance(kmer, options.hamming_distance)
        <span class="hljs-keyword">if</span> options.reverse_complement:
            kmer_rc = reverse_complement(kmer)
            neighbourhood = find_all_dna_kmers_within_hamming_distance(kmer_rc, options.hamming_distance)
        <span class="hljs-keyword">return</span> neighbourhood

    kmer_counter = {}

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_kmer</span>(<span class="hljs-params">kmer: str, loc: int</span>) -&gt; <span class="hljs-keyword">None</span>:</span>
        <span class="hljs-keyword">if</span> kmer <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> kmer_counter:
            kmer_counter[kmer] = set()
        kmer_counter[kmer].add(window_idx + kmer_idx)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove_kmer</span>(<span class="hljs-params">kmer: str, loc: int</span>) -&gt; <span class="hljs-keyword">None</span>:</span>
        kmer_counter[kmer].remove(window_idx - <span class="hljs-number">1</span>)
        <span class="hljs-keyword">if</span> len(kmer_counter[kmer]) == <span class="hljs-number">0</span>:
            <span class="hljs-keyword">del</span> kmer_counter[kmer]

    clustered_kmers = set()

    old_first_kmer = <span class="hljs-literal">None</span>
    <span class="hljs-keyword">for</span> window, window_idx <span class="hljs-keyword">in</span> slide_window(sequence, cluster_window_size):
        first_kmer = window[<span class="hljs-number">0</span>:k]
        last_kmer = window[-k:]

        <span class="hljs-comment"># If first iteration, add all kmers</span>
        <span class="hljs-keyword">if</span> window_idx == <span class="hljs-number">0</span>:
            <span class="hljs-keyword">for</span> kmer, kmer_idx <span class="hljs-keyword">in</span> slide_window(window, k):
                <span class="hljs-keyword">for</span> alt_kmer <span class="hljs-keyword">in</span> neighborhood(kmer):
                    add_kmer(alt_kmer, window_idx + kmer_idx)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-comment"># Add kmer that was walked in to</span>
            <span class="hljs-keyword">for</span> new_last_kmer <span class="hljs-keyword">in</span> neighborhood(last_kmer):
                add_kmer(new_last_kmer, window_idx + cluster_window_size - k)
            <span class="hljs-comment"># Remove kmer that was walked out of</span>
            <span class="hljs-keyword">if</span> old_first_kmer <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
                <span class="hljs-keyword">for</span> alt_kmer <span class="hljs-keyword">in</span> neighborhood(old_first_kmer):
                    remove_kmer(alt_kmer, window_idx - <span class="hljs-number">1</span>)

        old_first_kmer = first_kmer

        <span class="hljs-comment"># Find clusters within window -- tuple is k-mer, start_idx, occurrence_count</span>
        [clustered_kmers.add(KmerCluster(k, min(v), len(v))) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> kmer_counter.items() <span class="hljs-keyword">if</span> len(v) &gt;= min_occurrence_in_cluster]

    <span class="hljs-keyword">return</span> clustered_kmers</code></pre><div style="border:1px solid black;">
<p></p>
<p>Found clusters of k=9 (at least 6 occurrences in window of 20) in TTTTTTTTTTTTTCCCTTTTTTTTTCCCTTTTTTTTTTTTT at...</p>
<ul>
<li>KmerCluster(kmer='AAAAAAAAA', start_index=0, occurrence_count=6)</li>
<li>KmerCluster(kmer='AGAAAAAAA', start_index=0, occurrence_count=6)</li>
<li>KmerCluster(kmer='CAAAAAAAA', start_index=0, occurrence_count=6)</li>
<li>KmerCluster(kmer='TAAAAAAAA', start_index=0, occurrence_count=6)</li>
<li>KmerCluster(kmer='GAAAAAAAA', start_index=0, occurrence_count=7)</li>
<li>KmerCluster(kmer='GAAAAAAAA', start_index=1, occurrence_count=6)</li>
<li>KmerCluster(kmer='AAAAAAAGA', start_index=26, occurrence_count=6)</li>
<li>KmerCluster(kmer='AAAAAAAAG', start_index=26, occurrence_count=6)</li>
<li>KmerCluster(kmer='AAAAAAAAG', start_index=26, occurrence_count=7)</li>
<li>KmerCluster(kmer='AAAAAAAAA', start_index=27, occurrence_count=6)</li>
<li>KmerCluster(kmer='AAAAAAAAC', start_index=27, occurrence_count=6)</li>
<li>KmerCluster(kmer='AAAAAAAAT', start_index=27, occurrence_count=6)</li>
</ul>
</div>
<p></p>
<a name="H_Probability%20of%20Appearance"></a><h3>Probability of Appearance</h3>
<p><a name="BM_(Algorithms%5C%2FK-mer%2FProbability%20of%20Appearance)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FK-mer%2FFind%20Locations)_TOPIC%2F">Algorithms/K-mer/Find Locations</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given ...</p>
<ul>
<li>the length of a <a href="#BM_(sequence)%2Fi">sequence</a> (n)</li>
<li>a <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a></li>
<li>a count (c)</li>
</ul>
<p>... find the probability of that <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> appearing at least c times within an arbitrary <a href="#BM_(sequence)%2Fi">sequence</a> of length n. For example, the probability that the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">2-mer</a> AA appears at least 2 times in a <a href="#BM_(sequence)%2Fi">sequence</a> of length 4:</p>
<ul>
<li>AAAA - yes</li>
<li>AAAT - yes</li>
<li>AAAC - yes</li>
<li>AAAG - yes</li>
<li>AATA - no</li>
<li>AATT - no</li>
<li>AATC - no</li>
<li>AATG - no</li>
<li>...</li>
<li>TAAA - yes</li>
<li>...</li>
<li>CAAA - yes</li>
<li>...</li>
<li>GAAA - yes</li>
<li>...</li>
<li>GGGA - no</li>
<li>GGGT - no</li>
<li>GGGC - no</li>
<li>GGGG - no</li>
</ul>
<p>The probability is 7/256.</p>
<p>This isn't trivial to accurately compute because the occurrences of a <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> within a <a href="#BM_(sequence)%2Fi">sequence</a> may overlap. For example, the number of times AA appears in AAAA is 3 while in CAAA it's 2.</p>
<p><strong>WHY</strong>: When a <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> is found within a <a href="#BM_(sequence)%2Fi">sequence</a>, knowing the probability of that <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> being found within an arbitrary <a href="#BM_(sequence)%2Fi">sequence</a> of the same length hints at the significance of the find. For example, if some <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">10-mer</a> has a 0.2 chance of appearing in an arbitrary <a href="#BM_(sequence)%2Fi">sequence</a> of length 50, that's too high of a chance to consider it a significant find -- 0.2 means 1 in 5 chance that the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">10-mer</a> just randomly happens to appear.</p>
<a name="H_Bruteforce%20Algorithm"></a><h4>Bruteforce Algorithm</h4>
<p><strong>ALGORITHM</strong>:</p>
<p>This algorithm tries every possible combination of <a href="#BM_(sequence)%2Fi">sequence</a> to find the probability. It falls over once the length of the <a href="#BM_(sequence)%2Fi">sequence</a> extends into the double digits. It's intended to help conceptualize what's going on.</p>
<pre class="hljs"><code><span class="hljs-comment"># Of the X sequence combinations tried, Y had the k-mer. The probability is Y/X.</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bruteforce_probability</span>(<span class="hljs-params">searchspace_len: int, searchspace_symbol_count: int, search_for: List[int], min_occurrence: int</span>) -&gt; (int, int):</span>
    found = <span class="hljs-number">0</span>
    found_max = searchspace_symbol_count ** searchspace_len

    str_to_search = [<span class="hljs-number">0</span>] * searchspace_len

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">count_instances</span>():</span>
        ret = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, searchspace_len - len(search_for) + <span class="hljs-number">1</span>):
            <span class="hljs-keyword">if</span> str_to_search[i:i + len(search_for)] == search_for:
                ret += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> ret

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">walk</span>(<span class="hljs-params">idx: int</span>):</span>
        <span class="hljs-keyword">nonlocal</span> found

        <span class="hljs-keyword">if</span> idx == searchspace_len:
            count = count_instances()
            <span class="hljs-keyword">if</span> count &gt;= min_occurrence:
                found += <span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, searchspace_symbol_count):
                walk(idx + <span class="hljs-number">1</span>)
                str_to_search[idx] += <span class="hljs-number">1</span>
            str_to_search[idx] = <span class="hljs-number">0</span>

    walk(<span class="hljs-number">0</span>)

    <span class="hljs-keyword">return</span> found, found_max</code></pre><div style="border:1px solid black;">
<p></p>
<p>Brute-forcing probability of ACTG in arbitrary sequence of length 8</p>
<p>Probability: 0.0195159912109375 (1279/65536)</p>
</div>
<p></p>
<a name="H_Selection%20Estimate%20Algorithm"></a><h4>Selection Estimate Algorithm</h4>
<p><strong>ALGORITHM</strong>:</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The explanation in the comments below are a bastardization of "1.13 Detour: Probabilities of Patterns in a String" in the Pevzner book...</p>
</div>
<p>This algorithm tries estimating the probability by ignoring the fact that the occurrences of a <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> in a <a href="#BM_(sequence)%2Fi">sequence</a> may overlap. For example, searching for the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">2-mer</a> AA in the <a href="#BM_(sequence)%2Fi">sequence</a> AAAT yields 2 instances of AA:</p>
<ul>
<li>[AA]AT</li>
<li>A[AA]T</li>
</ul>
<p>If you go ahead and ignore overlaps, you can think of the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s occurring in a string as insertions. For example, imagine a <a href="#BM_(sequence)%2Fi">sequence</a> of length 7 and the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">2-mer</a> AA. If you were to inject 2 instances of AA into the <a href="#BM_(sequence)%2Fi">sequence</a> to get it to reach length 7, how would that look?</p>
<p>2 instances of a <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">2-mer</a> is 4 characters has a length of 5. To get the <a href="#BM_(sequence)%2Fi">sequence</a> to end up with a length of 7 after the insertions, the <a href="#BM_(sequence)%2Fi">sequence</a> needs to start with a length of 3:</p>
<pre><code>SSS
</code></pre>
<p>Given that you're changing reality to say that the instances WON'T overlap in the <a href="#BM_(sequence)%2Fi">sequence</a>, you can treat each instance of the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">2-mer</a> AA as a single entity being inserted. The number of ways that these 2 instances can be inserted into the <a href="#BM_(sequence)%2Fi">sequence</a> is 10:</p>
<pre><code>I = insertion of AA, S = arbitrary sequence character

IISSS  ISISS  ISSIS  ISSSI
SIISS  SISIS  SISSI
SSIIS  SSISI
SSSII
</code></pre>
<p>Another way to think of the above insertions is that they aren't insertions. Rather, you have 5 items in total and you're selecting 2 of them. How many ways can you select 2 of those 5 items? 10.</p>
<p>The number of ways to insert can be counted via the "binomial coefficient": <code>bc(m, k) = m!/(k!(m-k)!)</code>, where m is the total number of items (5 in the example above) and k is the number of selections (2 in the example above). For the example above:</p>
<pre><code>bc(5, 2) = 5!/(2!(5-2)!) = 10
</code></pre>
<p>Since the SSS can be any arbitrary nucleotide <a href="#BM_(sequence)%2Fi">sequence</a> of 3, count the number of different representations that are possible for SSS: <code>4^3 = 4*4*4 = 64</code> (4^3, 4 because a nucleotide can be one of ACTG, 3 because the length is 3). In each of these representations, the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">2-mer</a> AA can be inserted in 10 different ways:</p>
<pre><code>64*10 = 640
</code></pre>
<p>Since the total length of the <a href="#BM_(sequence)%2Fi">sequence</a> is 7, count the number of different representations that are possible:</p>
<pre><code>4^7 = 4*4*4*4*4*4*4 = 16384
</code></pre>
<p>The estimated probability is 640/16384. For...</p>
<ul>
<li>non-overlapping <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s, the estimation will actually be relatively accurate.</li>
<li>overlapping <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s, the estimation won't be as accurate.</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Maybe try training a deep learning model to see if it can provide better estimates?</p>
</div>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">estimate_probability</span>(<span class="hljs-params">searchspace_len: int, searchspace_symbol_count: int, search_for: List[int], min_occurrence: int</span>) -&gt; float:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">factorial</span>(<span class="hljs-params">num</span>):</span>
        <span class="hljs-keyword">if</span> num == <span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> num
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> num * factorial(num - <span class="hljs-number">1</span>)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bc</span>(<span class="hljs-params">m, k</span>):</span>
        <span class="hljs-keyword">return</span> factorial(m) / (factorial(k) * factorial(m - k))

    k = len(search_for)
    n = (searchspace_len - min_occurrence * k)
    <span class="hljs-keyword">return</span> bc(n + min_occurrence, min_occurrence) * (searchspace_symbol_count ** n) / searchspace_symbol_count ** searchspace_len</code></pre><div style="border:1px solid black;">
<p></p>
<p>Estimating probability of ACTG in arbitrary sequence of length 8</p>
<p>Probability: 0.01953125</p>
</div>
<p></p>
<a name="H_GC%20Skew"></a><h2>GC Skew</h2>
<p><a name="BM_(Algorithms%5C%2FGC%20Skew)_TOPIC%2F"></a><strong></strong></p>
<p><strong>WHAT</strong>: Given a <a href="#BM_(sequence)%2Fi">sequence</a>, create a counter and walk over the <a href="#BM_(sequence)%2Fi">sequence</a>. Whenever a ...</p>
<ul>
<li>G is encountered, increment the counter.</li>
<li>C is encountered, decrement the counter.</li>
</ul>
<p><strong>WHY</strong>: Given the DNA <a href="#BM_(sequence)%2Fi">sequence</a> of an organism, some segments may have lower count of Gs vs Cs.</p>
<p>During replication, some segments of DNA stay single-stranded for a much longer time than other segments. <a href="#BM_(single%20stranded%20DNA%7Csingle-stranded%20DNA)%2Fi">Single-stranded DNA</a> is 100 times more susceptible to mutations than <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA)%2Fi">double-stranded DNA</a>. Specifically, in <a href="#BM_(single%20stranded%20DNA%7Csingle-stranded%20DNA)%2Fi">single-stranded DNA</a>, C has a greater tendency to mutate to T. When that <a href="#BM_(single%20stranded%20DNA%7Csingle-stranded%20DNA)%2Fi">single-stranded DNA</a> re-binds to a neighbouring strand, the positions of any nucleotides that mutated from C to T will change on the neighbouring strand from G to A.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Recall that the reverse complements of ...</p>
<ul>
<li>C is G</li>
<li>A is T</li>
</ul>
<p>It mutated from C to T. Since its now T, its complement is A.</p>
</div>
<p>Plotting the skew shows roughly which segments of DNA stayed single-stranded for a longer period of time. That information hints at special / useful locations in the organism's DNA <a href="#BM_(sequence)%2Fi">sequence</a> (<a href="#BM_(replication%20origin)%2Fi">replication origin</a> / <a href="#BM_(replication%20terminus)%2Fi">replication terminus</a>).</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gc_skew</span>(<span class="hljs-params">seq: str</span>):</span>
    counter = <span class="hljs-number">0</span>
    skew = [counter]
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(seq)):
        <span class="hljs-keyword">if</span> seq[i] == <span class="hljs-string">'G'</span>:
            counter += <span class="hljs-number">1</span>
            skew.append(counter)
        <span class="hljs-keyword">elif</span> seq[i] == <span class="hljs-string">'C'</span>:
            counter -= <span class="hljs-number">1</span>
            skew.append(counter)
        <span class="hljs-keyword">else</span>:
            skew.append(counter)
    <span class="hljs-keyword">return</span> skew</code></pre><div style="border:1px solid black;">
<p></p>
<p>Calculating skew for: ...</p>
<p>Result: [0, -1, -1,...</p>
<p><img src="skew_babf857bad6dd935f0d1ddbbb8b5005f.png" alt="GC Skew Plot"></p>
</div>
<p></p>
<a name="H_Motif"></a><h2>Motif</h2>
<p><a name="BM_(Algorithms%5C%2FMotif)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FK-mer)_TOPIC%2F">Algorithms/K-mer</a></li>
</ul>
</div>
<p>A <a href="#BM_(motif)%2Fi">motif</a> is a pattern that matches many different <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s, where those matched <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s have some shared biological significance. The pattern matches a fixed k where each position may have alternate forms. The simplest way to think of a <a href="#BM_(motif)%2Fi">motif</a> is a regex pattern without quantifiers. For example, the regex <code>[AT]TT[GC]C</code> may match to ATTGC, ATTCC, TTTGC, and TTTCC.</p>
<p>A common scenario involving <a href="#BM_(motif)%2Fi">motif</a>s is to search through a set of DNA <a href="#BM_(sequence)%2Fi">sequence</a>s for an unknown <a href="#BM_(motif)%2Fi">motif</a>: Given a set of <a href="#BM_(sequence)%2Fi">sequence</a>s, it's suspected that each <a href="#BM_(sequence)%2Fi">sequence</a> contains a <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> that matches some <a href="#BM_(motif)%2Fi">motif</a>. But, that <a href="#BM_(motif)%2Fi">motif</a> isn't known beforehand. Both the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s and the <a href="#BM_(motif)%2Fi">motif</a> they match need to be found.</p>
<p>For example, each of the following <a href="#BM_(sequence)%2Fi">sequence</a>s contains a <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> that matches some <a href="#BM_(motif)%2Fi">motif</a>:</p>
<table>
<thead>
<tr>
<th><a href="#BM_(sequence)%2Fi">Sequence</a>s</th>
</tr>
</thead>
<tbody>
<tr>
<td>ATTGTTACCATAACCTTATTGCTAG</td>
</tr>
<tr>
<td>ATTCCTTTAGGACCACCCCAAACCC</td>
</tr>
<tr>
<td>CCCCAGGAGGGAACCTTTGCACACA</td>
</tr>
<tr>
<td>TATATATTTCCCACCCCAAGGGGGG</td>
</tr>
</tbody>
</table>
<p>That <a href="#BM_(motif)%2Fi">motif</a> is the one described above (<code>[AT]TT[GC]C</code>):</p>
<table>
<thead>
<tr>
<th><a href="#BM_(sequence)%2Fi">Sequence</a>s</th>
</tr>
</thead>
<tbody>
<tr>
<td>ATTGTTACCATAACCTT<strong>ATTGC</strong>TAG</td>
</tr>
<tr>
<td><strong>ATTCC</strong>TTTAGGACCACCCCAAACCC</td>
</tr>
<tr>
<td>CCCCAGGAGGGAACC<strong>TTTGC</strong>ACACA</td>
</tr>
<tr>
<td>TATATA<strong>TTTCC</strong>CACCCCAAGGGGGG</td>
</tr>
</tbody>
</table>
<p>A <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> is a matrix of <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s where each <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> matches a <a href="#BM_(motif)%2Fi">motif</a>. In the example <a href="#BM_(sequence)%2Fi">sequence</a>s above, the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> would be:</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>T</td>
<td>T</td>
<td>G</td>
<td>C</td>
</tr>
<tr>
<td>A</td>
<td>T</td>
<td>T</td>
<td>C</td>
<td>C</td>
</tr>
<tr>
<td>T</td>
<td>T</td>
<td>T</td>
<td>G</td>
<td>C</td>
</tr>
<tr>
<td>T</td>
<td>T</td>
<td>T</td>
<td>C</td>
<td>C</td>
</tr>
</tbody>
</table>
<p>A <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> that matches a <a href="#BM_(motif)%2Fi">motif</a> may be referred to as a <a href="#BM_(motif%20member)%2Fi">motif member</a>.</p>
<a name="H_Consensus%20String"></a><h3>Consensus String</h3>
<p><a name="BM_(Algorithms%5C%2FMotif%2FConsensus%20String)_TOPIC%2F"></a><strong></strong></p>
<p><strong>WHAT</strong>: Given a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>, generate a <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> where each position is the nucleotide most abundant at that column of the matrix.</p>
<p><strong>WHY</strong>: Given a set of <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s that are suspected to be part of a <a href="#BM_(motif)%2Fi">motif</a> (<a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>), the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> generated by selecting the most abundant column at each index is the "ideal" <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> for the <a href="#BM_(motif)%2Fi">motif</a>. It's a concise way of describing the <a href="#BM_(motif)%2Fi">motif</a>, especially if the columns in the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> are highly conserved.</p>
<p><strong>ALGORITHM</strong>:</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>It may be more appropriate to use a <a href="#BM_(hybrid%20alphabet%7Calternate%20alphabet%7Calternative%20alphabet)%2Fi">hybrid alphabet</a> when representing <a href="#BM_(consensus%20string%7Cconsensus%20sequence)%2Fi">consensus string</a> because alternate nucleotides could be represented as a single letter. The Pevzner book doesn't mention this specifically but multiple online sources discuss it.</p>
</div>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_consensus_string</span>(<span class="hljs-params">kmers: List[str]</span>) -&gt; str:</span>
    count = len(kmers[<span class="hljs-number">0</span>]);
    out = <span class="hljs-string">''</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, count):
        c = Counter()
        <span class="hljs-keyword">for</span> kmer <span class="hljs-keyword">in</span> kmers:
            c[kmer[i]] += <span class="hljs-number">1</span>
        ch = c.most_common(<span class="hljs-number">1</span>)
        out += ch[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]
    <span class="hljs-keyword">return</span> out</code></pre><div style="border:1px solid black;">
<p></p>
<p>Consensus is TTTCC in <br><br> ATTGC<br>ATTCC<br>TTTGC<br>TTTCC<br>TTTCA</p>
</div>
<p></p>
<a name="H_Motif%20Matrix%20Count"></a><h3>Motif Matrix Count</h3>
<p><a name="BM_(Algorithms%5C%2FMotif%2FMotif%20Matrix%20Count)_TOPIC%2F"></a><strong></strong></p>
<p><strong>WHAT</strong>: Given a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>, count how many of each nucleotide are in each column.</p>
<p><strong>WHY</strong>: Having a count of the number of nucleotides in each column is a basic statistic that gets used further down the line for tasks such as scoring a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>.</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">motif_matrix_count</span>(<span class="hljs-params">motif_matrix: List[str], elements=<span class="hljs-string">'ACGT'</span></span>) -&gt; Dict[str, List[int]]:</span>
    rows = len(motif_matrix)
    cols = len(motif_matrix[<span class="hljs-number">0</span>])

    ret = {}
    <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> elements:
        ret[ch] = [<span class="hljs-number">0</span>] * cols
    
    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, cols):
        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, rows):
            item = motif_matrix[r][c]
            ret[item][c] += <span class="hljs-number">1</span>
            
    <span class="hljs-keyword">return</span> ret</code></pre><div style="border:1px solid black;">
<p></p>
<p>Counting nucleotides at each column of the motif matrix...</p>
<p>ATTGC<br>TTTGC<br>TTTGG<br>ATTGC</p>
<p>Result...</p>
<p>('A', [2, 0, 0, 0, 0])<br>('C', [0, 0, 0, 0, 3])<br>('G', [0, 0, 0, 4, 1])<br>('T', [2, 4, 4, 0, 0])</p>
</div>
<p></p>
<a name="H_Motif%20Matrix%20Profile"></a><h3>Motif Matrix Profile</h3>
<p><a name="BM_(Algorithms%5C%2FMotif%2FMotif%20Matrix%20Profile)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FMotif%20Matrix%20Count)_TOPIC%2F">Algorithms/Motif/Motif Matrix Count</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>, for each column calculate how often A, C, G, and T occur as percentages.</p>
<p><strong>WHY</strong>: The percentages for each column represent a probability distribution for that column. For example, in column 1 of...</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>T</td>
<td>T</td>
<td>C</td>
<td>G</td>
</tr>
<tr>
<td>C</td>
<td>T</td>
<td>T</td>
<td>C</td>
<td>G</td>
</tr>
<tr>
<td>T</td>
<td>T</td>
<td>T</td>
<td>C</td>
<td>G</td>
</tr>
<tr>
<td>T</td>
<td>T</td>
<td>T</td>
<td>T</td>
<td>G</td>
</tr>
</tbody>
</table>
<ul>
<li>A appears 25% of the time.</li>
<li>C appears 25% of the time.</li>
<li>T appears 50% of the time.</li>
<li>G appears 0% of the time.</li>
</ul>
<p>These probability distributions can be used further down the line for tasks such as determining the probability that some arbitrary <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> conforms to the same <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>.</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">motif_matrix_profile</span>(<span class="hljs-params">motif_matrix_counts: Dict[str, List[int]]</span>) -&gt; Dict[str, List[float]]:</span>
    ret = {}
    <span class="hljs-keyword">for</span> elem, counts <span class="hljs-keyword">in</span> motif_matrix_counts.items():
        ret[elem] = [<span class="hljs-number">0.0</span>] * len(counts)

    cols = len(counts)  <span class="hljs-comment"># all elems should have the same len, so just grab the last one that was walked over</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(cols):
        total = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> elem <span class="hljs-keyword">in</span> motif_matrix_counts.keys():
            total += motif_matrix_counts[elem][i]
        <span class="hljs-keyword">for</span> elem <span class="hljs-keyword">in</span> motif_matrix_counts.keys():
            ret[elem][i] = motif_matrix_counts[elem][i] / total

    <span class="hljs-keyword">return</span> ret</code></pre><div style="border:1px solid black;">
<p></p>
<p>Profiling nucleotides at each column of the motif matrix...</p>
<p>ATTCG<br>CTTCG<br>TTTCG<br>TTTTG</p>
<p>Result...</p>
<p>('A', [0.25, 0.0, 0.0, 0.0, 0.0])<br>('C', [0.25, 0.0, 0.0, 0.75, 0.0])<br>('G', [0.0, 0.0, 0.0, 0.0, 1.0])<br>('T', [0.5, 1.0, 1.0, 0.25, 0.0])</p>
</div>
<p></p>
<a name="H_Motif%20Matrix%20Score"></a><h3>Motif Matrix Score</h3>
<p><a name="BM_(Algorithms%5C%2FMotif%2FMotif%20Matrix%20Score)_TOPIC%2F"></a><strong></strong></p>
<p><strong>WHAT</strong>: Given a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>, assign it a score based on how similar the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s that make up the matrix are to each other. Specifically, how conserved the nucleotides at each column are.</p>
<p><strong>WHY</strong>: Given a set of <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s that are suspected to be part of a <a href="#BM_(motif)%2Fi">motif</a> (<a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>), the more similar those <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s are to each other the more likely it is that those <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s are <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a>s of the same <a href="#BM_(motif)%2Fi">motif</a>. This seems to be the case for many enzymes that bind to DNA based on a <a href="#BM_(motif)%2Fi">motif</a> (e.g. <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a>s).</p>
<a name="H_Popularity%20Algorithm"></a><h4>Popularity Algorithm</h4>
<p><strong>ALGORITHM</strong>:</p>
<p>This algorithm scores a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> by summing up the number of unpopular items in a column. For example, imagine a column has 7 Ts, 2 Cs, and 1A. The Ts are the most popular (7 items), meaning that the 3 items (2 Cs and 1 A) are unpopular -- the score for the column is 3.</p>
<p>Sum up each of the column scores to the get the final score for the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>. A lower score is better.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">score_motif</span>(<span class="hljs-params">motif_matrix: List[str]</span>) -&gt; int:</span>
    rows = len(motif_matrix)
    cols = len(motif_matrix[<span class="hljs-number">0</span>])

    <span class="hljs-comment"># count up each column</span>
    counter_per_col = []
    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, cols):
        counter = Counter()
        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, rows):
            counter[motif_matrix[r][c]] += <span class="hljs-number">1</span>
        counter_per_col.append(counter)

    <span class="hljs-comment"># sum counts for each column AFTER removing the top-most count -- that is, consider the top-most count as the</span>
    <span class="hljs-comment"># most popular char, so you're summing the counts of all the UNPOPULAR chars</span>
    unpopular_sums = []
    <span class="hljs-keyword">for</span> counter <span class="hljs-keyword">in</span> counter_per_col:
        most_popular_item = counter.most_common(<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]
        <span class="hljs-keyword">del</span> counter[most_popular_item]
        unpopular_sum = sum(counter.values())
        unpopular_sums.append(unpopular_sum)

    <span class="hljs-keyword">return</span> sum(unpopular_sums)</code></pre><div style="border:1px solid black;">
<p></p>
<p>Scoring...</p>
<p>ATTGC<br>TTTGC<br>TTTGG<br>ATTGC</p>
<p>3</p>
</div>
<p></p>
<a name="H_Entropy%20Algorithm"></a><h4>Entropy Algorithm</h4>
<p><a name="BM_(Algorithms%5C%2FMotif%2FMotif%20Matrix%20Score%2FEntropy%20Algorithm)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FMotif%20Matrix%20Profile)_TOPIC%2F">Algorithms/Motif/Motif Matrix Profile</a></li>
</ul>
</div>
<p><strong>ALGORITHM</strong>:</p>
<p>This algorithm scores a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> by calculating the <a href="#BM_(entropy)%2Fi">entropy</a> of each column in the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>. <a href="#BM_(entropy)%2Fi">Entropy</a> is defined as the level of uncertainty for some variable. The more uncertain the nucleotides are in the column of a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>, the higher (worse) the score. For example, given a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> with 10 rows, a column with ...</p>
<ul>
<li>10 A nucleotides has low <a href="#BM_(entropy)%2Fi">entropy</a> because it's highly conserved,</li>
<li>6 A and 4 T nucleotides has a higher <a href="#BM_(entropy)%2Fi">entropy</a> because it's less highly conserved.</li>
</ul>
<p>Sum the output for each column to get the final score for the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>. A lower score is better.</p>
<pre class="hljs"><code><span class="hljs-comment"># According to the book, method of scoring a motif matrix as defined in ScoreMotif.py isn't the method used in the</span>
<span class="hljs-comment"># real-world. The method used in the real-world is this method, where...</span>
<span class="hljs-comment"># 1. each column has its probability distribution calculated (prob of A vs prob C vs prob of T vs prob of G)</span>
<span class="hljs-comment"># 2. the entropy of each of those prob dist are calculated</span>
<span class="hljs-comment"># 3. those entropies are summed up to get the ENTROPY OF THE MOTIF MATRIX</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calculate_entropy</span>(<span class="hljs-params">values: List[float]</span>) -&gt; float:</span>
    ret = <span class="hljs-number">0.0</span>
    <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> values:
        ret += value * (log(value, <span class="hljs-number">2.0</span>) <span class="hljs-keyword">if</span> value &gt; <span class="hljs-number">0.0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0.0</span>)
    ret = -ret
    <span class="hljs-keyword">return</span> ret

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">score_motify_entropy</span>(<span class="hljs-params">motif_matrix: List[str]</span>) -&gt; float:</span>
    rows = len(motif_matrix)
    cols = len(motif_matrix[<span class="hljs-number">0</span>])

    <span class="hljs-comment"># count up each column</span>
    counts = motif_matrix_count(motif_matrix)
    profile = motif_matrix_profile(counts)

    <span class="hljs-comment"># prob dist to entropy</span>
    entropy_per_col = []
    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> range(cols):
        entropy = calculate_entropy([profile[<span class="hljs-string">'A'</span>][c], profile[<span class="hljs-string">'C'</span>][c], profile[<span class="hljs-string">'G'</span>][c], profile[<span class="hljs-string">'T'</span>][c]])
        entropy_per_col.append(entropy)

    <span class="hljs-comment"># sum up entropies to get entropy of motif</span>
    <span class="hljs-keyword">return</span> sum(entropy_per_col)</code></pre><div style="border:1px solid black;">
<p></p>
<p>Scoring...</p>
<p>ATTGC<br>TTTGC<br>TTTGG<br>ATTGC</p>
<p>1.811278124459133</p>
</div>
<p></p>
<a name="H_Relative%20Entropy%20Algorithm"></a><h4>Relative Entropy Algorithm</h4>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FMotif%20Matrix%20Score%2FEntropy%20Algorithm)_TOPIC%2F">Algorithms/Motif/Motif Matrix Score/Entropy Algorithm</a></li>
</ul>
</div>
<p><strong>ALGORITHM</strong>:</p>
<p>This algorithm scores a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> by calculating the <a href="#BM_(entropy)%2Fi">entropy</a> of each column relative to the overall nucleotide distribution of the <a href="#BM_(sequence)%2Fi">sequence</a>s from which each <a href="#BM_(motif%20member)%2Fi">motif member</a> came from. This is important when finding <a href="#BM_(motif%20member)%2Fi">motif member</a>s across a set of <a href="#BM_(sequence)%2Fi">sequence</a>s. For example, the following <a href="#BM_(sequence)%2Fi">sequence</a>s have a nucleotide distribution highly skewed towards C...</p>
<table>
<thead>
<tr>
<th><a href="#BM_(sequence)%2Fi">Sequence</a>s</th>
</tr>
</thead>
<tbody>
<tr>
<td>CCCCCCCCCCCCCCCCCATTGCCCC</td>
</tr>
<tr>
<td>ATTCCCCCCCCCCCCCCCCCCCCCC</td>
</tr>
<tr>
<td>CCCCCCCCCCCCCCCTTTGCCCCCC</td>
</tr>
<tr>
<td>CCCCCCTTTCTCCCCCCCCCCCCCC</td>
</tr>
</tbody>
</table>
<p>Given the <a href="#BM_(sequence)%2Fi">sequence</a>s in the example above, of all <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrices</a> possible for k=5, basic <a href="#BM_(entropy)%2Fi">entropy</a> scoring will always lead to a matrix filled with Cs:</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>C</td>
<td>C</td>
<td>C</td>
<td>C</td>
<td>C</td>
</tr>
<tr>
<td>C</td>
<td>C</td>
<td>C</td>
<td>C</td>
<td>C</td>
</tr>
<tr>
<td>C</td>
<td>C</td>
<td>C</td>
<td>C</td>
<td>C</td>
</tr>
<tr>
<td>C</td>
<td>C</td>
<td>C</td>
<td>C</td>
<td>C</td>
</tr>
</tbody>
</table>
<p>Even though the above <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> scores perfect, it's likely junk. <a href="#BM_%5Cb(member)_MOTIF%2Fi">Member</a>s containing all Cs score better because the <a href="#BM_(sequence)%2Fi">sequence</a>s they come from are biased (saturated with Cs), not because they share some higher biological significance.</p>
<p>To reduce bias, the nucleotide distributions from which the <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a>s came from need to be factored in to the <a href="#BM_(entropy)%2Fi">entropy</a> calculation: relative <a href="#BM_(entropy)%2Fi">entropy</a>.</p>
<pre class="hljs"><code><span class="hljs-comment"># <span class="hljs-doctag">NOTE:</span> This is different from the traditional version of entropy -- it doesn't negate the sum before returning it.</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calculate_entropy</span>(<span class="hljs-params">probabilities_for_nuc: List[float]</span>) -&gt; float:</span>
    ret = <span class="hljs-number">0.0</span>
    <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> probabilities_for_nuc:
        ret += value * (log(value, <span class="hljs-number">2.0</span>) <span class="hljs-keyword">if</span> value &gt; <span class="hljs-number">0.0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0.0</span>)
    <span class="hljs-keyword">return</span> ret


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calculate_cross_entropy</span>(<span class="hljs-params">probabilities_for_nuc: List[float], total_frequencies_for_nucs: List[float]</span>) -&gt; float:</span>
    ret = <span class="hljs-number">0.0</span>
    <span class="hljs-keyword">for</span> prob, total_freq <span class="hljs-keyword">in</span> zip(probabilities_for_nuc, total_frequencies_for_nucs):
        ret += prob * (log(total_freq, <span class="hljs-number">2.0</span>) <span class="hljs-keyword">if</span> total_freq &gt; <span class="hljs-number">0.0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0.0</span>)
    <span class="hljs-keyword">return</span> ret


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">score_motif_relative_entropy</span>(<span class="hljs-params">motif_matrix: List[str], source_strs: List[str]</span>) -&gt; float:</span>
    <span class="hljs-comment"># calculate frequency of nucleotide across all source strings</span>
    nuc_counter = Counter()
    nuc_total = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> source_str <span class="hljs-keyword">in</span> source_strs:
        <span class="hljs-keyword">for</span> nuc <span class="hljs-keyword">in</span> source_str:
            nuc_counter[nuc] += <span class="hljs-number">1</span>
        nuc_total += len(source_str)
    nuc_freqs = dict([(k, v / nuc_total) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> nuc_counter.items()])

    rows = len(motif_matrix)
    cols = len(motif_matrix[<span class="hljs-number">0</span>])

    <span class="hljs-comment"># count up each column</span>
    counts = motif_matrix_count(motif_matrix)
    profile = motif_matrix_profile(counts)
    relative_entropy_per_col = []
    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> range(cols):
        <span class="hljs-comment"># get entropy of column in motif</span>
        entropy = calculate_entropy(
            [
                profile[<span class="hljs-string">'A'</span>][c],
                profile[<span class="hljs-string">'C'</span>][c],
                profile[<span class="hljs-string">'G'</span>][c],
                profile[<span class="hljs-string">'T'</span>][c]
            ]
        )
        <span class="hljs-comment"># get cross entropy of column in motif (mixes in global nucleotide frequencies)</span>
        cross_entropy = calculate_cross_entropy(
            [
                profile[<span class="hljs-string">'A'</span>][c],
                profile[<span class="hljs-string">'C'</span>][c],
                profile[<span class="hljs-string">'G'</span>][c],
                profile[<span class="hljs-string">'T'</span>][c]
            ],
            [
                nuc_freqs[<span class="hljs-string">'A'</span>],
                nuc_freqs[<span class="hljs-string">'C'</span>],
                nuc_freqs[<span class="hljs-string">'G'</span>],
                nuc_freqs[<span class="hljs-string">'T'</span>]
            ]
        )
        relative_entropy = entropy - cross_entropy
        <span class="hljs-comment"># Right now relative_entropy is calculated by subtracting cross_entropy from (a negated) entropy. But, according</span>
        <span class="hljs-comment"># to the Pevzner book, the calculation of relative_entropy can be simplified to just...</span>
        <span class="hljs-comment"># def calculate_relative_entropy(probabilities_for_nuc: List[float], total_frequencies_for_nucs: List[float]) -&gt; float:</span>
        <span class="hljs-comment">#     ret = 0.0</span>
        <span class="hljs-comment">#     for prob, total_freq in zip(probabilities_for_nuc, total_frequency_for_nucs):</span>
        <span class="hljs-comment">#         ret += value * (log(value / total_freq, 2.0) if value &gt; 0.0 else 0.0)</span>
        <span class="hljs-comment">#     return ret</span>
        relative_entropy_per_col.append(relative_entropy)

    <span class="hljs-comment"># sum up entropies to get entropy of motif</span>
    ret = sum(relative_entropy_per_col)

    <span class="hljs-comment"># All of the other score_motif algorithms try to MINIMIZE score. In the case of relative entropy (this algorithm),</span>
    <span class="hljs-comment"># the greater the score is the better of a match it is. As such, negate this score so the existing algorithms can</span>
    <span class="hljs-comment"># still try to minimize.</span>
    <span class="hljs-keyword">return</span> -ret</code></pre><div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>In the outputs below, the score in the second output should be less than (better) the score in the first output.</p>
</div>
<div style="border:1px solid black;">
<p></p>
<p>Scoring...</p>
<p>CCCCC<br>CCCCC<br>CCCCC<br>CCCCC</p>
<p>... which was pulled from ...</p>
<p>CCCCCCCCCCCCCCCCCATTGCCCC<br>ATTCCCCCCCCCCCCCCCCCCCCCC<br>CCCCCCCCCCCCCCCTTTGCCCCCC<br>CCCCCCTTTCTCCCCCCCCCCCCCC</p>
<p>-1.172326268185115</p>
</div>
<p></p>
<div style="border:1px solid black;">
<p></p>
<p>Scoring...</p>
<p>ATTGC<br>ATTCC<br>CTTTG<br>TTTCT</p>
<p>... which was pulled from ...</p>
<p>CCCCCCCCCCCCCCCCCATTGCCCC<br>ATTCCCCCCCCCCCCCCCCCCCCCC<br>CCCCCCCCCCCCCCCTTTGCCCCCC<br>CCCCCCTTTCTCCCCCCCCCCCCCC</p>
<p>-10.194105327448927</p>
</div>
<p></p>
<a name="H_Motif%20Logo"></a><h3>Motif Logo</h3>
<p><a name="BM_(Algorithms%5C%2FMotif%2FMotif%20Logo)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FMotif%20Matrix%20Score%2FEntropy%20Algorithm)_TOPIC%2F">Algorithms/Motif/Motif Matrix Score/Entropy Algorithm</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>, generate a graphical representation showing how conserved the <a href="#BM_(motif)%2Fi">motif</a> is. Each position has its possible nucleotides stacked on top of each other, where the height of each nucleotide is based on how conserved it is. The more conserved a position is, the taller that column will be. This type of graphical representation is called a <a href="#BM_(%5Cblogo%7Csequence%20logo)%2Fi">sequence logo</a>.</p>
<p><strong>WHY</strong>: A <a href="#BM_(%5Cblogo%7Csequence%20logo)%2Fi">sequence logo</a> helps more quickly convey the characteristics of the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> it's for.</p>
<p><strong>ALGORITHM</strong>:</p>
<p>For this particular <a href="#BM_(%5Cblogo%7Csequence%20logo)%2Fi">logo</a> implementation, a lower <a href="#BM_(entropy)%2Fi">entropy</a> results in a taller overall column.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calculate_entropy</span>(<span class="hljs-params">values: List[float]</span>) -&gt; float:</span>
    ret = <span class="hljs-number">0.0</span>
    <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> values:
        ret += value * (log(value, <span class="hljs-number">2.0</span>) <span class="hljs-keyword">if</span> value &gt; <span class="hljs-number">0.0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0.0</span>)
    ret = -ret
    <span class="hljs-keyword">return</span> ret

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_logo</span>(<span class="hljs-params">motif_matrix_profile: Dict[str, List[float]]</span>) -&gt; Logo:</span>
    columns = list(motif_matrix_profile.keys())
    data = [motif_matrix_profile[k] <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> motif_matrix_profile.keys()]
    data = list(zip(*data))  <span class="hljs-comment"># trick to transpose data</span>

    entropies = list(map(<span class="hljs-keyword">lambda</span> x: <span class="hljs-number">2</span> - calculate_entropy(x), data))

    data_scaledby_entropies = [[p * e <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> d] <span class="hljs-keyword">for</span> d, e <span class="hljs-keyword">in</span> zip(data, entropies)]

    df = pd.DataFrame(
        columns=columns,
        data=data_scaledby_entropies
    )
    logo = lm.Logo(df)
    logo.ax.set_ylabel(<span class="hljs-string">'information (bits)'</span>)
    logo.ax.set_xlim([<span class="hljs-number">-1</span>, len(df)])
    <span class="hljs-keyword">return</span> logo</code></pre><div style="border:1px solid black;">
<p></p>
<p>Generating logo for the following motif matrix...</p>
<p>TCGGGGGTTTTT<br>CCGGTGACTTAC<br>ACGGGGATTTTC<br>TTGGGGACTTTT<br>AAGGGGACTTCC<br>TTGGGGACTTCC<br>TCGGGGATTCAT<br>TCGGGGATTCCT<br>TAGGGGAACTAC<br>TCGGGTATAACC</p>
<p>Result...</p>
<p><img src="motif_logo_01b7e8763a84973751af52163d52f5bd.svg" alt="Motif Logo"></p>
</div>
<p></p>
<a name="H_K-mer%20Match%20Probability"></a><h3>K-mer Match Probability</h3>
<p><a name="BM_(Algorithms%5C%2FMotif%2FK-mer%20Match%20Probability)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FMotif%20Matrix%20Count)_TOPIC%2F">Algorithms/Motif/Motif Matrix Count</a></li>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FMotif%20Matrix%20Profile)_TOPIC%2F">Algorithms/Motif/Motif Matrix Profile</a></li>
<li><a href="#BM_(Algorithms%5C%2FK-mer)_TOPIC%2F">Algorithms/K-mer</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> and a <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>, calculate the probability of that <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> being a <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a> of that <a href="#BM_(motif)%2Fi">motif</a>.</p>
<p><strong>WHY</strong>: Being able to determine if a <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> is potentially a <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a> of a <a href="#BM_(motif)%2Fi">motif</a> can help speed up experiments. For example, imagine that you suspect 21 different <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">genes</a> of being regulated by the same <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a>. You isolate the <a href="#BM_(transcription%20factor%20binding%20site)%2Fi">transcription factor binding site</a> for 6 of those <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">genes</a> and use their <a href="#BM_(sequence)%2Fi">sequence</a>s as the underlying <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s for a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>. That <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> doesn't represent the <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a>'s <a href="#BM_(motif)%2Fi">motif</a> exactly, but it's close enough that you can use it to scan through the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s in the remaining 15 <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">genes</a> and calculate the probability of them being <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a>s of the same <a href="#BM_(motif)%2Fi">motif</a>.</p>
<p>If a <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> exists such that it conforms to the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> with a high probability, it likely is a <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a> of the <a href="#BM_(motif)%2Fi">motif</a>.</p>
<p><strong>ALGORITHM</strong>:</p>
<p>Imagine the following <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>:</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>T</td>
<td>G</td>
<td>C</td>
<td>A</td>
<td>C</td>
</tr>
<tr>
<td>A</td>
<td>T</td>
<td>G</td>
<td>C</td>
<td>A</td>
<td>C</td>
</tr>
<tr>
<td>A</td>
<td>T</td>
<td>C</td>
<td>C</td>
<td>A</td>
<td>C</td>
</tr>
<tr>
<td>A</td>
<td>T</td>
<td>C</td>
<td>C</td>
<td>A</td>
<td>C</td>
</tr>
</tbody>
</table>
<p>Calculating the counts for that <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> results in:</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>4</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>4</td>
<td>0</td>
</tr>
<tr>
<td>C</td>
<td>0</td>
<td>0</td>
<td>2</td>
<td>4</td>
<td>0</td>
<td>4</td>
</tr>
<tr>
<td>T</td>
<td>0</td>
<td>4</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>G</td>
<td>0</td>
<td>0</td>
<td>2</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>Calculating the profile from those counts results in:</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>C</td>
<td>0</td>
<td>0</td>
<td>0.5</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>T</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>G</td>
<td>0</td>
<td>0</td>
<td>0.5</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>Using this profile, the probability that a <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> conforms to the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> is calculated by mapping the nucleotide at each position of the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> to the corresponding nucleotide in the corresponding position of the profile and multiplying them together. For example, the probability that the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>...</p>
<ul>
<li>ATGCAC conforms to the example profile above is calculated as 1*1*0.5*1*1*1 = 0.5</li>
<li>TTGCAC conforms to the example profile above is calculated as 0*1*0.5*1*1*1 = 0</li>
</ul>
<p>Of the these two <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s, ...</p>
<ul>
<li>all positions in the first (ATGCAC) have been seen before in the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>.</li>
<li>all but one position in the second (TTGCAC) have been seen before in the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> (index 0).</li>
</ul>
<p>Both of these <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s should have a reasonable probability of being <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a>s of the <a href="#BM_(motif)%2Fi">motif</a>. However, notice how the second <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> ends up with a 0 probability. The reason has to do with the underlying concept behind <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrices</a>: the entire point of a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> is to use the known <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a>s of a <a href="#BM_(motif)%2Fi">motif</a> to find other potential <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a>s of that same <a href="#BM_(motif)%2Fi">motif</a>. The second <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> contains a T at index 0, but none of the known <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a>s of the <a href="#BM_(motif)%2Fi">motif</a> have a T at that index. As such, its probability gets reduced to 0 even though the rest of the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> conforms.</p>
<p><a href="#BM_(Cromwell's%20rule)%2Fi">Cromwell's rule</a> says that when a probability is based off past events, a hard 0 or 1 values shouldn't be used. As such, a quick workaround to the 0% probability problem described above is to artificially inflate the counts that lead to the profile such that no count is 0 (<a href="#BM_(pseudocount)%2Fi">pseudocount</a>s). For example, for the same <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>, incrementing the counts by 1 results in:</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>5</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>5</td>
<td>1</td>
</tr>
<tr>
<td>C</td>
<td>1</td>
<td>1</td>
<td>3</td>
<td>5</td>
<td>1</td>
<td>5</td>
</tr>
<tr>
<td>T</td>
<td>1</td>
<td>5</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>G</td>
<td>1</td>
<td>1</td>
<td>3</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>Calculating the profile from those inflated counts results in:</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>0.625</td>
<td>0.125</td>
<td>0.125</td>
<td>0.125</td>
<td>0.625</td>
<td>0.125</td>
</tr>
<tr>
<td>C</td>
<td>0.125</td>
<td>0.125</td>
<td>0.375</td>
<td>0.625</td>
<td>0.125</td>
<td>0.625</td>
</tr>
<tr>
<td>T</td>
<td>0.125</td>
<td>0.625</td>
<td>0.125</td>
<td>0.125</td>
<td>0.125</td>
<td>0.125</td>
</tr>
<tr>
<td>G</td>
<td>0.125</td>
<td>0.125</td>
<td>0.375</td>
<td>0.125</td>
<td>0.125</td>
<td>0.125</td>
</tr>
</tbody>
</table>
<p>Using this new profile, the probability that the previous <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s conform are:</p>
<ul>
<li>ATGCAC is calculated as 0.625*0.625*0.325*0.625*0.625*0.625 = 0.031</li>
<li>TTGCAC is calculated as 0.125*0.625*0.325*0.625*0.625*0.625 = 0.0062</li>
</ul>
<p>Although the probabilities seem low, it's all relative. The probability calculated for the first <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> (ATGCAC) is the highest probability possible -- each position in the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> maps to the highest probability nucleotide of the corresponding position of the profile.</p>
<pre class="hljs"><code><span class="hljs-comment"># Run this on the counts before generating the profile to avoid the 0 probability problem.</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply_psuedocounts_to_count_matrix</span>(<span class="hljs-params">counts: Dict[str, List[int]], extra_count: int = <span class="hljs-number">1</span></span>):</span>
    <span class="hljs-keyword">for</span> elem, elem_counts <span class="hljs-keyword">in</span> counts.items():
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(elem_counts)):
            elem_counts[i] += extra_count


<span class="hljs-comment"># Recall that a profile matrix is a matrix of probabilities. Each row represents a single element (e.g. nucleotide) and</span>
<span class="hljs-comment"># each column represents the probability distribution for that position.</span>
<span class="hljs-comment">#</span>
<span class="hljs-comment"># So for example, imagine the following probability distribution...</span>
<span class="hljs-comment">#</span>
<span class="hljs-comment">#     1   2   3   4</span>
<span class="hljs-comment"># A: 0.2 0.2 0.0 0.0</span>
<span class="hljs-comment"># C: 0.1 0.6 0.0 0.0</span>
<span class="hljs-comment"># G: 0.1 0.0 1.0 1.0</span>
<span class="hljs-comment"># T: 0.7 0.2 0.0 0.0</span>
<span class="hljs-comment">#</span>
<span class="hljs-comment"># At position 2, the probability that the element will be C is 0.6 while the probability that it'll be T is 0.2. Note</span>
<span class="hljs-comment"># how each column sums to 1.</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">determine_probability_of_match_using_profile_matrix</span>(<span class="hljs-params">profile: Dict[str, List[float]], kmer: str</span>):</span>
    prob = <span class="hljs-number">1.0</span>
    <span class="hljs-keyword">for</span> idx, elem <span class="hljs-keyword">in</span> enumerate(kmer):
        prob = prob * profile[elem][idx]
    <span class="hljs-keyword">return</span> prob


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_most_probable_kmer_using_profile_matrix</span>(<span class="hljs-params">profile: Dict[str, List[float]], dna: str</span>):</span>
    k = len(list(profile.values())[<span class="hljs-number">0</span>])

    most_probable: Tuple[str, float] = <span class="hljs-literal">None</span>  <span class="hljs-comment"># [kmer, probability]</span>
    <span class="hljs-keyword">for</span> kmer, _ <span class="hljs-keyword">in</span> slide_window(dna, k):
        prob = determine_probability_of_match_using_profile_matrix(profile, kmer)
        <span class="hljs-keyword">if</span> most_probable <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> prob &gt; most_probable[<span class="hljs-number">1</span>]:
            most_probable = (kmer, prob)

    <span class="hljs-keyword">return</span> most_probable</code></pre><div style="border:1px solid black;">
<p></p>
<p>Motif matrix...</p>
<p>ATGCAC<br>ATGCAC<br>ATCCAC</p>
<p>Probability that TTGCAC matches the motif 0.0...</p>
</div>
<p></p>
<a name="H_Find%20Motif%20Matrix"></a><h3>Find Motif Matrix</h3>
<p><a name="BM_(Algorithms%5C%2FMotif%2FFind%20Motif%20Matrix)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FK-mer%20Match%20Probability)_TOPIC%2F">Algorithms/Motif/K-mer Match Probability</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given a set of <a href="#BM_(sequence)%2Fi">sequence</a>s, find <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s in those <a href="#BM_(sequence)%2Fi">sequence</a>s that may be <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a>s of the same <a href="#BM_(motif)%2Fi">motif</a>.</p>
<p><strong>WHY</strong>: A <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a> is an enzyme that either increases or decreases a <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">gene</a>'s <a href="#BM_(transcription%7Ctranscribed%7Ctranscribe)%2Fi">transcription</a> rate. It does so by binding to a specific part of the <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">gene</a>'s <a href="#BM_(upstream%20region)%2Fi">upstream region</a> called the <a href="#BM_(transcription%20factor%20binding%20site)%2Fi">transcription factor binding site</a>. That <a href="#BM_(transcription%20factor%20binding%20site)%2Fi">transcription factor binding site</a> consists of a <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> that matches the <a href="#BM_(motif)%2Fi">motif</a> expected by that <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a>, called a <a href="#BM_(regulatory%20motif)%2Fi">regulatory motif</a>.</p>
<p>A single <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a> may operate on many different <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">genes</a>. Often times a scientist will identify a set of <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">genes</a> that are suspected to be regulated by a single <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a>, but that scientist won't know ...</p>
<ul>
<li>what the <a href="#BM_(regulatory%20motif)%2Fi">regulatory motif</a> is (the pattern expected by the enzyme).</li>
<li>where the <a href="#BM_(transcription%20factor%20binding%20site)%2Fi">transcription factor binding site</a>s are (which <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s the enzyme is targeting).</li>
<li>how long the <a href="#BM_(transcription%20factor%20binding%20site)%2Fi">transcription factor binding site</a>s are (which k the enzyme is targeting).</li>
</ul>
<p>The <a href="#BM_(regulatory%20motif)%2Fi">regulatory motif</a> expected by a <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a> typically expects <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s that have the same length and are similar to each other (short hamming distance). As such, potential <a href="#BM_(motif)%2Fi">motif</a> candidates can be derived by finding <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s across the set of <a href="#BM_(sequence)%2Fi">sequence</a>s that are similar to each other.</p>
<a name="H1_Bruteforce%20Algorithm"></a><h4>Bruteforce Algorithm</h4>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FK-mer%2FHamming%20Distance%20Neighbourhood)_TOPIC%2F">Algorithms/K-mer/Hamming Distance Neighbourhood</a></li>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FMotif%20Matrix%20Score)_TOPIC%2F">Algorithms/Motif/Motif Matrix Score</a></li>
</ul>
</div>
<p><strong>ALGORITHM</strong>:</p>
<p>This algorithm scans over all <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s in a set of DNA <a href="#BM_(sequence)%2Fi">sequence</a>s, enumerates the hamming distance neighbourhood of each <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>, and uses the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s from the hamming distance neighbourhood to build out possible <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrices</a>. Of all the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrices</a> built, it selects the one with the lowest score.</p>
<p>Neither k nor the mismatches allowed by the <a href="#BM_(motif)%2Fi">motif</a> is known. As such, the algorithm may need to be repeated multiple times with different value combinations.</p>
<p>Even for trivial inputs, this algorithm falls over very quickly. It's intended to help conceptualize the problem of <a href="#BM_(motif)%2Fi">motif</a> finding.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">enumerate_hamming_distance_neighbourhood_for_all_kmer</span>(<span class="hljs-params">
        dna: str,             <span class="hljs-comment"># dna strings to search in for motif</span>
        k: int,               <span class="hljs-comment"># k-mer length</span>
        max_mismatches: int   <span class="hljs-comment"># max num of mismatches for motif (hamming dist)</span>
</span>) -&gt; Set[str]:</span>
    kmers_to_check = set()
    <span class="hljs-keyword">for</span> kmer, _ <span class="hljs-keyword">in</span> slide_window(dna, k):
        neighbouring_kmers = find_all_dna_kmers_within_hamming_distance(kmer, max_mismatches)
        kmers_to_check |= neighbouring_kmers

    <span class="hljs-keyword">return</span> kmers_to_check


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exhaustive_motif_search</span>(<span class="hljs-params">dnas: List[str], k: int, max_mismatches: int</span>):</span>
    kmers_for_dnas = [enumerate_hamming_distance_neighbourhood_for_all_kmer(dna, k, max_mismatches) <span class="hljs-keyword">for</span> dna <span class="hljs-keyword">in</span> dnas]

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">build_next_matrix</span>(<span class="hljs-params">out_matrix: List[str]</span>):</span>
        idx = len(out_matrix)
        <span class="hljs-keyword">if</span> len(kmers_for_dnas) == idx:
            <span class="hljs-keyword">yield</span> out_matrix[:]
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">for</span> kmer <span class="hljs-keyword">in</span> kmers_for_dnas[idx]:
                out_matrix.append(kmer)
                <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> build_next_matrix(out_matrix)
                out_matrix.pop()

    best_motif_matrix = <span class="hljs-literal">None</span>
    <span class="hljs-keyword">for</span> next_motif_matrix <span class="hljs-keyword">in</span> build_next_matrix([]):
        <span class="hljs-keyword">if</span> best_motif_matrix <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> score_motif(next_motif_matrix) &lt; score_motif(best_motif_matrix):
            best_motif_matrix = next_motif_matrix

    <span class="hljs-keyword">return</span> best_motif_matrix</code></pre><div style="border:1px solid black;">
<p></p>
<p>Searching for motif of k=5 and a max of 1 mismatches in the following...</p>
<p>ATAAAGGGATA<br>ACAGAAATGAT<br>TGAAATAACCT</p>
<p>Found the motif matrix...</p>
<p>AAAGA<br>AAAGA<br>AAAGA</p>
</div>
<p></p>
<a name="H_Median%20String%20Algorithm"></a><h4>Median String Algorithm</h4>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FConsensus%20String)_TOPIC%2F">Algorithms/Motif/Consensus String</a></li>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FMotif%20Matrix%20Score)_TOPIC%2F">Algorithms/Motif/Motif Matrix Score</a></li>
<li><a href="#BM_(Algorithms%5C%2FK-mer%2FHamming%20Distance)_TOPIC%2F">Algorithms/K-mer/Hamming Distance</a></li>
</ul>
</div>
<p><strong>ALGORITHM</strong>:</p>
<p>This algorithm takes advantage of the fact that the same score can be derived by scoring a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> either row-by-row or column-by-column. For example, the score for the following <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> is 3...</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>A</td>
<td>T</td>
<td><strong>G</strong></td>
<td>C</td>
<td>A</td>
<td>C</td>
<td></td>
</tr>
<tr>
<td></td>
<td>A</td>
<td>T</td>
<td><strong>G</strong></td>
<td>C</td>
<td>A</td>
<td>C</td>
<td></td>
</tr>
<tr>
<td></td>
<td>A</td>
<td>T</td>
<td>C</td>
<td>C</td>
<td><strong>T</strong></td>
<td>C</td>
<td></td>
</tr>
<tr>
<td></td>
<td>A</td>
<td>T</td>
<td>C</td>
<td>C</td>
<td>A</td>
<td>C</td>
<td></td>
</tr>
<tr>
<td>Score</td>
<td>0</td>
<td>0</td>
<td>2</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>For each column, the number of unpopular nucleotides is counted. Then, those counts are summed to get the score: 0 + 0 + 2 + 0 + 1 + 0 = 3.</p>
<p>That exact same score scan be calculated by working through the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> row-by-row...</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>Score</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>T</td>
<td><strong>G</strong></td>
<td>C</td>
<td>A</td>
<td>C</td>
<td>1</td>
</tr>
<tr>
<td>A</td>
<td>T</td>
<td><strong>G</strong></td>
<td>C</td>
<td>A</td>
<td>C</td>
<td>1</td>
</tr>
<tr>
<td>A</td>
<td>T</td>
<td>C</td>
<td>C</td>
<td><strong>T</strong></td>
<td>C</td>
<td>1</td>
</tr>
<tr>
<td>A</td>
<td>T</td>
<td>C</td>
<td>C</td>
<td>A</td>
<td>C</td>
<td>0</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>3</td>
</tr>
</tbody>
</table>
<p>For each row, the number of unpopular nucleotides is counted. Then, those counts are summed to get the score: 1 + 1 + 1 + 0 = 3.</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>Score</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>A</td>
<td>T</td>
<td><strong>G</strong></td>
<td>C</td>
<td>A</td>
<td>C</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>A</td>
<td>T</td>
<td><strong>G</strong></td>
<td>C</td>
<td>A</td>
<td>C</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>A</td>
<td>T</td>
<td>C</td>
<td>C</td>
<td><strong>T</strong></td>
<td>C</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>A</td>
<td>T</td>
<td>C</td>
<td>C</td>
<td>A</td>
<td>C</td>
<td>0</td>
</tr>
<tr>
<td>Score</td>
<td>0</td>
<td>0</td>
<td>2</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>Notice how each row's score is equivalent to the hamming distance between the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> at that row and the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>'s <a href="#BM_(consensus%20string%7Cconsensus%20sequence)%2Fi">consensus string</a>. Specifically, the <a href="#BM_(consensus%20string%7Cconsensus%20sequence)%2Fi">consensus string</a> for the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> is ATCCAC. For each row, ...</p>
<ul>
<li>hamming_distance(ATGCAC, ATCCAC) = 1</li>
<li>hamming_distance(ATGCAC, ATCCAC) = 1</li>
<li>hamming_distance(ATCCTC, ATCCAC) = 1</li>
<li>hamming_distance(ATCCAC, ATCCAC) = 0</li>
</ul>
<p>Given these facts, this algorithm constructs a set of <a href="#BM_(consensus%20string%7Cconsensus%20sequence)%2Fi">consensus string</a>s by enumerating through all possible <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s for some k. Then, for each <a href="#BM_(consensus%20string%7Cconsensus%20sequence)%2Fi">consensus string</a>, it scans over each <a href="#BM_(sequence)%2Fi">sequence</a> to find the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> that minimizes the hamming distance for that <a href="#BM_(consensus%20string%7Cconsensus%20sequence)%2Fi">consensus string</a>. These <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s are used as the <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a>s of a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>.</p>
<p>Of all the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrices</a> built, the one with the lowest score is selected.</p>
<p>Since the k for the <a href="#BM_(motif)%2Fi">motif</a> is unknown, this algorithm may need to be repeated multiple times with different k values. This algorithm also doesn't scale very well. For k=10, 1048576 different <a href="#BM_(consensus%20string%7Cconsensus%20sequence)%2Fi">consensus string</a>s are possible.</p>
<pre class="hljs"><code><span class="hljs-comment"># The name is slightly confusing. What this actually does...</span>
<span class="hljs-comment">#   For each dna string:</span>
<span class="hljs-comment">#     Find the k-mer with the min hamming distance between the k-mers that make up the DNA string and pattern</span>
<span class="hljs-comment">#   Sum up the min hamming distances of the found k-mers (equivalent to the motif matrix score)</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">distance_between_pattern_and_strings</span>(<span class="hljs-params">pattern: str, dnas: List[str]</span>) -&gt; int:</span>
    min_hds = []

    k = len(pattern)
    <span class="hljs-keyword">for</span> dna <span class="hljs-keyword">in</span> dnas:
        min_hd = <span class="hljs-literal">None</span>
        <span class="hljs-keyword">for</span> dna_kmer, _ <span class="hljs-keyword">in</span> slide_window(dna, k):
            hd = hamming_distance(pattern, dna_kmer)
            <span class="hljs-keyword">if</span> min_hd <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> hd &lt; min_hd:
                min_hd = hd
        min_hds.append(min_hd)
    <span class="hljs-keyword">return</span> sum(min_hds)


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">median_string</span>(<span class="hljs-params">k: int, dnas: List[str]</span>):</span>
    last_best: Tuple[str, int] = <span class="hljs-literal">None</span>  <span class="hljs-comment"># last found consensus string and its score</span>
    <span class="hljs-keyword">for</span> kmer <span class="hljs-keyword">in</span> enumerate_patterns(k):
        score = distance_between_pattern_and_strings(kmer, dnas)  <span class="hljs-comment"># find score of best motif matrix where consensus str is kmer</span>
        <span class="hljs-keyword">if</span> last_best <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> score &lt; last_best[<span class="hljs-number">1</span>]:
            last_best = kmer, score
    <span class="hljs-keyword">return</span> last_best</code></pre><div style="border:1px solid black;">
<p></p>
<p>Searching for motif of k=3 in the following...</p>
<p>AAATTGACGCAT<br>GACGACCACGTT<br>CGTCAGCGCCTG<br>GCTGAGCACCGG<br>AGTTCGGGACAG</p>
<p>Found the consensus string GAC with a score of 2</p>
</div>
<p></p>
<a name="H_Greedy%20Algorithm"></a><h4>Greedy Algorithm</h4>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FMotif%20Matrix%20Score)_TOPIC%2F">Algorithms/Motif/Motif Matrix Score</a></li>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FK-mer%20Match%20Probability)_TOPIC%2F">Algorithms/Motif/K-mer Match Probability</a></li>
</ul>
</div>
<p><strong>ALGORITHM</strong>:</p>
<p>This algorithm begins by constructing a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> where the only <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a> is a <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> picked from the first <a href="#BM_(sequence)%2Fi">sequence</a>. From there, it goes through the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s in the ...</p>
<ol>
<li>second <a href="#BM_(sequence)%2Fi">sequence</a> to find the one that has the highest match probability to the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> and adds it as a <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a> to the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>.</li>
<li>third <a href="#BM_(sequence)%2Fi">sequence</a> to find the one that has the highest match probability to the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> and adds it as a <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a> to the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>.</li>
<li>fourth <a href="#BM_(sequence)%2Fi">sequence</a> to find the one that has the highest match probability to the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> and adds it as a <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a> to the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>.</li>
<li>...</li>
</ol>
<p>This process repeats once for every <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> in the first <a href="#BM_(sequence)%2Fi">sequence</a>. Each repetition produces a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>. Of all the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrices</a> built, the one with the lowest score is selected.</p>
<p>This is a <a href="#BM_(greedy%20algorithm)%2Fi">greedy algorithm</a>. It builds out potential <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrices</a> by selecting the locally optimal <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> from each <a href="#BM_(sequence)%2Fi">sequence</a>. While this may not lead to the globally optimal <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>, it's fast and has a higher than normal likelihood of picking out the correct <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">greedy_motif_search_with_psuedocounts</span>(<span class="hljs-params">k: int, dnas: List[str]</span>):</span>
    best_motif_matrix = [dna[<span class="hljs-number">0</span>:k] <span class="hljs-keyword">for</span> dna <span class="hljs-keyword">in</span> dnas]

    <span class="hljs-keyword">for</span> motif, _ <span class="hljs-keyword">in</span> slide_window(dnas[<span class="hljs-number">0</span>], k):
        motif_matrix = [motif]
        counts = motif_matrix_count(motif_matrix)
        apply_psuedocounts_to_count_matrix(counts)
        profile = motif_matrix_profile(counts)

        <span class="hljs-keyword">for</span> dna <span class="hljs-keyword">in</span> dnas[<span class="hljs-number">1</span>:]:
            next_motif, _ = find_most_probable_kmer_using_profile_matrix(profile, dna)
            <span class="hljs-comment"># push in closest kmer as a motif member and recompute profile for the next iteration</span>
            motif_matrix.append(next_motif)
            counts = motif_matrix_count(motif_matrix)
            apply_psuedocounts_to_count_matrix(counts)
            profile = motif_matrix_profile(counts)

        <span class="hljs-keyword">if</span> score_motif(motif_matrix) &lt; score_motif(best_motif_matrix):
            best_motif_matrix = motif_matrix

    <span class="hljs-keyword">return</span> best_motif_matrix</code></pre><div style="border:1px solid black;">
<p></p>
<p>Searching for motif of k=3 in the following...</p>
<p>AAATTGACGCAT<br>GACGACCACGTT<br>CGTCAGCGCCTG<br>GCTGAGCACCGG<br>AGTTCGGGACAG</p>
<p>Found the motif matrix...</p>
<p>GAC<br>GAC<br>GTC<br>GAG<br>GAC</p>
</div>
<p></p>
<a name="H_Randomized%20Algorithm"></a><h4>Randomized Algorithm</h4>
<p><a name="BM_(Algorithms%5C%2FMotif%2FFind%20Motif%20Matrix%2FRandomized%20Algorithm)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FMotif%20Matrix%20Score)_TOPIC%2F">Algorithms/Motif/Motif Matrix Score</a></li>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FMotif%20Matrix%20Profile)_TOPIC%2F">Algorithms/Motif/Motif Matrix Profile</a></li>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FK-mer%20Match%20Probability)_TOPIC%2F">Algorithms/Motif/K-mer Match Probability</a></li>
</ul>
</div>
<p><strong>ALGORITHM</strong>:</p>
<p>This algorithm selects a random <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> from each <a href="#BM_(sequence)%2Fi">sequence</a> to form an initial <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>. Then, for each <a href="#BM_(sequence)%2Fi">sequence</a>, it finds the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> that has the highest probability of matching that <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>. Those <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s form the <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a>s of a new <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>. If the new <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> scores better than the existing <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>, the existing <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> gets replaced with the new <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> and the process repeats. Otherwise, the existing <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> is selected.</p>
<p>In theory, this algorithm works because all <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s in a <a href="#BM_(sequence)%2Fi">sequence</a> other than the <a href="#BM_(motif%20member)%2Fi">motif member</a> are considered to be random noise. As such, if no <a href="#BM_(motif%20member)%2Fi">motif member</a>s were selected when creating the initial <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>, the profile of that initial <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> would be more or less uniform:</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>0.25</td>
<td>0.25</td>
<td>0.25</td>
<td>0.25</td>
<td>0.25</td>
<td>0.25</td>
</tr>
<tr>
<td>C</td>
<td>0.25</td>
<td>0.25</td>
<td>0.25</td>
<td>0.25</td>
<td>0.25</td>
<td>0.25</td>
</tr>
<tr>
<td>T</td>
<td>0.25</td>
<td>0.25</td>
<td>0.25</td>
<td>0.25</td>
<td>0.25</td>
<td>0.25</td>
</tr>
<tr>
<td>G</td>
<td>0.25</td>
<td>0.25</td>
<td>0.25</td>
<td>0.25</td>
<td>0.25</td>
<td>0.25</td>
</tr>
</tbody>
</table>
<p>Such a profile wouldn't allow for converging to a vastly better scoring <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>.</p>
<p>However, if at least one <a href="#BM_(motif%20member)%2Fi">motif member</a> were selected when creating the initial <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>, the profile of that initial <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> would skew towards the <a href="#BM_(motif)%2Fi">motif</a>:</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td><strong>0.333</strong></td>
<td>0.233</td>
<td>0.233</td>
<td>0.233</td>
<td><strong>0.333</strong></td>
<td>0.233</td>
</tr>
<tr>
<td>C</td>
<td>0.233</td>
<td>0.233</td>
<td><strong>0.333</strong></td>
<td><strong>0.333</strong></td>
<td>0.233</td>
<td><strong>0.333</strong></td>
</tr>
<tr>
<td>T</td>
<td>0.233</td>
<td><strong>0.333</strong></td>
<td>0.233</td>
<td>0.233</td>
<td>0.233</td>
<td>0.233</td>
</tr>
<tr>
<td>G</td>
<td>0.233</td>
<td>0.233</td>
<td>0.233</td>
<td>0.233</td>
<td>0.233</td>
<td>0.233</td>
</tr>
</tbody>
</table>
<p>Such a profile would lead to a better scoring <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> where that better scoring <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> contains the other <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a>s of the <a href="#BM_(motif)%2Fi">motif</a>.</p>
<p>In practice, this algorithm may trip up on real-world data. Real-world <a href="#BM_(sequence)%2Fi">sequence</a>s don't actually contain random noise. The hope is that the only <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s that are highly similar to each other in the <a href="#BM_(sequence)%2Fi">sequence</a>s are <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a>s of the <a href="#BM_(motif)%2Fi">motif</a>. It's possible that the <a href="#BM_(sequence)%2Fi">sequence</a>s contain other sets of <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s that are similar to each other but vastly different than the <a href="#BM_(motif%20member)%2Fi">motif member</a>s. In such cases, even if a <a href="#BM_(motif%20member)%2Fi">motif member</a> were to be selected when creating the initial <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>, the algorithm may converge to a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> that isn't for the <a href="#BM_(motif)%2Fi">motif</a>.</p>
<p>This is a <a href="#BM_(Monte%20Carlo%20algorithm)%2Fi">monte carlo algorithm</a>. It uses randomness to deliver an approximate solution. While this may not lead to the globally optimal <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>, it's fast and as such can be run multiple times. The run with the best <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> will likely be a good enough solution (it captures most of the <a href="#BM_(motif%20member)%2Fi">motif member</a>s, or parts of the <a href="#BM_(motif%20member)%2Fi">motif member</a>s if k was too small, or etc..).</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">randomized_motif_search_with_psuedocounts</span>(<span class="hljs-params">k: int, dnas: List[str]</span>) -&gt; List[str]:</span>
        motif_matrix = []
        <span class="hljs-keyword">for</span> dna <span class="hljs-keyword">in</span> dnas:
            start = randrange(len(dna) - k + <span class="hljs-number">1</span>)
            kmer = dna[start:start + k]
            motif_matrix.append(kmer)

        best_motif_matrix = motif_matrix

        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
            counts = motif_matrix_count(motif_matrix)
            apply_psuedocounts_to_count_matrix(counts)
            profile = motif_matrix_profile(counts)

            motif_matrix = [find_most_probable_kmer_using_profile_matrix(profile, dna)[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> dna <span class="hljs-keyword">in</span> dnas]
            <span class="hljs-keyword">if</span> score_motif(motif_matrix) &lt; score_motif(best_motif_matrix):
                best_motif_matrix = motif_matrix
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">return</span> best_motif_matrix</code></pre><div style="border:1px solid black;">
<p></p>
<p>Searching for motif of k=3 in the following...</p>
<p>AAATTGACGCAT<br>GACGACCACGTT<br>CGTCAGCGCCTG<br>GCTGAGCACCGG<br>AGTTCGGGACAG</p>
<p>Running 1000 iterations...</p>
<p>Best found the motif matrix...</p>
<p>GAC<br>GAC<br>GTC<br>GAG<br>GAC</p>
</div>
<p></p>
<a name="H_Gibbs%20Sampling%20Algorithm"></a><h4>Gibbs Sampling Algorithm</h4>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FMotif%20Matrix%20Score)_TOPIC%2F">Algorithms/Motif/Motif Matrix Score</a></li>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FK-mer%20Match%20Probability)_TOPIC%2F">Algorithms/Motif/K-mer Match Probability</a></li>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FFind%20Motif%20Matrix%2FRandomized%20Algorithm)_TOPIC%2F">Algorithms/Motif/Find Motif Matrix/Randomized Algorithm</a></li>
</ul>
</div>
<p><strong>ALGORITHM</strong>:</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The Pevzner book mentions there's more to Gibbs Sampling than what it discussed. I looked up the topic but couldn't make much sense of it.</p>
</div>
<p>This algorithm selects a random <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> from each <a href="#BM_(sequence)%2Fi">sequence</a> to form an initial <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>. Then, one of the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s from the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> is randomly chosen and replaced with another <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> from the same <a href="#BM_(sequence)%2Fi">sequence</a> that the removed <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> came from. The replacement is selected by using a weighted random number algorithm, where how likely a <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> is to be chosen as a replacement has to do with how probable of a match it is to the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>.</p>
<p>This process of replacement is repeated for some user-defined number of cycles, at which point the algorithm has hopefully homed in on the desired <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>.</p>
<p>This is a <a href="#BM_(Monte%20Carlo%20algorithm)%2Fi">monte carlo algorithm</a>. It uses randomness to deliver an approximate solution. While this may not lead to the globally optimal <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>, it's fast and as such can be run multiple times. The run with the best <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> will likely be a good enough solution (it captures most of the <a href="#BM_(motif%20member)%2Fi">motif member</a>s, or parts of the <a href="#BM_(motif%20member)%2Fi">motif member</a>s if k was too small, or etc..).</p>
<p>The idea behind this algorithm is similar to the idea behind the <a href="#BM_(randomized%20algorithm)%2Fi">randomized algorithm</a> for <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> finding, except that this algorithm is more conservative in how it converges on a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> and the weighted random selection allows it to potentially break out if stuck in a local optima.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gibbs_rand</span>(<span class="hljs-params">prob_dist: List[float]</span>) -&gt; int:</span>
    <span class="hljs-comment"># normalize prob_dist -- just incase sum(prob_dist) != 1.0</span>
    prob_dist_sum = sum(prob_dist)
    prob_dist = [p / prob_dist_sum <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> prob_dist]

    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        selection = randrange(<span class="hljs-number">0</span>, len(prob_dist))
        <span class="hljs-keyword">if</span> random() &lt; prob_dist[selection]:
            <span class="hljs-keyword">return</span> selection


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">determine_probabilities_of_all_kmers_in_dna</span>(<span class="hljs-params">profile_matrix: Dict[str, List[float]], dna: str, k: int</span>) -&gt; List[int]:</span>
    ret = []
    <span class="hljs-keyword">for</span> kmer, _ <span class="hljs-keyword">in</span> slide_window(dna, k):
        prob = determine_probability_of_match_using_profile_matrix(profile_matrix, kmer)
        ret.append(prob)
    <span class="hljs-keyword">return</span> ret


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gibbs_sampler_motif_search_with_psuedocounts</span>(<span class="hljs-params">k: int, dnas: List[str], cycles: int</span>) -&gt; List[str]:</span>
    motif_matrix = []
    <span class="hljs-keyword">for</span> dna <span class="hljs-keyword">in</span> dnas:
        start = randrange(len(dna) - k + <span class="hljs-number">1</span>)
        kmer = dna[start:start + k]
        motif_matrix.append(kmer)

    best_motif_matrix = motif_matrix[:]  <span class="hljs-comment"># create a copy, otherwise you'll be modifying both motif and best_motif</span>

    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, cycles):
        i = randrange(len(dnas))  <span class="hljs-comment"># pick a dna</span>
        <span class="hljs-keyword">del</span> motif_matrix[i]  <span class="hljs-comment"># remove the kmer for that dna from the motif str</span>

        counts = motif_matrix_count(motif_matrix)
        apply_psuedocounts_to_count_matrix(counts)
        profile = motif_matrix_profile(counts)

        new_motif_kmer_probs = determine_probabilities_of_all_kmers_in_dna(profile, dnas[i], k)
        new_motif_kmer_idx = gibbs_rand(new_motif_kmer_probs)
        new_motif_kmer = dnas[i][new_motif_kmer_idx:new_motif_kmer_idx+k]
        motif_matrix.insert(i, new_motif_kmer)

        <span class="hljs-keyword">if</span> score_motif(motif_matrix) &lt; score_motif(best_motif_matrix):
            best_motif_matrix = motif_matrix[:]  <span class="hljs-comment"># create a copy, otherwise you'll be modifying both motif and best_motif</span>

    <span class="hljs-keyword">return</span> best_motif_matrix</code></pre><div style="border:1px solid black;">
<p></p>
<p>Searching for motif of k=3 in the following...</p>
<p>AAATTGACGCAT<br>GACGACCACGTT<br>CGTCAGCGCCTG<br>GCTGAGCACCGG<br>AGTTCGGGACAG</p>
<p>Running 1000 iterations...</p>
<p>Best found the motif matrix...</p>
<p>GAC<br>GAC<br>GTC<br>CAC<br>GAC</p>
</div>
<p></p>
<a name="H_Motif%20Matrix%20Hybrid%20Alphabet"></a><h3>Motif Matrix Hybrid Alphabet</h3>
<p><a name="BM_(Algorithms%5C%2FMotif%2FMotif%20Matrix%20Hybrid%20Alphabet)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FConsensus%20String)_TOPIC%2F">Algorithms/Motif/Consensus String</a></li>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FMotif%20Matrix%20Score)_TOPIC%2F">Algorithms/Motif/Motif Matrix Score</a></li>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FFind%20Motif%20Matrix)_TOPIC%2F">Algorithms/Motif/Find Motif Matrix</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: When creating finding a <a href="#BM_(motif)%2Fi">motif</a>, it may be beneficial to use a <a href="#BM_(hybrid%20alphabet%7Calternate%20alphabet%7Calternative%20alphabet)%2Fi">hybrid alphabet</a> rather than the standard nucleotides (A, C, T, and G). For example, the following <a href="#BM_(hybrid%20alphabet%7Calternate%20alphabet%7Calternative%20alphabet)%2Fi">hybrid alphabet</a> marks certain combinations of nucleotides as a single letter:</p>
<ul>
<li>A = A</li>
<li>C = C</li>
<li>T = T</li>
<li>G = G</li>
<li>W = A or T</li>
<li>S = G or C</li>
<li>K = G or T</li>
<li>Y = C or T</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The alphabet above was pulled from the Pevzner book section 2.16: Complications in <a href="#BM_(motif)%2Fi">Motif</a> Finding. It's a subset of the <a href="#BM_(IUPAC%20nucleotide%20code)%2Fi">IUPAC nucleotide code</a>s alphabet. The author didn't mention if the alphabet was explicitly chosen for <a href="#BM_(regulatory%20motif)%2Fi">regulatory motif</a> finding. If it was, it may have been derived from running probabilities over already discovered <a href="#BM_(regulatory%20motif)%2Fi">regulatory motif</a>s: e.g. for the <a href="#BM_(motif)%2Fi">motif</a>s already discovered, if a position has 2 possible nucleotides then G/C (S), G/T (K), C/T (Y), and A/T (W) are likely but other combinations aren't.</p>
</div>
<p><strong>WHY</strong>: <a href="#BM_(hybrid%20alphabet%7Calternate%20alphabet%7Calternative%20alphabet)%2Fi">Hybrid alphabet</a>s may make it easier for <a href="#BM_(motif)%2Fi">motif</a> finding algorithms to converge on a <a href="#BM_(motif)%2Fi">motif</a>. For example, when scoring a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>, treat the position as a single letter if the distinct nucleotides at that position map to one of the combinations in the <a href="#BM_(hybrid%20alphabet%7Calternate%20alphabet%7Calternative%20alphabet)%2Fi">hybrid alphabet</a>.</p>
<p><a href="#BM_(hybrid%20alphabet%7Calternate%20alphabet%7Calternative%20alphabet)%2Fi">Hybrid alphabet</a>s may make more sense for representing a <a href="#BM_(consensus%20string%7Cconsensus%20sequence)%2Fi">consensus string</a>. Rather than picking out the most popular nucleotide, the <a href="#BM_(hybrid%20alphabet%7Calternate%20alphabet%7Calternative%20alphabet)%2Fi">hybrid alphabet</a> can be used to describe alternating nucleotides at each position.</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code>PEVZNER_2_16_ALPHABET = dict()
PEVZNER_2_16_ALPHABET[frozenset({<span class="hljs-string">'A'</span>, <span class="hljs-string">'T'</span>})] = <span class="hljs-string">'W'</span>
PEVZNER_2_16_ALPHABET[frozenset({<span class="hljs-string">'G'</span>, <span class="hljs-string">'C'</span>})] = <span class="hljs-string">'S'</span>
PEVZNER_2_16_ALPHABET[frozenset({<span class="hljs-string">'G'</span>, <span class="hljs-string">'T'</span>})] = <span class="hljs-string">'K'</span>
PEVZNER_2_16_ALPHABET[frozenset({<span class="hljs-string">'C'</span>, <span class="hljs-string">'T'</span>})] = <span class="hljs-string">'Y'</span>


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_hybrid_alphabet_motif_matrix</span>(<span class="hljs-params">motif_matrix: List[str], hybrid_alphabet: Dict[FrozenSet[str], str]</span>) -&gt; List[str]:</span>
    rows = len(motif_matrix)
    cols = len(motif_matrix[<span class="hljs-number">0</span>])

    motif_matrix = motif_matrix[:]  <span class="hljs-comment"># make a copy</span>
    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> range(cols):
        distinct_nucs_at_c = frozenset([motif_matrix[r][c] <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> range(rows)])
        <span class="hljs-keyword">if</span> distinct_nucs_at_c <span class="hljs-keyword">in</span> hybrid_alphabet:
            <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> range(rows):
                motif_member = motif_matrix[r]
                motif_member = motif_member[:c] + hybrid_alphabet[distinct_nucs_at_c] + motif_member[c+<span class="hljs-number">1</span>:]
                motif_matrix[r] = motif_member

    <span class="hljs-keyword">return</span> motif_matrix</code></pre><div style="border:1px solid black;">
<p></p>
<p>Converted...</p>
<p>CATCCG<br>CTTCCT<br>CATCTT</p>
<p>to...</p>
<p>CWTCYK<br>CWTCYK<br>CWTCYK</p>
<p>using...</p>
<p>{frozenset({'T', 'A'}): 'W', frozenset({'G', 'C'}): 'S', frozenset({'G', 'T'}): 'K', frozenset({'C', 'T'}): 'Y'}</p>
</div>
<p></p>
<a name="H_Assembly"></a><h2>Assembly</h2>
<p><a name="BM_(Algorithms%5C%2FAssembly)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FK-mer)_TOPIC%2F">Algorithms/K-mer</a></li>
</ul>
</div>
<p>DNA <a href="#BM_(sequencer)%2Fi">sequencer</a>s work by taking many copies of an organism's <a href="#BM_(genome)%2Fi">genome</a>, breaking up those copies into fragments, then scanning in those fragments. <a href="#BM_(sequencer)%2Fi">Sequencer</a>s typically scan fragments in 1 of 2 ways:</p>
<ul>
<li>
<p><a href="#BM_%5Cb(read)_SEQ%2Fi">read</a>s - small DNA fragments of equal size (represented as <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s).</p>
<p><img src="svgbob_0466ab6a6dc49c17c2bac89fed628823f1b8d580.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a>s - small DNA fragments of equal size where the bases in the middle part of the fragment aren't known (represented as <a href="#BM_(%5C(%5Cd%2B%2C%5Cs*%5Cd%2B%5C)-mer%7Ckd-mer%7Ckdmer%7C%5C(k%2C%5Cs*d%5C)-mer)%2Fi">kd-mer</a>s).</p>
<p><img src="svgbob_246ba3d13372ae267d9a596e030d11d7550b036b.svg" alt="Kroki diagram output"></p>
</li>
</ul>
<p><a href="#BM_(assembly%7Cassemble)%2Fi">Assembly</a> is the process of reconstructing an organism's <a href="#BM_(genome)%2Fi">genome</a> from the <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s returned by a <a href="#BM_(sequencer)%2Fi">sequencer</a>. Since the <a href="#BM_(sequencer)%2Fi">sequencer</a> breaks up many copies of the same <a href="#BM_(genome)%2Fi">genome</a> and each <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>'s start position is random, the original <a href="#BM_(genome)%2Fi">genome</a> can be reconstructed by finding overlaps between <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s and stitching them back together.</p>
<p><img src="svgbob_c14e6c546e8e4369db69bd39a7c6e934e7ddefe7.svg" alt="Kroki diagram output"></p>
<p>A typical problem with <a href="#BM_(sequencing%7Csequenced)%2Fi">sequencing</a> is that the number of errors in a <a href="#BM_(fragment)_SEQ%2Fi">fragment</a> increase as the number of scanned bases increases. As such, <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a>s are preferred over <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a>s: by only scanning in the head and tail of a long <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>, the scan won't contain as many errors as a <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> of the same length but will still contain extra information which helps with <a href="#BM_(assembly%7Cassemble)%2Fi">assembly</a> (length of unknown nucleotides in between the prefix and suffix).</p>
<p><a href="#BM_(assembly%7Cassemble)%2Fi">Assembly</a> has many practical complications that prevent full <a href="#BM_(genome)%2Fi">genome</a> reconstruction from <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s:</p>
<ul>
<li>
<p>Which strand of <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA)%2Fi">double stranded DNA</a> that a <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> / <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a> comes from isn't known, which means the overlaps you find may not be accurate.</p>
<p><img src="svgbob_9a1e8981d7c6da721c87d87057f266ca1aeee3d2.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p>The <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s may not cover the entire <a href="#BM_(genome)%2Fi">genome</a>, which prevents full reconstruction.</p>
<p><img src="svgbob_b6294ec3ffaf661c338522ed9985ae78672bd1a0.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p>The <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s may have errors (e.g. wrong nucleotides scanned in), which may prevent finding overlaps.</p>
<p><img src="svgbob_919ae750094a4b11c00506ce3dd45a1c3c6f97af.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p>The <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s for repetitive parts of the <a href="#BM_(genome)%2Fi">genome</a> (e.g. <a href="#BM_(transposon%7Ctransposable%20element%7Cjumping%20gene)%2Fi">transposon</a>s) likely can't be accurately <a href="#BM_(assembly%7Cassemble)%2Fi">assemble</a>d.</p>
<p><img src="svgbob_b6caa3257c0c8b7d997763ca20474e872861ae48.svg" alt="Kroki diagram output"></p>
</li>
</ul>
<a name="H_Stitch%20Reads"></a><h3>Stitch Reads</h3>
<p><a name="BM_(Algorithms%5C%2FAssembly%2FStitch%20Reads)_TOPIC%2F"></a><strong></strong></p>
<p><strong>WHAT</strong>: Given a list of overlapping <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a>s where ...</p>
<ul>
<li>all <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a>s are of the same k,</li>
<li>all overlap regions are of the same length,</li>
<li>and each <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> in the list overlaps with the next <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> in the list</li>
</ul>
<p>... , stitch them together. For example, in the <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> list [GAAA, AAAT, AATC] each <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> overlaps the subsequent <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> by an offset of 1: GAAATC.</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>R1</td>
<td>G</td>
<td>A</td>
<td>A</td>
<td>A</td>
<td></td>
<td></td>
</tr>
<tr>
<td>R2</td>
<td></td>
<td>A</td>
<td>A</td>
<td>A</td>
<td>T</td>
<td></td>
</tr>
<tr>
<td>R3</td>
<td></td>
<td></td>
<td>A</td>
<td>A</td>
<td>T</td>
<td>C</td>
</tr>
<tr>
<td>Stitched</td>
<td>G</td>
<td>A</td>
<td>A</td>
<td>A</td>
<td>T</td>
<td>C</td>
</tr>
</tbody>
</table>
<p><strong>WHY</strong>: Since the <a href="#BM_(sequencer)%2Fi">sequencer</a> breaks up many copies of the same DNA and each <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a>'s start position is random, larger parts of the original DNA can be reconstructed by finding overlaps between <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s and stitching them back together.</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">append_overlap</span>(<span class="hljs-params">self: Read, other: Read, skip: int = <span class="hljs-number">1</span></span>) -&gt; Read:</span>
    offset = len(self.data) - len(other.data)
    data_head = self.data[:offset]
    data = self.data[offset:]

    prefix = data[:skip]
    overlap1 = data[skip:]
    overlap2 = other.data[:-skip]
    suffix = other.data[-skip:]
    ret = data_head + prefix
    <span class="hljs-keyword">for</span> ch1, ch2 <span class="hljs-keyword">in</span> zip(overlap1, overlap2):
        ret += ch1 <span class="hljs-keyword">if</span> ch1 == ch2 <span class="hljs-keyword">else</span> <span class="hljs-string">'?'</span>  <span class="hljs-comment"># for failure, use IUPAC nucleotide codes instead of question mark?</span>
    ret += suffix
    <span class="hljs-keyword">return</span> Read(ret, source=(<span class="hljs-string">'overlap'</span>, [self, other]))

<span class="hljs-meta">@staticmethod</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stitch</span>(<span class="hljs-params">items: List[Read], skip: int = <span class="hljs-number">1</span></span>) -&gt; str:</span>
    <span class="hljs-keyword">assert</span> len(items) &gt; <span class="hljs-number">0</span>
    ret = items[<span class="hljs-number">0</span>]
    <span class="hljs-keyword">for</span> other <span class="hljs-keyword">in</span> items[<span class="hljs-number">1</span>:]:
        ret = ret.append_overlap(other, skip)
    <span class="hljs-keyword">return</span> ret.data</code></pre><div style="border:1px solid black;">
<p></p>
<p>Stitched [GAAA, AAAT, AATC] to GAAATC</p>
</div>
<p></p>
<a name="H_Stitch%20Read-Pairs"></a><h3>Stitch Read-Pairs</h3>
<p><a name="BM_(Algorithms%5C%2FAssembly%2FStitch%20Read-Pairs)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FStitch%20Reads)_TOPIC%2F">Algorithms/Assembly/Stitch Reads</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given a list of overlapping <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a>s where ...</p>
<ul>
<li>all <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a>s are of the same k and d,</li>
<li>all overlap regions are of the same length,</li>
<li>and each <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a> in the list overlaps with the next <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a> in the list</li>
</ul>
<p>... , stitch them together. For example, in the <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a> list [ATG---CCG, TGT---CGT, GTT---GTT, TTA---TTC] each <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a> overlaps the subsequent <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a> by an offset of 1: ATGTTACCGTTC.</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
</tr>
</thead>
<tbody>
<tr>
<td>R1</td>
<td>A</td>
<td>T</td>
<td>G</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>C</td>
<td>C</td>
<td>G</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>R2</td>
<td></td>
<td>T</td>
<td>G</td>
<td>T</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>C</td>
<td>G</td>
<td>T</td>
<td></td>
<td></td>
</tr>
<tr>
<td>R3</td>
<td></td>
<td></td>
<td>G</td>
<td>T</td>
<td>T</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>G</td>
<td>T</td>
<td>T</td>
<td></td>
</tr>
<tr>
<td>R4</td>
<td></td>
<td></td>
<td></td>
<td>T</td>
<td>T</td>
<td>A</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>T</td>
<td>T</td>
<td>C</td>
</tr>
<tr>
<td>Stitched</td>
<td>A</td>
<td>T</td>
<td>G</td>
<td>T</td>
<td>T</td>
<td>A</td>
<td>C</td>
<td>C</td>
<td>G</td>
<td>T</td>
<td>T</td>
<td>C</td>
</tr>
</tbody>
</table>
<p><strong>WHY</strong>: Since the <a href="#BM_(sequencer)%2Fi">sequencer</a> breaks up many copies of the same DNA and each <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a>'s start position is random, larger parts of the original DNA can be reconstructed by finding overlaps between <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s and stitching them back together.</p>
<p><strong>ALGORITHM</strong>:</p>
<p>Overlapping <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a>s are stitched by taking the first <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a> and iterating through the remaining <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a>s where ...</p>
<ul>
<li>the suffix from each remaining <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a>'s head k is appended to the first <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a>'s head k.</li>
<li>the suffix from each remaining <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a>'s tail k is appended to the first <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a>'s tail k.</li>
</ul>
<p>For example, to stitch [ATG---CCG, TGT---CGT], ...</p>
<ol>
<li>stitch the heads as if they were <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a>s: [ATG, TGT] results in ATGT,</li>
<li>stitch the tails as if they were <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a>s: [CCG, CGT] results in CCGT.</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td>R1</td>
<td>A</td>
<td>T</td>
<td>G</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>C</td>
<td>C</td>
<td>G</td>
<td></td>
</tr>
<tr>
<td>R2</td>
<td></td>
<td>T</td>
<td>G</td>
<td>T</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>C</td>
<td>G</td>
<td>T</td>
</tr>
<tr>
<td>Stitched</td>
<td>A</td>
<td>T</td>
<td>G</td>
<td>T</td>
<td>-</td>
<td>-</td>
<td>C</td>
<td>C</td>
<td>G</td>
<td>T</td>
</tr>
</tbody>
</table>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">append_overlap</span>(<span class="hljs-params">self: ReadPair, other: ReadPair, skip: int = <span class="hljs-number">1</span></span>) -&gt; ReadPair:</span>
    self_head = Read(self.data.head)
    other_head = Read(other.data.head)
    new_head = self_head.append_overlap(other_head)
    new_head = new_head.data

    self_tail = Read(self.data.tail)
    other_tail = Read(other.data.tail)
    new_tail = self_tail.append_overlap(other_tail)
    new_tail = new_tail.data

    <span class="hljs-comment"># WARNING: new_d may go negative -- In the event of a negative d, it means that rather than there being a gap</span>
    <span class="hljs-comment"># in between the head and tail, there's an OVERLAP in between the head and tail. To get rid of the overlap, you</span>
    <span class="hljs-comment"># need to remove either the last d chars from head or first d chars from tail.</span>
    new_d = self.d - skip
    kdmer = Kdmer(new_head, new_tail, new_d)

    <span class="hljs-keyword">return</span> ReadPair(kdmer, source=(<span class="hljs-string">'overlap'</span>, [self, other]))

<span class="hljs-meta">@staticmethod</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stitch</span>(<span class="hljs-params">items: List[ReadPair], skip: int = <span class="hljs-number">1</span></span>) -&gt; str:</span>
    <span class="hljs-keyword">assert</span> len(items) &gt; <span class="hljs-number">0</span>
    ret = items[<span class="hljs-number">0</span>]
    <span class="hljs-keyword">for</span> other <span class="hljs-keyword">in</span> items[<span class="hljs-number">1</span>:]:
        ret = ret.append_overlap(other, skip)
    <span class="hljs-keyword">assert</span> ret.d &lt;= <span class="hljs-number">0</span>, <span class="hljs-string">"Gap still exists -- not enough to stitch"</span>
    overlap_count = -ret.d
    <span class="hljs-keyword">return</span> ret.data.head + ret.data.tail[overlap_count:]</code></pre><div style="border:1px solid black;">
<p></p>
<p>Stitched [ATG---CCG, TGT---CGT, GTT---GTT, TTA---TTC] to ATGTTACCGTTC</p>
</div>
<p></p>
<a name="H_Break%20Reads"></a><h3>Break Reads</h3>
<p><a name="BM_(Algorithms%5C%2FAssembly%2FBreak%20Reads)_TOPIC%2F"></a><strong></strong></p>
<p><strong>WHAT</strong>: Given a set of <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a>s that arbitrarily overlap, each <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> can be broken into many smaller <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a>s that overlap better. For example, given 4 <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">10-mer</a>s that arbitrarily overlap, you can break them into better overlapping <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">5-mer</a>s...</p>
<p><img src="svgbob_d9e103b16312cfe660d19df9305a9361ac1241ac.svg" alt="Kroki diagram output"></p>
<p><strong>WHY</strong>: <a href="#BM_(read%20breaking%7Cread-breaking%7Cbreaking%20reads)%2Fi">Breaking reads</a> may cause more ambiguity in overlaps. At the same time, <a href="#BM_(read%20breaking%7Cread-breaking%7Cbreaking%20reads)%2Fi">read breaking</a> makes it easier to find overlaps by bringing the overlaps closer together and provides (artificially) increased <a href="#BM_(coverage)_SEQ%2Fi">coverage</a>.</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-comment"># This is read breaking -- why not just call it break? because break is a reserved keyword.</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">shatter</span>(<span class="hljs-params">self: Read, k: int</span>) -&gt; List[Read]:</span>
    ret = []
    <span class="hljs-keyword">for</span> kmer, _ <span class="hljs-keyword">in</span> slide_window(self.data, k):
        r = Read(kmer, source=(<span class="hljs-string">'shatter'</span>, [self]))
        ret.append(r)
    <span class="hljs-keyword">return</span> ret</code></pre><div style="border:1px solid black;">
<p></p>
<p>Broke ACTAAGAACC to [ACTAA, CTAAG, TAAGA, AAGAA, AGAAC, GAACC]</p>
</div>
<p></p>
<a name="H_Break%20Read-Pairs"></a><h3>Break Read-Pairs</h3>
<p><a name="BM_(Algorithms%5C%2FAssembly%2FBreak%20Read-Pairs)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FBreak%20Reads)_TOPIC%2F">Algorithms/Assembly/Break Reads</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given a set of <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a>s that arbitrarily overlap, each <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a> can be broken into many <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a>s with a smaller k that overlap better. For example, given 4 <a href="#BM_(%5C(%5Cd%2B%2C%5Cs*%5Cd%2B%5C)-mer%7Ckd-mer%7Ckdmer%7C%5C(k%2C%5Cs*d%5C)-mer)%2Fi">(4,2)-mer</a>s that arbitrarily overlap, you can break them into better overlapping <a href="#BM_(%5C(%5Cd%2B%2C%5Cs*%5Cd%2B%5C)-mer%7Ckd-mer%7Ckdmer%7C%5C(k%2C%5Cs*d%5C)-mer)%2Fi">(2,4)-mer</a>s...</p>
<p><img src="svgbob_eb8f1251b4e293a9662ade2c0a4452a7c7884f2f.svg" alt="Kroki diagram output"></p>
<p><strong>WHY</strong>: <a href="#BM_(read-pair%20breaking%7Cread%20pair%20breaking%7Cbreaking%20read-pairs%7Cbreaking%20read%20pairs)%2Fi">Breaking read-pairs</a> may cause more ambiguity in overlaps. At the same time, <a href="#BM_(read-pair%20breaking%7Cread%20pair%20breaking%7Cbreaking%20read-pairs%7Cbreaking%20read%20pairs)%2Fi">read-pair breaking</a> makes it easier to find overlaps by bringing the overlaps closer together and provides (artificially) increased <a href="#BM_(coverage)_SEQ%2Fi">coverage</a>.</p>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-comment"># This is read breaking -- why not just call it break? because break is a reserved keyword.</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">shatter</span>(<span class="hljs-params">self: ReadPair, k: int</span>) -&gt; List[ReadPair]:</span>
    ret = []
    d = (self.k - k) + self.d
    <span class="hljs-keyword">for</span> window_head, window_tail <span class="hljs-keyword">in</span> zip(slide_window(self.data.head, k), slide_window(self.data.tail, k)):
        kmer_head, _ = window_head
        kmer_tail, _ = window_tail
        kdmer = Kdmer(kmer_head, kmer_tail, d)
        rp = ReadPair(kdmer, source=(<span class="hljs-string">'shatter'</span>, [self]))
        ret.append(rp)
    <span class="hljs-keyword">return</span> ret</code></pre><div style="border:1px solid black;">
<p></p>
<p>Broke ACTA--AACC to [AC----AA, CT----AC, TA----CC]</p>
</div>
<p></p>
<a name="H_Probability%20of%20Fragment%20Occurrence"></a><h3>Probability of Fragment Occurrence</h3>
<p><a name="BM_(Algorithms%5C%2FAssembly%2FProbability%20of%20Fragment%20Occurrence)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FStitch%20Reads)_TOPIC%2F">Algorithms/Assembly/Stitch Reads</a></li>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FStitch%20Read-Pairs)_TOPIC%2F">Algorithms/Assembly/Stitch Read-Pairs</a></li>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FBreak%20Reads)_TOPIC%2F">Algorithms/Assembly/Break Reads</a></li>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FBreak%20Read-Pairs)_TOPIC%2F">Algorithms/Assembly/Break Read-Pairs</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: <a href="#BM_(sequencer)%2Fi">Sequencer</a>s work by taking many copies of an organism's <a href="#BM_(genome)%2Fi">genome</a>, randomly breaking up those <a href="#BM_(genome)%2Fi">genome</a>s into smaller pieces, and randomly scanning in those pieces (<a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s). As such, it isn't immediately obvious how many times each <a href="#BM_(fragment)_SEQ%2Fi">fragment</a> actually appears in the <a href="#BM_(genome)%2Fi">genome</a>.</p>
<p>Imagine that you're <a href="#BM_(sequencing%7Csequenced)%2Fi">sequencing</a> an organism's <a href="#BM_(genome)%2Fi">genome</a>. Given that ...</p>
<ul>
<li>there's good <a href="#BM_(coverage)_SEQ%2Fi">coverage</a> of the <a href="#BM_(genome)%2Fi">genome</a> (e.g. ~30x as many <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s as the length of the <a href="#BM_(genome)%2Fi">genome</a>),</li>
<li>the <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s scanned in are chosen at random (unbiased),</li>
<li>the <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s scanned in start at random offsets in the <a href="#BM_(genome)%2Fi">genome</a> (unbiased),</li>
<li>and the majority of <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s are for non-repeating parts of the <a href="#BM_(genome)%2Fi">genome</a>.</li>
</ul>
<p>... you can use probabilities to hint at how many times a <a href="#BM_(fragment)_SEQ%2Fi">fragment</a> appears in the <a href="#BM_(genome)%2Fi">genome</a>.</p>
<p><strong>WHY</strong>:</p>
<p>Determining how many times a <a href="#BM_(fragment)_SEQ%2Fi">fragment</a> appears in a <a href="#BM_(genome)%2Fi">genome</a> helps with <a href="#BM_(assembly%7Cassemble)%2Fi">assembly</a>. Specifically, ...</p>
<ul>
<li><a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s for repeat regions of the <a href="#BM_(genome)%2Fi">genome</a> can be accounted for during <a href="#BM_(assembly%7Cassemble)%2Fi">assembly</a>.</li>
<li><a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s containing <a href="#BM_(sequencing%20error)%2Fi">sequencing error</a>s may be detectable and filtered out prior to <a href="#BM_(assembly%7Cassemble)%2Fi">assembly</a>.</li>
</ul>
<p><strong>ALGORITHM</strong>:</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>For simplicity's sake, the <a href="#BM_(genome)%2Fi">genome</a> is single-stranded (not <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA)%2Fi">double-stranded DNA</a> / no reverse complementing stand).</p>
</div>
<p>Imagine a <a href="#BM_(genome)%2Fi">genome</a> of ATGGATGC. A <a href="#BM_(sequencer)%2Fi">sequencer</a> runs over that single strand and generates <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">3-mer</a> <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a>s with roughly 30x <a href="#BM_(coverage)_SEQ%2Fi">coverage</a>. The resulting <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s are ...</p>
<table>
<thead>
<tr>
<th><a href="#BM_%5Cb(read)_SEQ%2Fi">Read</a></th>
<th># of Copies</th>
</tr>
</thead>
<tbody>
<tr>
<td>ATG</td>
<td>61</td>
</tr>
<tr>
<td>TGG</td>
<td>30</td>
</tr>
<tr>
<td>GAT</td>
<td>31</td>
</tr>
<tr>
<td>TGC</td>
<td>29</td>
</tr>
<tr>
<td>TGT</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>Since the <a href="#BM_(genome)%2Fi">genome</a> is known to have less than 50% repeats, the dominate number of copies likely maps to 1 instance of that <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> appearing in the <a href="#BM_(genome)%2Fi">genome</a>. Since the dominate number is ~30, divide the number of copies for each <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> by ~30 to find out roughly how many times each <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> appears in the <a href="#BM_(genome)%2Fi">genome</a> ...</p>
<table>
<thead>
<tr>
<th><a href="#BM_%5Cb(read)_SEQ%2Fi">Read</a></th>
<th># of Copies</th>
<th># of Appearances in <a href="#BM_(genome)%2Fi">Genome</a></th>
</tr>
</thead>
<tbody>
<tr>
<td>ATG</td>
<td>61</td>
<td>2</td>
</tr>
<tr>
<td>TGG</td>
<td>30</td>
<td>1</td>
</tr>
<tr>
<td>GAT</td>
<td>31</td>
<td>1</td>
</tr>
<tr>
<td>TGC</td>
<td>29</td>
<td>1</td>
</tr>
<tr>
<td>TGT</td>
<td>1</td>
<td>0.03</td>
</tr>
</tbody>
</table>
<p>Note the last <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> (TGT) has 0.03 appearances, meaning it's a <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> that it either</p>
<ul>
<li>contains a <a href="#BM_(sequencing%20error)%2Fi">sequencing error</a>,</li>
<li>or it has poor <a href="#BM_(coverage)_SEQ%2Fi">coverage</a> (likely because it's at the head / tail of the <a href="#BM_(genome)%2Fi">genome</a> so it got scanned in less than other <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s).</li>
</ul>
<p>In this case, it's an error because it doesn't appear in the original <a href="#BM_(genome)%2Fi">genome</a>: TGT is not in ATGGATGC.</p>
<pre class="hljs"><code><span class="hljs-comment"># If less than 50% of the reads are from repeats, this attempts to count and normalize such that it can hint at which</span>
<span class="hljs-comment"># reads may contain errors (= ~0) and which reads are for repeat regions (&gt; 1.0).</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calculate_fragment_occurrence_probabilities</span>(<span class="hljs-params">fragments: List[T]</span>) -&gt; Dict[T, float]:</span>
    counter = Counter(fragments)
    max_digit_count = max([len(str(count)) <span class="hljs-keyword">for</span> count <span class="hljs-keyword">in</span> counter.values()])
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(max_digit_count):
        rounded_counter = Counter(dict([(k, round(count, -i)) <span class="hljs-keyword">for</span> k, count <span class="hljs-keyword">in</span> counter.items()]))
        <span class="hljs-keyword">for</span> k, orig_count <span class="hljs-keyword">in</span> counter.items():
            <span class="hljs-keyword">if</span> rounded_counter[k] == <span class="hljs-number">0</span>:
                rounded_counter[k] = orig_count
        most_occurring_count, times_counted = Counter(rounded_counter.values()).most_common(<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]
        <span class="hljs-keyword">if</span> times_counted &gt;= len(rounded_counter) * <span class="hljs-number">0.5</span>:
            <span class="hljs-keyword">return</span> dict([(key, value / most_occurring_count) <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> rounded_counter.items()])
    <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f'Failed to find a common count: <span class="hljs-subst">{counter}</span>'</span>)</code></pre><div style="border:1px solid black;">
<p></p>
<p>Sequenced fragments:</p>
<ul>
<li>ATG was scanned in 61 times.</li>
<li>TGG was scanned in 30 times.</li>
<li>GAT was scanned in 31 times.</li>
<li>TGC was scanned in 29 times.</li>
<li>TGT was scanned in 1 times.</li>
</ul>
<p>Probability of occurrence in genome:</p>
<ul>
<li>ATG probably has 2.0 appearances in the genome.</li>
<li>TGG probably has 1.0 appearances in the genome.</li>
<li>GAT probably has 1.0 appearances in the genome.</li>
<li>TGC probably has 1.0 appearances in the genome.</li>
<li>TGT probably has 0.03333333333333333 appearances in the genome.</li>
</ul>
</div>
<p></p>
<a name="H_Overlap%20Graph"></a><h3>Overlap Graph</h3>
<p><a name="BM_(Algorithms%5C%2FAssembly%2FOverlap%20Graph)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FStitch%20Reads)_TOPIC%2F">Algorithms/Assembly/Stitch Reads</a></li>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FStitch%20Read-Pairs)_TOPIC%2F">Algorithms/Assembly/Stitch Read-Pairs</a></li>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FBreak%20Reads)_TOPIC%2F">Algorithms/Assembly/Break Reads</a></li>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FBreak%20Read-Pairs)_TOPIC%2F">Algorithms/Assembly/Break Read-Pairs</a></li>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FProbability%20of%20Fragment%20Occurrence)_TOPIC%2F">Algorithms/Assembly/Probability of Fragment Occurrence</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given the <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s for a single strand of DNA, create a directed graph where ...</p>
<ol>
<li>
<p>each node is a <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>.</p>
<p><img src="svgbob_ba61508d2d4f3dfef58ce5783f8e22f49ddec891.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p>each edge is between overlapping <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s (nodes), where the ...</p>
<ul>
<li>source node has the overlap in its suffix .</li>
<li>destination node has the overlap in its prefix.</li>
</ul>
<p><img src="svgbob_62843d070e55883049a5a0f4881f1ec17928f780.svg" alt="Kroki diagram output"></p>
</li>
</ol>
<p>This is called an <a href="#BM_(overlap%20graph)%2Fi">overlap graph</a>.</p>
<p><strong>WHY</strong>: An <a href="#BM_(overlap%20graph)%2Fi">overlap graph</a> shows the different ways that <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s can be stitched together. A path in in an <a href="#BM_(overlap%20graph)%2Fi">overlap graph</a> that touches each node exactly once is one possibility for the original <a href="#BM_(single%20stranded%20DNA%7Csingle-stranded%20DNA)%2Fi">single stranded DNA</a> that the <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s came from. For example...</p>
<ul>
<li>[TTA, TAG, AGT, GTT, TTA, TAC, ACT, CTT] ⟶ TTAGTTACTT</li>
<li>[TTA, TAC, ACT, CTT, TTA, TAG, AGT, GTT] ⟶ TTACTTAGTT</li>
<li>[ACT, CTT, TTA, TAG, AGT, GTT, TTA, TAC] ⟶ ACTTAGTTAC</li>
<li>[CTT, TTA, TAG, AGT, GTT, TTA, TAC, ACT] ⟶ CTTAGTTACT</li>
<li>...</li>
</ul>
<p>These paths are referred to as <a href="#BM_(Hamiltonian%20path%7CHamilton%20path)%2Fi">Hamiltonian path</a>s.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Notice that the example graph is circular. If the organism <a href="#BM_(genome)%2Fi">genome</a> itself were also circular (e.g. bacterial <a href="#BM_(genome)%2Fi">genome</a>), the <a href="#BM_(genome)%2Fi">genome</a> guesses above are all actually the same because circular <a href="#BM_(genome)%2Fi">genome</a>s don't have a beginning / end.</p>
</div>
<p><strong>ALGORITHM</strong>:</p>
<p><a href="#BM_(sequencer)%2Fi">Sequencer</a>s produce <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s, but <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s by themselves typically aren't enough for most experiments / algorithms. In theory, stitching overlapping <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s for a single-strand of DNA should reveal that single-strand of DNA. In practice, real-world complications make revealing that single-strand of DNA nearly impossible:</p>
<ul>
<li><a href="#BM_(fragment)_SEQ%2Fi">Fragment</a>s are for both strands (strand of <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA)%2Fi">double-stranded DNA</a> a <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>'s from isn't known).</li>
<li><a href="#BM_(fragment)_SEQ%2Fi">Fragment</a>s may be missing (<a href="#BM_(sequencer)%2Fi">sequencer</a> didn't capture it).</li>
<li><a href="#BM_(fragment)_SEQ%2Fi">Fragment</a>s may have incorrect occurrence counts (<a href="#BM_(sequencer)%2Fi">sequencer</a> captured it too many/few times).</li>
<li><a href="#BM_(fragment)_SEQ%2Fi">Fragment</a>s may have errors (<a href="#BM_(sequencer)%2Fi">sequencer</a> produced <a href="#BM_(sequencing%20error)%2Fi">sequencing error</a>s).</li>
<li><a href="#BM_(fragment)_SEQ%2Fi">Fragment</a>s may be stitch-able in more than one way (multiple guesses).</li>
<li><a href="#BM_(fragment)_SEQ%2Fi">Fragment</a>s may take a long time to stitch (computationally intensive).</li>
</ul>
<p>Never the less, in an ideal world where most of these problems don't exist, an <a href="#BM_(overlap%20graph)%2Fi">overlap graph</a> is a good way to guess the single-strand of DNA that a set of <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s came from. An <a href="#BM_(overlap%20graph)%2Fi">overlap graph</a> assumes that the <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s it's operating on ...</p>
<ul>
<li>are from a single-strand of DNA,</li>
<li>have correct occurrence counts (no missing or extra),</li>
<li>and contain no errors.</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Although the complications discussed above make it impossible to get the original <a href="#BM_(genome)%2Fi">genome</a> in its entirety, it's still possible to pull out large parts of the original <a href="#BM_(genome)%2Fi">genome</a>. This is discussed in <a href="#BM_(Algorithms%5C%2FAssembly%2FFind%20Contigs)_TOPIC%2F">Algorithms/Assembly/Find Contigs</a>.</p>
</div>
<p>To construct an <a href="#BM_(overlap%20graph)%2Fi">overlap graph</a>, create an edge between <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s that have an overlap.</p>
<p>For each <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>, add that <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>'s ...</p>
<ul>
<li>prefix to a hash table.</li>
<li>suffix to a hash table.</li>
</ul>
<p>Then, join the hash tables together to find overlapping <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_overlap_graph</span>(<span class="hljs-params">items: List[T], skip: int = <span class="hljs-number">1</span></span>) -&gt; Graph[T]:</span>
    ret = Graph()

    prefixes = dict()
    suffixes = dict()
    <span class="hljs-keyword">for</span> i, item <span class="hljs-keyword">in</span> enumerate(items):
        prefix = item.prefix(skip)
        prefixes.setdefault(prefix, set()).add(i)
        suffix = item.suffix(skip)
        suffixes.setdefault(suffix, set()).add(i)

    <span class="hljs-keyword">for</span> key, indexes <span class="hljs-keyword">in</span> suffixes.items():
        other_indexes = prefixes.get(key)
        <span class="hljs-keyword">if</span> other_indexes <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">continue</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> indexes:
            item = items[i]
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> other_indexes:
                <span class="hljs-keyword">if</span> i == j:
                    <span class="hljs-keyword">continue</span>
                other_item = items[j]
                ret.insert_edge(item, other_item)
    <span class="hljs-keyword">return</span> ret</code></pre><div style="border:1px solid black;">
<p></p>
<p>Given the fragments ['TTA', 'TTA', 'TAG', 'AGT', 'GTT', 'TAC', 'ACT', 'CTT'], the overlap graph is...</p>
<p><img src="dot_8ca9fb7886e86704dc01b1bffd1d6dd1.svg" alt="Dot diagram"></p>
</div>
<p></p>
<p>A path that touches each node of an graph exactly once is a <a href="#BM_(Hamiltonian%20path%7CHamilton%20path)%2Fi">Hamiltonian path</a>. Each  The <a href="#BM_(Hamiltonian%20path%7CHamilton%20path)%2Fi">Hamiltonian path</a> in an <a href="#BM_(overlap%20graph)%2Fi">overlap graph</a> is a guess as to the original single strand of DNA that the <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s for the graph came from.</p>
<p>The code shown below recursively walks all paths. Of all the paths it walks over, the ones that walk every node of the graph exactly once are selected.</p>
<p>This algorithm will likely fall over on non-trivial <a href="#BM_(overlap%20graph)%2Fi">overlap graph</a>s. Even finding one <a href="#BM_(Hamiltonian%20path%7CHamilton%20path)%2Fi">Hamiltonian path</a> is computationally intensive.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exhaustively_walk_until_all_nodes_touched_exactly_one</span>(<span class="hljs-params">
        graph: Graph[T],
        from_node: T,
        current_path: List[T]
</span>) -&gt; List[List[T]]:</span>
    current_path.append(from_node)

    <span class="hljs-keyword">if</span> len(current_path) == len(graph):
        found_paths = [current_path.copy()]
    <span class="hljs-keyword">else</span>:
        found_paths = []
        <span class="hljs-keyword">for</span> to_node <span class="hljs-keyword">in</span> graph.get_outputs(from_node):
            <span class="hljs-keyword">if</span> to_node <span class="hljs-keyword">in</span> set(current_path):
                <span class="hljs-keyword">continue</span>
            found_paths += exhaustively_walk_until_all_nodes_touched_exactly_one(graph, to_node, current_path)

    current_path.pop()
    <span class="hljs-keyword">return</span> found_paths


<span class="hljs-comment"># walk each node exactly once</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">walk_hamiltonian_paths</span>(<span class="hljs-params">graph: Graph[T], from_node: T</span>) -&gt; List[List[T]]:</span>
    <span class="hljs-keyword">return</span> exhaustively_walk_until_all_nodes_touched_exactly_one(graph, from_node, [])</code></pre><div style="border:1px solid black;">
<p></p>
<p>Given the fragments ['TTA', 'TTA', 'TAG', 'AGT', 'GTT', 'TAC', 'ACT', 'CTT'], the overlap graph is...</p>
<p><img src="dot_8ca9fb7886e86704dc01b1bffd1d6dd1.svg" alt="Dot diagram"></p>
<p>... and the Hamiltonian paths are ...</p>
<ul>
<li>TAG -&gt; AGT -&gt; GTT -&gt; TTA -&gt; TAC -&gt; ACT -&gt; CTT -&gt; TTA</li>
<li>TAC -&gt; ACT -&gt; CTT -&gt; TTA -&gt; TAG -&gt; AGT -&gt; GTT -&gt; TTA</li>
<li>AGT -&gt; GTT -&gt; TTA -&gt; TAC -&gt; ACT -&gt; CTT -&gt; TTA -&gt; TAG</li>
<li>CTT -&gt; TTA -&gt; TAG -&gt; AGT -&gt; GTT -&gt; TTA -&gt; TAC -&gt; ACT</li>
<li>ACT -&gt; CTT -&gt; TTA -&gt; TAG -&gt; AGT -&gt; GTT -&gt; TTA -&gt; TAC</li>
<li>GTT -&gt; TTA -&gt; TAC -&gt; ACT -&gt; CTT -&gt; TTA -&gt; TAG -&gt; AGT</li>
<li>TTA -&gt; TAG -&gt; AGT -&gt; GTT -&gt; TTA -&gt; TAC -&gt; ACT -&gt; CTT</li>
<li>TAG -&gt; AGT -&gt; GTT -&gt; TTA -&gt; TAC -&gt; ACT -&gt; CTT -&gt; TTA</li>
<li>TAC -&gt; ACT -&gt; CTT -&gt; TTA -&gt; TAG -&gt; AGT -&gt; GTT -&gt; TTA</li>
<li>TTA -&gt; TAC -&gt; ACT -&gt; CTT -&gt; TTA -&gt; TAG -&gt; AGT -&gt; GTT</li>
<li>GTT -&gt; TTA -&gt; TAC -&gt; ACT -&gt; CTT -&gt; TTA -&gt; TAG -&gt; AGT</li>
<li>CTT -&gt; TTA -&gt; TAG -&gt; AGT -&gt; GTT -&gt; TTA -&gt; TAC -&gt; ACT</li>
<li>ACT -&gt; CTT -&gt; TTA -&gt; TAG -&gt; AGT -&gt; GTT -&gt; TTA -&gt; TAC</li>
<li>TTA -&gt; TAG -&gt; AGT -&gt; GTT -&gt; TTA -&gt; TAC -&gt; ACT -&gt; CTT</li>
<li>AGT -&gt; GTT -&gt; TTA -&gt; TAC -&gt; ACT -&gt; CTT -&gt; TTA -&gt; TAG</li>
<li>TTA -&gt; TAC -&gt; ACT -&gt; CTT -&gt; TTA -&gt; TAG -&gt; AGT -&gt; GTT</li>
</ul>
</div>
<p></p>
<a name="H_De%20Bruijn%20Graph"></a><h3>De Bruijn Graph</h3>
<p><a name="BM_(Algorithms%5C%2FAssembly%2FDe%20Bruijn%20Graph)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FStitch%20Reads)_TOPIC%2F">Algorithms/Assembly/Stitch Reads</a></li>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FStitch%20Read-Pairs)_TOPIC%2F">Algorithms/Assembly/Stitch Read-Pairs</a></li>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FBreak%20Reads)_TOPIC%2F">Algorithms/Assembly/Break Reads</a></li>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FBreak%20Read-Pairs)_TOPIC%2F">Algorithms/Assembly/Break Read-Pairs</a></li>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FProbability%20of%20Fragment%20Occurrence)_TOPIC%2F">Algorithms/Assembly/Probability of Fragment Occurrence</a></li>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FOverlap%20Graph)_TOPIC%2F">Algorithms/Assembly/Overlap Graph</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given the <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s for a single strand of DNA, create a directed graph where ...</p>
<ol>
<li>
<p>each <a href="#BM_(fragment)_SEQ%2Fi">fragment</a> is represented as an edge connecting 2 nodes, where the ...</p>
<ul>
<li>source node is the prefix of the <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>.</li>
<li>destination node is the suffix of the <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>.</li>
</ul>
<p><img src="svgbob_843b8aaedb289d3d3ad5aef2fcd9bf5a504ad5af.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p>duplicate nodes are merged into a single node.</p>
<p><img src="svgbob_7dea4cc54e9eac3d3a657922085849157a9cf869.svg" alt="Kroki diagram output"></p>
</li>
</ol>
<p>This graph is called a <a href="#BM_(de%20Bruijn%20graph)%2Fi">de Bruijn graph</a>: a <a href="#BM_(balanced)_GRAPH%2Fi">balanced</a> and <a href="#BM_(strongly%20connected)%2Fi">strongly connected</a> graph where the <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s are represented as edges.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The example graph above is <a href="#BM_(balanced)_GRAPH%2Fi">balanced</a>. But, depending on the <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s used, the graph may not be totally <a href="#BM_(balanced)_GRAPH%2Fi">balanced</a>. A technique for dealing with this is detailed below. For now, just assume that the graph will be <a href="#BM_(balanced)_GRAPH%2Fi">balanced</a>.</p>
</div>
<p><strong>WHY</strong>:  Similar to an <a href="#BM_(overlap%20graph)%2Fi">overlap graph</a>, a <a href="#BM_(de%20Bruijn%20graph)%2Fi">de Bruijn graph</a> shows the different ways that <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s can be stitched together. However, unlike an <a href="#BM_(overlap%20graph)%2Fi">overlap graph</a>, the <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s are represented as edges rather than nodes. Where in an <a href="#BM_(overlap%20graph)%2Fi">overlap graph</a> you need to find paths that touch every node exactly once (<a href="#BM_(Hamiltonian%20path%7CHamilton%20path)%2Fi">Hamiltonian path</a>), in a <a href="#BM_(de%20Bruijn%20graph)%2Fi">de Bruijn graph</a> you need to find paths that walk over every edge exactly once (<a href="#BM_(Eulerian%20cycle)%2Fi">Eulerian cycle</a>).</p>
<p>A path in a <a href="#BM_(de%20Bruijn%20graph)%2Fi">de Bruijn graph</a> that walks over each edge exactly once is one possibility for the original <a href="#BM_(single%20stranded%20DNA%7Csingle-stranded%20DNA)%2Fi">single stranded DNA</a> that the <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s came from: it starts and ends at the same node (a cycle), and walks over every edge in the graph.</p>
<p>In contrast to finding a <a href="#BM_(Hamiltonian%20path%7CHamilton%20path)%2Fi">Hamiltonian path</a> in an <a href="#BM_(overlap%20graph)%2Fi">overlap graph</a>, it's much faster to find an <a href="#BM_(Eulerian%20cycle)%2Fi">Eulerian cycle</a> in an <a href="#BM_(de%20Bruijn%20graph)%2Fi">de Bruijn graph</a>.</p>
<p><a href="#BM_(de%20Bruijn%20graph)%2Fi">De Bruijn graph</a>s were originally invented to solve the <a href="#BM_(k-universal%7C%5Cd%2B-universal)%2Fi">k-universal</a> string problem, which is effectively the same concept as <a href="#BM_(assembly%7Cassemble)%2Fi">assembly</a>.</p>
<p><strong>ALGORITHM</strong>:</p>
<p><a href="#BM_(sequencer)%2Fi">Sequencer</a>s produce <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s, but <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s by themselves typically aren't enough for most experiments / algorithms. In theory, stitching overlapping <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s for a single-strand of DNA should reveal that single-strand of DNA. In practice, real-world complications make revealing that single-strand of DNA nearly impossible:</p>
<ul>
<li><a href="#BM_(fragment)_SEQ%2Fi">Fragment</a>s are for both strands (strand of <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA)%2Fi">double-stranded DNA</a> a <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>'s from isn't known).</li>
<li><a href="#BM_(fragment)_SEQ%2Fi">Fragment</a>s may be missing (<a href="#BM_(sequencer)%2Fi">sequencer</a> didn't capture it).</li>
<li><a href="#BM_(fragment)_SEQ%2Fi">Fragment</a>s may have incorrect occurrence counts (<a href="#BM_(sequencer)%2Fi">sequencer</a> captured it too many/few times).</li>
<li><a href="#BM_(fragment)_SEQ%2Fi">Fragment</a>s may have errors (<a href="#BM_(sequencer)%2Fi">sequencer</a> produced <a href="#BM_(sequencing%20error)%2Fi">sequencing error</a>s).</li>
<li><a href="#BM_(fragment)_SEQ%2Fi">Fragment</a>s may be stitch-able in more than one way (multiple guesses).</li>
<li><a href="#BM_(fragment)_SEQ%2Fi">Fragment</a>s may take a long time to stitch (computationally intensive).</li>
</ul>
<p>Never the less, in an ideal world where most of these problems don't exist, an <a href="#BM_(de%20Bruijn%20graph)%2Fi">de Bruijn graph</a> is a good way to guess the single-strand of DNA that a set of <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s came from. A <a href="#BM_(de%20Bruijn%20graph)%2Fi">de Bruijn graph</a> assumes that the <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s it's operating on ...</p>
<ul>
<li>are from a single-strand of DNA,</li>
<li>have correct occurrence counts (no missing or extra),</li>
<li>and contain no errors.</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Although the complications discussed above make it impossible to get the original <a href="#BM_(genome)%2Fi">genome</a> in its entirety, it's still possible to pull out large parts of the original <a href="#BM_(genome)%2Fi">genome</a>. This is discussed in <a href="#BM_(Algorithms%5C%2FAssembly%2FFind%20Contigs)_TOPIC%2F">Algorithms/Assembly/Find Contigs</a>.</p>
</div>
<p>To construct a <a href="#BM_(de%20Bruijn%20graph)%2Fi">de Bruijn graph</a>, add an edge for each <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>, creating missing nodes as required.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_debruijn_graph</span>(<span class="hljs-params">reads: List[T], skip: int = <span class="hljs-number">1</span></span>) -&gt; Graph[T]:</span>
    graph = Graph()
    <span class="hljs-keyword">for</span> read <span class="hljs-keyword">in</span> reads:
        from_node = read.prefix(skip)
        to_node = read.suffix(skip)
        graph.insert_edge(from_node, to_node)
    <span class="hljs-keyword">return</span> graph</code></pre><div style="border:1px solid black;">
<p></p>
<p>Given the fragments ['TTAG', 'TAGT', 'AGTT', 'GTTA', 'TTAC', 'TACT', 'ACTT', 'CTTA'], the de Bruijn graph is...</p>
<p><img src="dot_fc6c4f4bf004838f81f7a6343b7d2e19.svg" alt="Dot diagram"></p>
</div>
<p></p>
<p>Note how the graph above is both <a href="#BM_(balanced)_GRAPH%2Fi">balanced</a> and <a href="#BM_(strongly%20connected)%2Fi">strongly connected</a>. In most cases, non-circular <a href="#BM_(genome)%2Fi">genome</a>s won't generate a <a href="#BM_(balanced%20graph)%2Fi">balanced graph</a> like the one above. Instead, a non-circular <a href="#BM_(genome)%2Fi">genome</a> will very likely generate a graph that's nearly <a href="#BM_(balanced)_GRAPH%2Fi">balanced</a>: Nearly <a href="#BM_(balanced%20graph)%2Fi">balanced graph</a>s are graphs that are would be <a href="#BM_(balanced)_GRAPH%2Fi">balanced</a> if not for a few un<a href="#BM_(balanced%20node)%2Fi">balanced node</a>s (usually root and tail nodes). They can artificially be made to become <a href="#BM_(balanced)_GRAPH%2Fi">balanced</a> by finding im<a href="#BM_(balanced%20node)%2Fi">balanced node</a>s and creating artificial edges between them until they become <a href="#BM_(balanced%20node)%2Fi">balanced node</a>s.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>Circular <a href="#BM_(genome)%2Fi">genome</a>s are <a href="#BM_(genome)%2Fi">genome</a>s that wrap around (e.g. bacterial <a href="#BM_(genome)%2Fi">genome</a>s). They don't have a beginning / end.</p>
</div>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_unbalanced_nodes</span>(<span class="hljs-params">graph: Graph[T]</span>) -&gt; List[Tuple[T, int, int]]:</span>
    unbalanced_nodes = []
    <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph.get_nodes():
        in_degree = graph.get_in_degree(node)
        out_degree = graph.get_out_degree(node)
        <span class="hljs-keyword">if</span> in_degree != out_degree:
            unbalanced_nodes.append((node, in_degree, out_degree))
    <span class="hljs-keyword">return</span> unbalanced_nodes


<span class="hljs-comment"># creates a balanced graph from a nearly balanced graph -- nearly balanced means the graph has an equal number of</span>
<span class="hljs-comment"># missing outputs and missing inputs.</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">balance_graph</span>(<span class="hljs-params">graph: Graph[T]</span>) -&gt; Tuple[Graph[T], Set[T], Set[T]]:</span>
    unbalanced_nodes = find_unbalanced_nodes(graph)
    nodes_with_missing_ins = filter(<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>] &lt; x[<span class="hljs-number">2</span>], unbalanced_nodes)
    nodes_with_missing_outs = filter(<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>] &gt; x[<span class="hljs-number">2</span>], unbalanced_nodes)

    graph = graph.copy()

    <span class="hljs-comment"># create 1 copy per missing input / per missing output</span>
    n_per_need_in = [_n <span class="hljs-keyword">for</span> n, in_degree, out_degree <span class="hljs-keyword">in</span> nodes_with_missing_ins <span class="hljs-keyword">for</span> _n <span class="hljs-keyword">in</span> [n] * (out_degree - in_degree)]
    n_per_need_out = [_n <span class="hljs-keyword">for</span> n, in_degree, out_degree <span class="hljs-keyword">in</span> nodes_with_missing_outs <span class="hljs-keyword">for</span> _n <span class="hljs-keyword">in</span> [n] * (in_degree - out_degree)]
    <span class="hljs-keyword">assert</span> len(n_per_need_in) == len(n_per_need_out)  <span class="hljs-comment"># need an equal count of missing ins and missing outs to balance</span>

    <span class="hljs-comment"># balance</span>
    <span class="hljs-keyword">for</span> n_need_in, n_need_out <span class="hljs-keyword">in</span> zip(n_per_need_in, n_per_need_out):
        graph.insert_edge(n_need_out, n_need_in)

    <span class="hljs-keyword">return</span> graph, set(n_per_need_in), set(n_per_need_out)  <span class="hljs-comment"># return graph with cycle, orig root nodes, orig tail nodes</span></code></pre><div style="border:1px solid black;">
<p></p>
<p>Given the fragments ['TTAC', 'TACC', 'ACCC', 'CCCT'], the artificially balanced de Bruijn graph is...</p>
<p><img src="dot_060b6d958ad63bcbb55a116f699b26f5.svg" alt="Dot diagram"></p>
<p>... with original head nodes at {TTA} and tail nodes at {CCT}.</p>
</div>
<p></p>
<p>Given a <a href="#BM_(de%20Bruijn%20graph)%2Fi">de Bruijn graph</a> (<a href="#BM_(strongly%20connected)%2Fi">strongly connected</a> and <a href="#BM_(balanced)_GRAPH%2Fi">balanced</a>), you can find a <a href="#BM_(Eulerian%20cycle)%2Fi">Eulerian cycle</a> by randomly walking unexplored edges in the graph. Pick a starting node and randomly walk edges until you end up back at that same node, ignoring all edges that were previously walked over. Of the nodes that were walked over, pick one that still has unexplored edges and repeat the process: Walk edges from that node until you end up back at that same node, ignoring edges all edges that were previously walked over (including those in the past iteration). Continue this until you run out of unexplored edges.</p>
<pre class="hljs"><code><span class="hljs-comment"># (6, 8), (8, 7), (7, 9), (9, 6)  ----&gt;  68796</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edge_list_to_node_list</span>(<span class="hljs-params">edges: List[Tuple[T, T]]</span>) -&gt; List[T]:</span>
    ret = [edges[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]]
    <span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> edges:
        ret.append(e[<span class="hljs-number">1</span>])
    <span class="hljs-keyword">return</span> ret


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">randomly_walk_and_remove_edges_until_cycle</span>(<span class="hljs-params">graph: Graph[T], node: T</span>) -&gt; List[T]:</span>
    end_node = node
    edge_list = []
    from_node = node
    <span class="hljs-keyword">while</span> len(graph) &gt; <span class="hljs-number">0</span>:
        to_nodes = graph.get_outputs(from_node)
        to_node = next(to_nodes, <span class="hljs-literal">None</span>)
        <span class="hljs-keyword">assert</span> to_node <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>  <span class="hljs-comment"># eularian graphs are strongly connected, meaning we should never hit dead-end nodes</span>

        graph.delete_edge(from_node, to_node, <span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>)

        edge = (from_node, to_node)
        edge_list.append(edge)
        from_node = to_node
        <span class="hljs-keyword">if</span> from_node == end_node:
            <span class="hljs-keyword">return</span> edge_list_to_node_list(edge_list)

    <span class="hljs-keyword">assert</span> <span class="hljs-literal">False</span>  <span class="hljs-comment"># eularian graphs are strongly connected and balanced, meaning we should never run out of nodes</span>


<span class="hljs-comment"># graph must be strongly connected</span>
<span class="hljs-comment"># graph must be balanced</span>
<span class="hljs-comment"># if the 2 conditions above are met, the graph will be eularian (a eulerian cycle exists)</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">walk_eulerian_cycle</span>(<span class="hljs-params">graph: Graph[T], start_node: T</span>) -&gt; List[T]:</span>
    graph = graph.copy()

    node_cycle = randomly_walk_and_remove_edges_until_cycle(graph, start_node)
    node_cycle_ptr = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> len(graph) &gt; <span class="hljs-number">0</span>:
        new_node_cycle = <span class="hljs-literal">None</span>
        <span class="hljs-keyword">for</span> local_ptr, node <span class="hljs-keyword">in</span> enumerate(node_cycle[node_cycle_ptr:]):
            <span class="hljs-keyword">if</span> node <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> graph:
                <span class="hljs-keyword">continue</span>
            node_cycle_ptr += local_ptr
            inject_node_cycle = randomly_walk_and_remove_edges_until_cycle(graph, node)
            new_node_cycle = node_cycle[:]
            new_node_cycle[node_cycle_ptr:node_cycle_ptr+<span class="hljs-number">1</span>] = inject_node_cycle
            <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">assert</span> new_node_cycle <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>
        node_cycle = new_node_cycle

    <span class="hljs-keyword">return</span> node_cycle</code></pre><div style="border:1px solid black;">
<p></p>
<p>Given the fragments ['TTA', 'TAT', 'ATT', 'TTC', 'TCT', 'CTT'], the de Bruijn graph is...</p>
<p><img src="dot_3a93e1cbe061465a28efa39eadb1f973.svg" alt="Dot diagram"></p>
<p>... and a Eulerian cycle is ...</p>
<p>TT -&gt; TC -&gt; CT -&gt; TT -&gt; TA -&gt; AT -&gt; TT</p>
</div>
<p></p>
<p>Note that the graph above is naturally <a href="#BM_(balanced)_GRAPH%2Fi">balanced</a> (no artificial edges have been added in to make it <a href="#BM_(balanced)_GRAPH%2Fi">balanced</a>). If the graph you're finding a <a href="#BM_(Eulerian%20cycle)%2Fi">Eulerian cycle</a> on has been artificially <a href="#BM_(balanced)_GRAPH%2Fi">balanced</a>, simply start the search for a <a href="#BM_(Eulerian%20cycle)%2Fi">Eulerian cycle</a> from one of the original head node. The artificial edge will show up at the end of the <a href="#BM_(Eulerian%20cycle)%2Fi">Eulerian cycle</a>, and as such can be dropped from the path.</p>
<p><img src="svgbob_cdf5dbb7db5be8e11adb7461507ac8e7ae647e3a.svg" alt="Kroki diagram output"></p>
<p>This algorithm picks one <a href="#BM_(Eulerian%20cycle)%2Fi">Eulerian cycle</a> in a graph. Most graph have multiple <a href="#BM_(Eulerian%20cycle)%2Fi">Eulerian cycle</a>s, likely too many to enumerate all of them.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>See the section on <a href="#BM_(k-universal%7C%5Cd%2B-universal)%2Fi">k-universal</a> strings to see a real-world application of <a href="#BM_(Eulerian%20graph)%2Fi">Eulerian graph</a>s. For something like k=20, good luck trying to enumerate all <a href="#BM_(Eulerian%20cycle)%2Fi">Eulerian cycle</a>s.</p>
</div>
<a name="H_Find%20Bubbles"></a><h3>Find Bubbles</h3>
<p><a name="BM_(Algorithms%5C%2FAssembly%2FFind%20Bubbles)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FOverlap%20Graph)_TOPIC%2F">Algorithms/Assembly/Overlap Graph</a></li>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FDe%20Bruijn%20Graph)_TOPIC%2F">Algorithms/Assembly/De Bruijn Graph</a></li>
</ul>
</div>
<p><strong>WHAT</strong>: Given a set of a <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s that have been broken to k (<a href="#BM_(read%20breaking%7Cread-breaking%7Cbreaking%20reads)%2Fi">read breaking</a> / <a href="#BM_(read-pair%20breaking%7Cread%20pair%20breaking%7Cbreaking%20read-pairs%7Cbreaking%20read%20pairs)%2Fi">read-pair breaking</a>), any ...</p>
<ul>
<li>forked prefixes,</li>
<li>forked suffixes,</li>
<li>or bubbles</li>
</ul>
<p>... of length ...</p>
<ul>
<li>k in the <a href="#BM_(overlap%20graph)%2Fi">overlap graph</a>,</li>
<li>or k-1 in the <a href="#BM_(de%20Bruijn%20graph)%2Fi">de Bruijn graph</a></li>
</ul>
<p>... may have been from a <a href="#BM_(sequencing%20error)%2Fi">sequencing error</a>.</p>
<p><img src="svgbob_986faa465630c014228747bd8c1b6750b9c7d5a7.svg" alt="Kroki diagram output"></p>
<p><strong>WHY</strong>: When <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s returned by a <a href="#BM_(sequencer)%2Fi">sequencer</a> get broken (<a href="#BM_(read%20breaking%7Cread-breaking%7Cbreaking%20reads)%2Fi">read breaking</a> / <a href="#BM_(read-pair%20breaking%7Cread%20pair%20breaking%7Cbreaking%20read-pairs%7Cbreaking%20read%20pairs)%2Fi">read-pair breaking</a>), any <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s containing <a href="#BM_(sequencing%20error)%2Fi">sequencing error</a>s may show up in the graph as one of 3 structures: forked prefix, forked suffix, or bubble. As such, it may be possible to detect these structures and flatten them (by removing bad branches) to get a cleaner graph.</p>
<p>For example, imagine the <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> ATTGG. <a href="#BM_(read%20breaking%7Cread-breaking%7Cbreaking%20reads)%2Fi">Read breaking</a> it into <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">2-mer</a> <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a>s results in: [AT, TT, TG, GG].</p>
<p><img src="svgbob_14d21a2810cefc8cfab333aadbe576260b565d48.svg" alt="Kroki diagram output"></p>
<p>Now, imagine that the <a href="#BM_(sequencer)%2Fi">sequencer</a> captures that same part of the <a href="#BM_(genome)%2Fi">genome</a> again, but this time the <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> contains a <a href="#BM_(sequencing%20error)%2Fi">sequencing error</a>. Depending on where the incorrect nucleotide is, one of the 3 structures will get introduced into the graph:</p>
<ul>
<li>
<p>ATTGG vs A<strong>C</strong>TGG (within first 2 elements)</p>
<p><img src="svgbob_0c0a09e604164ee4ffcdc4f3fcfa420c2035cdd5.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p>ATTGG vs ATT<strong>C</strong>G (within last 2 elements)</p>
<p><img src="svgbob_8749bd635048fbfa4bd483e9c5425e73ff41a8d1.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p>ATTGG vs AT<strong>C</strong>GG (sandwiched after first 2 elements and before last 2 elements)</p>
<p><img src="svgbob_3cc83e04b59a481951a59a2edd92cab8b200b193.svg" alt="Kroki diagram output"></p>
</li>
</ul>
<p>Note that just because these structures exist doesn't mean that the <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s they represent definitively have a <a href="#BM_(sequencing%20error)%2Fi">sequencing error</a>s. These structures could have been caused by other problems / may not be problems at all:</p>
<ul>
<li>
<p>Bubbles may be caused by repetitive regions of DNA.</p>
<p><a href="#BM_(fragment)_SEQ%2Fi">Fragment</a>s from different parts of the <a href="#BM_(genome)%2Fi">genome</a> that are the same except for a few positions will show up as bubbles.</p>
</li>
<li>
<p>Bubbles / forks may be caused when <a href="#BM_(sequencing%7Csequenced)%2Fi">sequencing</a> <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA)%2Fi">double-stranded DNA</a>.</p>
<p>When both strands of DNA get tangled into the same graph, it's possible that <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s from different strands may form bubbles or forks.</p>
</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The Pevzner book says that bubble removal is a common feature in modern <a href="#BM_(assembly%7Cassemble)%2Fi">assemble</a>rs. My assumption is that, before pulling out <a href="#BM_(contig)s%3F%5Cb%2Fi">contig</a>s (described later on), basic probabilities are used to try and suss out if a branch in a bubble / prefix fork / suffix fork is bad and remove it if it is. This (hopefully) results in longer <a href="#BM_(contig)s%3F%5Cb%2Fi">contig</a>s.</p>
</div>
<p><strong>ALGORITHM</strong>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_head_convergences</span>(<span class="hljs-params">graph: Graph[T], branch_len: int</span>) -&gt; List[Tuple[Optional[T], List[T], Optional[T]]]:</span>
    root_nodes = filter(<span class="hljs-keyword">lambda</span> n: graph.get_in_degree(n) == <span class="hljs-number">0</span>, graph.get_nodes())

    ret = []
    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> root_nodes:
        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> graph.get_outputs(n):
            path_from_child = walk_outs_until_converge(graph, child)
            <span class="hljs-keyword">if</span> path_from_child <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
                <span class="hljs-keyword">continue</span>
            diverging_node = <span class="hljs-literal">None</span>
            branch_path = [n] + path_from_child[:<span class="hljs-number">-1</span>]
            converging_node = path_from_child[<span class="hljs-number">-1</span>]
            path = (diverging_node, branch_path, converging_node)
            <span class="hljs-keyword">if</span> len(branch_path) &lt;= branch_len:
                ret.append(path)
    <span class="hljs-keyword">return</span> ret


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_tail_divergences</span>(<span class="hljs-params">graph: Graph[T], branch_len: int</span>) -&gt; List[Tuple[Optional[T], List[T], Optional[T]]]:</span>
    tail_nodes = filter(<span class="hljs-keyword">lambda</span> n: graph.get_out_degree(n) == <span class="hljs-number">0</span>, graph.get_nodes())

    ret = []
    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> tail_nodes:
        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> graph.get_inputs(n):
            path_from_child = walk_ins_until_diverge(graph, child)
            <span class="hljs-keyword">if</span> path_from_child <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
                <span class="hljs-keyword">continue</span>
            diverging_node = path_from_child[<span class="hljs-number">0</span>]
            branch_path = path_from_child[<span class="hljs-number">1</span>:] + [n]
            converging_node = <span class="hljs-literal">None</span>
            path = (diverging_node, branch_path, converging_node)
            <span class="hljs-keyword">if</span> len(branch_path) &lt;= branch_len:
                ret.append(path)
    <span class="hljs-keyword">return</span> ret


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_bubbles</span>(<span class="hljs-params">graph: Graph[T], branch_len: int</span>) -&gt; List[Tuple[Optional[T], List[T], Optional[T]]]:</span>
    branching_nodes = filter(<span class="hljs-keyword">lambda</span> n: graph.get_out_degree(n) &gt; <span class="hljs-number">1</span>, graph.get_nodes())

    ret = []
    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> branching_nodes:
        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> graph.get_outputs(n):
            path_from_child = walk_outs_until_converge(graph, child)
            <span class="hljs-keyword">if</span> path_from_child <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
                <span class="hljs-keyword">continue</span>
            diverging_node = n
            branch_path = path_from_child[:<span class="hljs-number">-1</span>]
            converging_node = path_from_child[<span class="hljs-number">-1</span>]
            path = (diverging_node, branch_path, converging_node)
            <span class="hljs-keyword">if</span> len(branch_path) &lt;= branch_len:
                ret.append(path)
    <span class="hljs-keyword">return</span> ret</code></pre><div style="border:1px solid black;">
<p></p>
<p>Fragments from sequencer:</p>
<ul>
<li>ATAGGAC scanned in 1.</li>
<li>ATTGGAC scanned in 55.</li>
<li>TTGGACA scanned in 30.</li>
<li>TGGACAA scanned in 30.</li>
<li>GGACAAT scanned in 30.</li>
<li>GACAATC scanned in 30.</li>
<li>ACAATCT scanned in 30.</li>
<li>ACAGTCT scanned in 1.</li>
<li>CAATCTC scanned in 30.</li>
<li>AATCTCG scanned in 30.</li>
<li>ATCTCGG scanned in 30.</li>
<li>TCTCGGG scanned in 30.</li>
<li>CTCGGGC scanned in 55.</li>
<li>CTCGTGC scanned in 1.</li>
</ul>
<p>Fragments after being broken to k=4:</p>
<ul>
<li>ATAG broken out 1 times, so it probably appears in the genome 0.01 times.</li>
<li>TAGG broken out 1 times, so it probably appears in the genome 0.01 times.</li>
<li>AGGA broken out 1 times, so it probably appears in the genome 0.01 times.</li>
<li>GGAC broken out 146 times, so it probably appears in the genome 1.0 times.</li>
<li>ATTG broken out 55 times, so it probably appears in the genome 1.0 times.</li>
<li>TTGG broken out 85 times, so it probably appears in the genome 1.0 times.</li>
<li>TGGA broken out 115 times, so it probably appears in the genome 1.0 times.</li>
<li>GACA broken out 120 times, so it probably appears in the genome 1.0 times.</li>
<li>ACAA broken out 120 times, so it probably appears in the genome 1.0 times.</li>
<li>CAAT broken out 120 times, so it probably appears in the genome 1.0 times.</li>
<li>AATC broken out 120 times, so it probably appears in the genome 1.0 times.</li>
<li>ATCT broken out 120 times, so it probably appears in the genome 1.0 times.</li>
<li>ACAG broken out 1 times, so it probably appears in the genome 0.01 times.</li>
<li>CAGT broken out 1 times, so it probably appears in the genome 0.01 times.</li>
<li>AGTC broken out 1 times, so it probably appears in the genome 0.01 times.</li>
<li>GTCT broken out 1 times, so it probably appears in the genome 0.01 times.</li>
<li>TCTC broken out 120 times, so it probably appears in the genome 1.0 times.</li>
<li>CTCG broken out 146 times, so it probably appears in the genome 1.0 times.</li>
<li>TCGG broken out 115 times, so it probably appears in the genome 1.0 times.</li>
<li>CGGG broken out 85 times, so it probably appears in the genome 1.0 times.</li>
<li>GGGC broken out 55 times, so it probably appears in the genome 1.0 times.</li>
<li>TCGT broken out 1 times, so it probably appears in the genome 0.01 times.</li>
<li>CGTG broken out 1 times, so it probably appears in the genome 0.01 times.</li>
<li>GTGC broken out 1 times, so it probably appears in the genome 0.01 times.</li>
</ul>
<p>De Bruijn graph:</p>
<p><img src="dot_58d24202dc65f3967dedac820f12af62.svg" alt="Dot diagram"></p>
<p>Problem paths:</p>
<ul>
<li>Src: ACA, Dst: TCT, Branch: CAA-&gt;AAT-&gt;ATC</li>
<li>Src: ACA, Dst: TCT, Branch: CAG-&gt;AGT-&gt;GTC</li>
<li>Src: None, Dst: GGA, Branch: ATA-&gt;TAG-&gt;AGG</li>
<li>Src: None, Dst: GGA, Branch: ATT-&gt;TTG-&gt;TGG</li>
<li>Src: TCG, Dst: None, Branch: CGG-&gt;GGG-&gt;GGC</li>
<li>Src: TCG, Dst: None, Branch: CGT-&gt;GTG-&gt;TGC</li>
</ul>
</div>
<p></p>
<a name="H_Find%20Contigs"></a><h3>Find Contigs</h3>
<p><a name="BM_(Algorithms%5C%2FAssembly%2FFind%20Contigs)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FOverlap%20Graph)_TOPIC%2F">Algorithms/Assembly/Overlap Graph</a></li>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FDe%20Bruijn%20Graph)_TOPIC%2F">Algorithms/Assembly/De Bruijn Graph</a></li>
<li><a href="#BM_(Algorithms%5C%2FAssembly%2FFind%20Bubbles)_TOPIC%2F">Algorithms/Assembly/Find Bubbles</a></li>
</ul>
</div>
<p>TODO: CONTINUE HERE</p>
<p>TODO: CONTINUE HERE</p>
<p>TODO: CONTINUE HERE</p>
<p>TODO: CONTINUE HERE</p>
<p>TODO: CONTINUE HERE</p>
<p>TODO: CONTINUE HERE</p>
<p>TODO: CONTINUE HERE</p>
<p>TODO: CONTINUE HERE</p>
<p>TODO: CONTINUE HERE</p>
<p>TODO: CONTINUE HERE</p>
<p>TODO: CONTINUE HERE</p>
<p>TODO: CONTINUE HERE</p>
<p>TODO: CONTINUE HERE</p>
<p>TODO: CONTINUE HERE</p>
<p>TODO: CONTINUE HERE</p>
<p>TODO: CONTINUE HERE</p>
<p>TODO: CONTINUE HERE</p>
<p>TODO: CONTINUE HERE</p>
<p>TODO: CONTINUE HERE</p>
<p>TODO: CONTINUE HERE</p>
<p>TODO: CONTINUE HERE</p>
<p>TODO: CONTINUE HERE</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">walk_until_non_1_to_1</span>(<span class="hljs-params">graph: Graph[T], node: T</span>) -&gt; Optional[List[T]]:</span>
    ret = [node]
    ret_quick_lookup = {node}
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        out_degree = graph.get_out_degree(node)
        in_degree = graph.get_in_degree(node)
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(in_degree == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> out_degree == <span class="hljs-number">1</span>):
            <span class="hljs-keyword">return</span> ret

        children = graph.get_outputs(node)
        child = next(children)
        <span class="hljs-keyword">if</span> child <span class="hljs-keyword">in</span> ret_quick_lookup:
            <span class="hljs-keyword">return</span> ret

        node = child
        ret.append(node)
        ret_quick_lookup.add(node)


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">walk_until_loop</span>(<span class="hljs-params">graph: Graph[T], node: T</span>) -&gt; Optional[List[T]]:</span>
    ret = [node]
    ret_quick_lookup = {node}
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        out_degree = graph.get_out_degree(node)
        <span class="hljs-keyword">if</span> out_degree &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> out_degree == <span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>

        children = graph.get_outputs(node)
        child = next(children)
        <span class="hljs-keyword">if</span> child <span class="hljs-keyword">in</span> ret_quick_lookup:
            <span class="hljs-keyword">return</span> ret

        node = child
        ret.append(node)
        ret_quick_lookup.add(node)


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_maximal_non_branching_paths</span>(<span class="hljs-params">graph: Graph[T]</span>) -&gt; List[List[T]]:</span>
    paths = []

    <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph.get_nodes():
        out_degree = graph.get_out_degree(node)
        in_degree = graph.get_in_degree(node)
        <span class="hljs-keyword">if</span> (in_degree == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> out_degree == <span class="hljs-number">1</span>) <span class="hljs-keyword">or</span> out_degree == <span class="hljs-number">0</span>:
            <span class="hljs-keyword">continue</span>
        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> graph.get_outputs(node):
            path_from_child = walk_until_non_1_to_1(graph, child)
            <span class="hljs-keyword">if</span> path_from_child <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
                <span class="hljs-keyword">continue</span>
            path = [node] + path_from_child
            paths.append(path)

    skip_nodes = set()
    <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph.get_nodes():
        <span class="hljs-keyword">if</span> node <span class="hljs-keyword">in</span> skip_nodes:
            <span class="hljs-keyword">continue</span>
        out_degree = graph.get_out_degree(node)
        in_degree = graph.get_in_degree(node)
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (in_degree == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> out_degree == <span class="hljs-number">1</span>) <span class="hljs-keyword">or</span> out_degree == <span class="hljs-number">0</span>:
            <span class="hljs-keyword">continue</span>
        path = walk_until_loop(graph, node)
        <span class="hljs-keyword">if</span> path <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">continue</span>
        path = path + [node]
        paths.append(path)
        skip_nodes |= set(path)

    <span class="hljs-keyword">return</span> paths</code></pre><a name="H_Stories"></a><h1>Stories</h1>
<a name="H_Bacteria%20Replication"></a><h2>Bacteria Replication</h2>
<p>Bacteria are known to have a single chromosome of circular / looping DNA. On that DNA, the <a href="#BM_(replication%20origin)%2Fi">replication origin</a> (<a href="#BM_%5Cb(ori)%5Cb%2Fi">ori</a>) is the region in which DNA replication starts, while the <a href="#BM_(replication%20terminus)%2Fi">replication terminus</a> (<a href="#BM_%5Cb(ter)%5Cb%2Fi">ter</a>) is where it ends. The <a href="#BM_%5Cb(ori)%5Cb%2Fi">ori</a> and <a href="#BM_%5Cb(ter)%5Cb%2Fi">ter</a> and usually placed on opposite ends of each other.</p>
<p><img src="svgbob_308a4af4e5d6864abeb06f6652581aec0ff50fb1.svg" alt="Kroki diagram output"></p>
<p>The replication process begins by a <a href="#BM_(replication%20fork)%2Fi">replication fork</a> opening at the <a href="#BM_%5Cb(ori)%5Cb%2Fi">ori</a>. As replication happens, that fork widens until the point it reaches <a href="#BM_%5Cb(ter)%5Cb%2Fi">ter</a>...</p>
<p><img src="svgbob_fc7cf2c734fa0cab15b5746e25ad07e25f85ec64.svg" alt="Kroki diagram output"></p>
<p>For each forked <a href="#BM_(single%20stranded%20DNA%7Csingle-stranded%20DNA)%2Fi">single-stranded DNA</a>, <a href="#BM_(DNA%20polymerase)%2Fi">DNA polymerase</a>s attach on and synthesize a new reverse complement strand so that it turns back into <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA)%2Fi">double-stranded DNA</a>....</p>
<p><img src="svgbob_971abfeff166ada9787cd484db9bfbe43120973a.svg" alt="Kroki diagram output"></p>
<p>The process of synthesizing a reverse complement strand is different based on the section of DNA that <a href="#BM_(DNA%20polymerase)%2Fi">DNA polymerase</a> is operating on. For each <a href="#BM_(single%20stranded%20DNA%7Csingle-stranded%20DNA)%2Fi">single-stranded DNA</a>, if the direction of that DNA strand is traveling from ...</p>
<ul>
<li><a href="#BM_%5Cb(ori)%5Cb%2Fi">ori</a> to <a href="#BM_%5Cb(ter)%5Cb%2Fi">ter</a>, it's called a <a href="#BM_(forward%20half-strand)%2Fi">forward half-strand</a>.</li>
<li><a href="#BM_%5Cb(ter)%5Cb%2Fi">ter</a> to <a href="#BM_%5Cb(ori)%5Cb%2Fi">ori</a>, it's called a <a href="#BM_(reverse%20half-strand%7Cbackward%20half-strand%7Cbackwards%20half-strand)%2Fi">reverse half-strand</a>.</li>
</ul>
<p><img src="svgbob_ad11e0114c63955ab620cbe9a8dee61a85caa1f9.svg" alt="Kroki diagram output"></p>
<p>Since <a href="#BM_(DNA%20polymerase)%2Fi">DNA polymerase</a> can only walk over DNA in the reverse direction (<a href="#BM_(3')%2Fi">3'</a> to <a href="#BM_(5')%2Fi">5'</a>), the 2 <a href="#BM_(reverse%20half-strand%7Cbackward%20half-strand%7Cbackwards%20half-strand)%2Fi">reverse half-strand</a>s will quickly get walked over in one shot. A <a href="#BM_(primer)%2Fi">primer</a> gets attached to the <a href="#BM_%5Cb(ori)%5Cb%2Fi">ori</a>, then a <a href="#BM_(DNA%20polymerase)%2Fi">DNA polymerase</a> attaches to that <a href="#BM_(primer)%2Fi">primer</a> to begin synthesis of a new strand. Synthesis continues until the <a href="#BM_%5Cb(ter)%5Cb%2Fi">ter</a> is reached...</p>
<p><img src="svgbob_83b0a64a4614fa906388ef166341e3fd293c6dc0.svg" alt="Kroki diagram output"></p>
<p>For the <a href="#BM_(forward%20half-strand)%2Fi">forward half-strand</a>s, the process is much slower. Since <a href="#BM_(DNA%20polymerase)%2Fi">DNA polymerase</a> can only walk DNA in the reverse direction, the <a href="#BM_(forward%20half-strand)%2Fi">forward half-strand</a>s get replicated in small segments. That is, as the <a href="#BM_(replication%20fork)%2Fi">replication fork</a> continues to grow, every ~2000 nucleotides a new <a href="#BM_(primer)%2Fi">primer</a> attaches to the end of the fork on the forward strands. A new <a href="#BM_(DNA%20polymerase)%2Fi">DNA polymerase</a> attaches to each <a href="#BM_(primer)%2Fi">primer</a> and walks in the reverse direction (towards the <a href="#BM_%5Cb(ori)%5Cb%2Fi">ori</a>) to synthesize a small segment of DNA. That small segment of DNA is called an <a href="#BM_(Okazaki%20fragment)%2Fi">Okazaki fragment</a>...</p>
<p><img src="svgbob_4c651d9aa100c5b586103bb0d42cc91ff27da474.svg" alt="Kroki diagram output"></p>
<p>The <a href="#BM_(replication%20fork)%2Fi">replication fork</a> will keep widening until the original 2 strands split off. <a href="#BM_(DNA%20polymerase)%2Fi">DNA polymerase</a> will have made sure that for each separated strand, a newly synthesized reverse complement is paired to it. The end result is 2 daughter chromosome where each chromosome has gaps...</p>
<p><img src="svgbob_eac405c5709e835b492078d1ea557a7199d8f722.svg" alt="Kroki diagram output"></p>
<p>The <a href="#BM_(Okazaki%20fragment)%2Fi">Okazaki fragment</a>s synthesized on the forward strands end up getting sewn together by <a href="#BM_(DNA%20ligase)%2Fi">DNA ligase</a>...</p>
<p><img src="svgbob_5c3304d08cc6bbc226df966d6e1c119636331723.svg" alt="Kroki diagram output"></p>
<p>There are now two complete copies of the DNA.</p>
<a name="H_Find%20Ori%20and%20Ter"></a><h3>Find Ori and Ter</h3>
<p><a name="BM_(Stories%5C%2FBacteria%20Replication%2FFind%20Ori%20and%20Ter)_TOPIC%2F"></a><strong></strong></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FGC%20Skew)_TOPIC%2F">Algorithms/GC Skew</a></li>
</ul>
</div>
<p>Since the <a href="#BM_(forward%20half-strand)%2Fi">forward half-strand</a> gets its reverse complement synthesized at a much slower rate than the <a href="#BM_(reverse%20half-strand%7Cbackward%20half-strand%7Cbackwards%20half-strand)%2Fi">reverse half-strand</a>, it stays single stranded for a much longer time. <a href="#BM_(single%20stranded%20DNA%7Csingle-stranded%20DNA)%2Fi">Single-stranded DNA</a> is 100 times more susceptible to mutations than <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA)%2Fi">double-stranded DNA</a>. Specifically, in <a href="#BM_(single%20stranded%20DNA%7Csingle-stranded%20DNA)%2Fi">single-stranded DNA</a>, C has a greater tendency to mutate to T. This process of mutation is referred to as deanimation.</p>
<p><img src="svgbob_f52124bb3b29a8388ed6a1fc5f597b26a2514f42.svg" alt="Kroki diagram output"></p>
<p>The <a href="#BM_(reverse%20half-strand%7Cbackward%20half-strand%7Cbackwards%20half-strand)%2Fi">reverse half-strand</a> spends much less time as a <a href="#BM_(single%20stranded%20DNA%7Csingle-stranded%20DNA)%2Fi">single-stranded DNA</a>. As such, it experiences much less C to T mutations.</p>
<p><img src="svgbob_7d778227822729bde64ce4a36b5cc9da206869c1.svg" alt="Kroki diagram output"></p>
<p>Ultimately, that means that a single strand will have a different nucleotide distribution between its <a href="#BM_(forward%20half-strand)%2Fi">forward half-strand</a> vs its <a href="#BM_(reverse%20half-strand%7Cbackward%20half-strand%7Cbackwards%20half-strand)%2Fi">backward half-strand</a>. If the half-strand being targeted for replication is the ...</p>
<ul>
<li><a href="#BM_(forward%20half-strand)%2Fi">forward half-strand</a>, some Cs get replaced with Ts. As such, its synthesized <a href="#BM_(reverse%20half-strand%7Cbackward%20half-strand%7Cbackwards%20half-strand)%2Fi">reverse half-strand</a> will have less Gs.</li>
<li><a href="#BM_(reverse%20half-strand%7Cbackward%20half-strand%7Cbackwards%20half-strand)%2Fi">reverse half-strand</a>, most Cs are kept. As such, its synthesized <a href="#BM_(forward%20half-strand)%2Fi">forward half-strand</a> will keep its Gs.</li>
</ul>
<p>To simplify, the ...</p>
<ul>
<li><a href="#BM_(forward%20half-strand)%2Fi">forward half-strand</a>: loses Cs, keeps Gs.</li>
<li><a href="#BM_(reverse%20half-strand%7Cbackward%20half-strand%7Cbackwards%20half-strand)%2Fi">reverse half-strand</a>: keeps Cs, loses Gs.</li>
</ul>
<p>You can use a GC skew diagram to help pinpoint where the <a href="#BM_%5Cb(ori)%5Cb%2Fi">ori</a> and <a href="#BM_%5Cb(ter)%5Cb%2Fi">ter</a> might be. The plot will typically form a peak where the <a href="#BM_%5Cb(ter)%5Cb%2Fi">ter</a> is (more G vs C) and form a valley where the <a href="#BM_%5Cb(ori)%5Cb%2Fi">ori</a> is (less G vs C). For example, the GC skew diagram for E. coli bacteria shows a distinct peak and distinct valley.</p>
<div style="border:1px solid black;">
<p></p>
<p>Calculating skew for: ...</p>
<p>Result: [0, 0, 1, 0,...</p>
<p><img src="skew_3b3ef8e0e7ef6297fdc10c525d5b0fbc.png" alt="GC Skew Plot"></p>
<p>Min position (ori): 4719166</p>
<p>Max position (ter): 2073768</p>
</div>
<p></p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The material talks about how not all bacteria have a single peak and single valley. Some may have multiple. The reasoning for this still hasn't been discovered. It was speculated at one point that some bacteria may have multiple <a href="#BM_%5Cb(ori)%5Cb%2Fi">ori</a> / <a href="#BM_%5Cb(ter)%5Cb%2Fi">ter</a> regions.</p>
</div>
<a name="H_Find%20the%20DnaA%20Box"></a><h3>Find the DnaA Box</h3>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Stories%5C%2FBacteria%20Replication%2FFind%20Ori%20and%20Ter)_TOPIC%2F">Stories/Bacteria Replication/Find Ori and Ter</a></li>
<li><a href="#BM_(Algorithms%5C%2FK-mer%2FFind%20Repeating%20in%20Window)_TOPIC%2F">Algorithms/K-mer/Find Repeating in Window</a></li>
<li><a href="#BM_(Algorithms%5C%2FGC%20Skew)_TOPIC%2F">Algorithms/GC Skew</a></li>
</ul>
</div>
<p>Within the <a href="#BM_%5Cb(ori)%5Cb%2Fi">ori</a> region, there exists several copies of some <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> pattern. These copies are referred to as <a href="#BM_(DnaA%20box)%2Fi">DnaA box</a>es.</p>
<p><img src="svgbob_d3e7c213995dec8a967fa89f40ebae73ed6e53ac.svg" alt="Kroki diagram output"></p>
<p>The DnaA protein binds to a <a href="#BM_(DnaA%20box)%2Fi">DnaA box</a> to activate the process of DNA replication. Through experiments, biologists have determined that <a href="#BM_(DnaA%20box)%2Fi">DnaA box</a>es are typical <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">9-mer</a>s. The <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">9-mer</a>s may not match exactly -- the DnaA protein may bind to ...</p>
<ul>
<li>the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">9-mer</a> itself.</li>
<li>slight variations of the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">9-mer</a>.</li>
<li>the reverse complement of the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">9-mer</a>.</li>
<li>slight variations of the reverse complement of the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">9-mer</a>.</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The reason why multiple copies of the <a href="#BM_(DnaA%20box)%2Fi">DnaA box</a> exist probably has to do with DNA mutation. If one of the copies mutates to a point where the DnaA protein no longer binds to it, it can still bind to the other copies.</p>
</div>
<p>In the example below, the general vicinity of E. coli's <a href="#BM_%5Cb(ori)%5Cb%2Fi">ori</a> is found using GC skew, then that general vicinity is searched for repeating <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">9-mer</a>s. These repeating <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">9-mer</a>s are potential <a href="#BM_(DnaA%20box)%2Fi">DnaA box</a> candidates.</p>
<div style="border:1px solid black;">
<p></p>
<p>Calculating skew for: ...</p>
<p>Result: [0, 0, 1, 0,...</p>
<p><img src="skew_3b3ef8e0e7ef6297fdc10c525d5b0fbc.png" alt="GC Skew Plot"></p>
<p>Ori vicinity (min pos): 4719166</p>
<p>In the ori vicinity, found clusters of k=9 (at least 3 occurrences in window of 500) in ... at...</p>
<ul>
<li>KmerCluster(kmer='CCGCGCTGG', start_index=9, occurrence_count=3)</li>
<li>KmerCluster(kmer='CGGTGCTGG', start_index=9, occurrence_count=3)</li>
<li>KmerCluster(kmer='TCGGCGGTA', start_index=52, occurrence_count=3)</li>
<li>KmerCluster(kmer='CTCGGCGGT', start_index=53, occurrence_count=3)</li>
<li>KmerCluster(kmer='CTGAAGATC', start_index=98, occurrence_count=3)</li>
<li>KmerCluster(kmer='AGGCGGTTC', start_index=160, occurrence_count=3)</li>
<li>KmerCluster(kmer='CAGGCGGCT', start_index=161, occurrence_count=3)</li>
<li>KmerCluster(kmer='CAGGCGGAT', start_index=161, occurrence_count=3)</li>
<li>KmerCluster(kmer='CAGGCGGGT', start_index=161, occurrence_count=3)</li>
<li>KmerCluster(kmer='CAGGCGGTT', start_index=161, occurrence_count=4)</li>
<li>KmerCluster(kmer='TCAGGCGGT', start_index=162, occurrence_count=4)</li>
<li>KmerCluster(kmer='ATCAGGCGG', start_index=163, occurrence_count=4)</li>
<li>KmerCluster(kmer='CATCAGGCG', start_index=164, occurrence_count=3)</li>
<li>KmerCluster(kmer='CCATCAGGC', start_index=165, occurrence_count=3)</li>
<li>KmerCluster(kmer='CGGCGATGG', start_index=199, occurrence_count=3)</li>
<li>KmerCluster(kmer='GGCGGTTCG', start_index=210, occurrence_count=3)</li>
<li>KmerCluster(kmer='GGCGGTATG', start_index=210, occurrence_count=3)</li>
<li>KmerCluster(kmer='GGCAGTACG', start_index=210, occurrence_count=3)</li>
<li>KmerCluster(kmer='CAGGCGGTT', start_index=212, occurrence_count=3)</li>
<li>KmerCluster(kmer='TCAGGCGGG', start_index=213, occurrence_count=3)</li>
<li>KmerCluster(kmer='TCAGGCGGC', start_index=213, occurrence_count=3)</li>
<li>KmerCluster(kmer='TCAGGCGGT', start_index=213, occurrence_count=3)</li>
<li>KmerCluster(kmer='TCAGGCGGA', start_index=213, occurrence_count=3)</li>
<li>KmerCluster(kmer='ATCAGGCGG', start_index=214, occurrence_count=3)</li>
<li>KmerCluster(kmer='GTCAGGCGG', start_index=214, occurrence_count=3)</li>
<li>KmerCluster(kmer='TTCAGGCGG', start_index=214, occurrence_count=3)</li>
<li>KmerCluster(kmer='CTCAGGCGG', start_index=214, occurrence_count=3)</li>
<li>KmerCluster(kmer='GGTCAGGCG', start_index=215, occurrence_count=3)</li>
<li>KmerCluster(kmer='CGGATCGTT', start_index=232, occurrence_count=3)</li>
<li>KmerCluster(kmer='CGGATCCTG', start_index=232, occurrence_count=3)</li>
<li>KmerCluster(kmer='GCGGATCCT', start_index=233, occurrence_count=3)</li>
<li>KmerCluster(kmer='CCGGATCGT', start_index=233, occurrence_count=3)</li>
<li>KmerCluster(kmer='AGCCGGATC', start_index=235, occurrence_count=3)</li>
<li>KmerCluster(kmer='GATCCTAAA', start_index=282, occurrence_count=3)</li>
<li>KmerCluster(kmer='TTTTGATAC', start_index=427, occurrence_count=3)</li>
<li>KmerCluster(kmer='TTCTTTTGA', start_index=430, occurrence_count=3)</li>
<li>KmerCluster(kmer='TGGCTGGGG', start_index=460, occurrence_count=3)</li>
<li>KmerCluster(kmer='ATCACCATT', start_index=500, occurrence_count=3)</li>
<li>KmerCluster(kmer='TCCTTTTTA', start_index=513, occurrence_count=3)</li>
<li>KmerCluster(kmer='ATCCTTTTT', start_index=514, occurrence_count=3)</li>
<li>KmerCluster(kmer='GATCCTTAT', start_index=515, occurrence_count=3)</li>
<li>KmerCluster(kmer='GATCCTTTT', start_index=515, occurrence_count=3)</li>
<li>KmerCluster(kmer='GGATCCTTT', start_index=516, occurrence_count=3)</li>
<li>KmerCluster(kmer='CTGATCCTT', start_index=517, occurrence_count=3)</li>
<li>KmerCluster(kmer='CCGATCCTT', start_index=517, occurrence_count=3)</li>
<li>KmerCluster(kmer='CGGATCATT', start_index=517, occurrence_count=3)</li>
<li>KmerCluster(kmer='AGGATCCTT', start_index=517, occurrence_count=3)</li>
<li>KmerCluster(kmer='CCGGATCCC', start_index=518, occurrence_count=3)</li>
<li>KmerCluster(kmer='CAGGATCCT', start_index=518, occurrence_count=3)</li>
<li>KmerCluster(kmer='CCCGGATCC', start_index=519, occurrence_count=3)</li>
<li>KmerCluster(kmer='TTATCCAGA', start_index=522, occurrence_count=3)</li>
<li>KmerCluster(kmer='CCAGGTTTT', start_index=529, occurrence_count=3)</li>
<li>KmerCluster(kmer='TCATTCTCA', start_index=611, occurrence_count=3)</li>
<li>KmerCluster(kmer='TCCCAGGTT', start_index=618, occurrence_count=3)</li>
<li>KmerCluster(kmer='ACAGATCTT', start_index=644, occurrence_count=3)</li>
<li>KmerCluster(kmer='AAACAGATC', start_index=646, occurrence_count=3)</li>
<li>KmerCluster(kmer='TCCAAATAA', start_index=653, occurrence_count=3)</li>
<li>KmerCluster(kmer='TTATTGATC', start_index=730, occurrence_count=3)</li>
<li>KmerCluster(kmer='GTTGTTGAG', start_index=731, occurrence_count=3)</li>
<li>KmerCluster(kmer='AGGATCAAC', start_index=769, occurrence_count=3)</li>
<li>KmerCluster(kmer='AGATCAACC', start_index=836, occurrence_count=3)</li>
</ul>
</div>
<p></p>
<a name="H_Transcription%20Factors"></a><h2>Transcription Factors</h2>
<p>A <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a> / <a href="#BM_(regulatory%20protein)%2Fi">regulatory protein</a> is an enzyme that influences the rate of <a href="#BM_(gene%20expression)%2Fi">gene expression</a> for some set of <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">genes</a>. As the saturation of a <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a> changes, so does the rate of <a href="#BM_(gene%20expression)%2Fi">gene expression</a> for the set of <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">genes</a> that it influences.</p>
<p><a href="#BM_(transcription%20factor)%2Fi">Transcription factor</a>s bind to DNA near the <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">genes</a> they influence: a <a href="#BM_(transcription%20factor%20binding%20site)%2Fi">transcription factor binding site</a> is located in a <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">gene</a>'s <a href="#BM_(upstream%20region)%2Fi">upstream region</a> and the <a href="#BM_(sequence)%2Fi">sequence</a> at that location is a fuzzy nucleotide <a href="#BM_(sequence)%2Fi">sequence</a> of length 8 to 12 called a <a href="#BM_(regulatory%20motif)%2Fi">regulatory motif</a>. The simplest way to think of a <a href="#BM_(regulatory%20motif)%2Fi">regulatory motif</a> is a regex pattern without quantifiers. For example, the regex <code>[AT]TT[GC]CCCTA</code> may match to ATTGCCCTA, ATTCCCCTA, TTTGCCCTA, and TTTCCCCTA. The regex itself is the <a href="#BM_(motif)%2Fi">motif</a>, while the <a href="#BM_(sequence)%2Fi">sequence</a>s being matched are <a href="#BM_(motif%20member)%2Fi">motif member</a>s.</p>
<p><img src="svgbob_c77523791e9f610ea50acd1a596be075095bcceb.svg" alt="Kroki diagram output"></p>
<p>The production of <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a>s may be tied to certain internal or external conditions. For example, imagine a flower where the petals...</p>
<ul>
<li>bunch together at night time when sunlight is hidden and temperature is lower.</li>
<li>spread out at day time when sunlight is available and temperature is higher.</li>
</ul>
<p>The external conditions of sunlight and temperature causes the saturation of some <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a>s to change. Those <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a>s influence the rate of <a href="#BM_(gene%20expression)%2Fi">gene expression</a> for the <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">genes</a> that control the bunching and spreading of the petals.</p>
<p><img src="svgbob_02d5e3f967efc5f1f94cccd5f97a6610035cb8fd.svg" alt="Kroki diagram output"></p>
<a name="H_Find%20Regulatory%20Motif"></a><h3>Find Regulatory Motif</h3>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>↩PREREQUISITES↩</strong></p>
<ul>
<li><a href="#BM_(Algorithms%5C%2FMotif%2FFind%20Motif%20Matrix)_TOPIC%2F">Algorithms/Motif/Find Motif Matrix</a></li>
</ul>
</div>
<p>Given a organism, it's suspected that some physical change in that organism is linked to a <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a>. However, it isn't known ...</p>
<ul>
<li>which <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a> (if any).</li>
<li>what the <a href="#BM_(regulatory%20motif)%2Fi">regulatory motif</a> for that <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a> is.</li>
</ul>
<p>A special device is used to take snapshots of the organism's mRNA at different points in time: <a href="#BM_(DNA%20microarray)%2Fi">DNA microarray</a> / RNA <a href="#BM_(sequencer)%2Fi">sequencer</a>. Specifically, two snapshots are taken:</p>
<ol>
<li>When the physical change is expressed.</li>
<li>When the physical change isn't expressed.</li>
</ol>
<p>Comparing these snapshots identifies which <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">genes</a> have noticeably differing rates of <a href="#BM_(gene%20expression)%2Fi">gene expression</a>. If these <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">genes</a> (or a subset of these <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">genes</a>) were influenced by the same <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a>, their <a href="#BM_(upstream%20region)%2Fi">upstream region</a>s would contain <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a>s of that <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a>'s <a href="#BM_(regulatory%20motif)%2Fi">regulatory motif</a>.</p>
<p>Since neither the <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a> nor its <a href="#BM_(regulatory%20motif)%2Fi">regulatory motif</a> are known, there is no specific <a href="#BM_(motif)%2Fi">motif</a> to search for in the <a href="#BM_(upstream%20region)%2Fi">upstream region</a>s. But, because <a href="#BM_(motif%20member)%2Fi">motif member</a>s are typically similar to each other, <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> finding algorithms can be used on these <a href="#BM_(upstream%20region)%2Fi">upstream region</a>s to find sets of similar <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s. These similar <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s may all be <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a>s of the same <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a>'s <a href="#BM_(regulatory%20motif)%2Fi">regulatory motif</a>.</p>
<p><img src="svgbob_bc9f1ba4918b4a4995ec308b823f93eb3da45567.svg" alt="Kroki diagram output"></p>
<p>In the example below, a set of <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">genes</a> in baker's yeast (Saccharomyces cerevisiae) are suspected of being influenced by the same <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a>. These <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">genes</a> are searched for a common <a href="#BM_(motif)%2Fi">motif</a>. Assuming one is found, it could be the <a href="#BM_(motif)%2Fi">motif</a> of the suspected <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The example below hard codes k to 18, but you typically don't know what k should be set to beforehand. The Pevzner book doesn't discuss how to work around this problem. A strategy for finding k may be to run the <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a> finding algorithm multiple times, but with a different k each time. For each <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a>, if the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s selected across the runs came from the same general vicinity of the <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">gene</a>'s <a href="#BM_(upstream%20region)%2Fi">upstream region</a>, those <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s may either be picking ...</p>
<ul>
<li>the actual <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a>.</li>
<li>a part of the actual <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a>.</li>
<li>a part of the actual <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a> with some junk prepended/appended to it.</li>
</ul>
</div>
<div style="border:1px solid black;">
<p></p>
<p>Organism is baker's yeast. Suspected genes influenced by transcription factor: THI12, YHL017W, SYN8, YCG1, UBX5, and KEI1.</p>
<p>Searching for 18-mer across a set of 6 gene upstream regions...</p>
<p>GAAAAAGGAAGGAAAAAT<br>GAAAAAAAAAGGAAAAAA<br>GAAAAAGAAAAAAAAAAA<br>GAAAAAAAGAAGACAAAG<br>GAATATAAACATATAAAA<br>GAATATAAACATATAAAA</p>
<p>Score is: 20</p>
</div>
<p></p>
<a name="H_Terminology"></a><h1>Terminology</h1>
<ul>
<li>
<p><a name="BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi"></a><strong>k-mer</strong> - A sub<a href="#BM_(sequence)%2Fi">sequence</a> of length k within some larger biological <a href="#BM_(sequence)%2Fi">sequence</a> (e.g. DNA or <a href="#BM_(amino%20acid)%2Fi">amino acid</a> chain). For example, in the DNA <a href="#BM_(sequence)%2Fi">sequence</a> GAAATC, the following <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>'s exist:</p>
<table>
<thead>
<tr>
<th>k</th>
<th><a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>G A A A T C</td>
</tr>
<tr>
<td>2</td>
<td>GA AA AA AT TC</td>
</tr>
<tr>
<td>3</td>
<td>GAA AAA AAT ATC</td>
</tr>
<tr>
<td>4</td>
<td>GAAA AAAT AATC</td>
</tr>
<tr>
<td>5</td>
<td>GAAAT AAATC</td>
</tr>
<tr>
<td>6</td>
<td>GAAATC</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><a name="BM_(%5C(%5Cd%2B%2C%5Cs*%5Cd%2B%5C)-mer%7Ckd-mer%7Ckdmer%7C%5C(k%2C%5Cs*d%5C)-mer)%2Fi"></a><strong>kd-mer</strong> - A sub<a href="#BM_(sequence)%2Fi">sequence</a> of length 2k + d within some larger biological <a href="#BM_(sequence)%2Fi">sequence</a> (e.g. DNA or <a href="#BM_(amino%20acid)%2Fi">amino acid</a> chain) where the first k elements and the last k elements are known but the d elements in between isn't known.</p>
<p>When identifying a <a href="#BM_(%5C(%5Cd%2B%2C%5Cs*%5Cd%2B%5C)-mer%7Ckd-mer%7Ckdmer%7C%5C(k%2C%5Cs*d%5C)-mer)%2Fi">kd-mer</a> with a specific k and d, the proper syntax is <a href="#BM_(%5C(%5Cd%2B%2C%5Cs*%5Cd%2B%5C)-mer%7Ckd-mer%7Ckdmer%7C%5C(k%2C%5Cs*d%5C)-mer)%2Fi">(k, d)-mer</a>. For example, <a href="#BM_(%5C(%5Cd%2B%2C%5Cs*%5Cd%2B%5C)-mer%7Ckd-mer%7Ckdmer%7C%5C(k%2C%5Cs*d%5C)-mer)%2Fi">(1, 2)-mer</a> represents a <a href="#BM_(%5C(%5Cd%2B%2C%5Cs*%5Cd%2B%5C)-mer%7Ckd-mer%7Ckdmer%7C%5C(k%2C%5Cs*d%5C)-mer)%2Fi">kd-mer</a> with k=1 and d=2. In the DNA <a href="#BM_(sequence)%2Fi">sequence</a> GAAATC, the following <a href="#BM_(%5C(%5Cd%2B%2C%5Cs*%5Cd%2B%5C)-mer%7Ckd-mer%7Ckdmer%7C%5C(k%2C%5Cs*d%5C)-mer)%2Fi">(1, 2)-mer</a>'s exist: <code>G--A</code>, <code>A--T</code>, <code>A--C</code>.</p>
<p>See <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a>.</p>
</li>
<li>
<p><a name="BM_(5')%2Fi"></a><strong>5'</strong> (<a name="BM_(5%20prime)%2Fi"></a><strong>5 prime</strong>) / <a name="BM_(3')%2Fi"></a><strong>3'</strong> (<a name="BM_(3%20prime)%2Fi"></a><strong>3 prime</strong>) - <a href="#BM_(5')%2Fi">5'</a> (<a href="#BM_(5%20prime)%2Fi">5 prime</a>) and <a href="#BM_(3')%2Fi">3'</a> (<a href="#BM_(3%20prime)%2Fi">3 prime</a>) describe the opposite ends of DNA. The chemical structure at each end is what defines if it's <a href="#BM_(5')%2Fi">5'</a> or <a href="#BM_(3')%2Fi">3'</a> -- each end is guaranteed to be different from the other. The forward direction on DNA is defined as <a href="#BM_(5')%2Fi">5'</a> to <a href="#BM_(3')%2Fi">3'</a>, while the backwards direction is <a href="#BM_(3')%2Fi">3'</a> to <a href="#BM_(5')%2Fi">5'</a>.</p>
<p>Two complementing DNA strands will always be attached in opposite directions.</p>
<p><img src="svgbob_a2c87a8f72a4ea21f474350dc6a429e386ae8222.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BM_(DNA%20polymerase)%2Fi"></a><strong>DNA polymerase</strong> - An enzyme that replicates a strand of DNA. That is, <a href="#BM_(DNA%20polymerase)%2Fi">DNA polymerase</a> walks over a single strand of DNA bases (not the strand of base pairs) and  generates a strand of complements. Before <a href="#BM_(DNA%20polymerase)%2Fi">DNA polymerase</a> can attach itself and start replicating DNA, it requires a <a href="#BM_(primer)%2Fi">primer</a>.</p>
<p><img src="svgbob_ac1f3f5c9441e395290e542abbc9256bed49302f.svg" alt="Kroki diagram output"></p>
<p><a href="#BM_(DNA%20polymerase)%2Fi">DNA polymerase</a> is unidirectional, meaning that it can only walk a DNA strand in one direction: reverse (<a href="#BM_(3')%2Fi">3'</a> to <a href="#BM_(5')%2Fi">5'</a>)</p>
</li>
<li>
<p><a name="BM_(primer)%2Fi"></a><strong>primer</strong> - A <a href="#BM_(primer)%2Fi">primer</a> is a short strand of RNA that binds to some larger strand of DNA (single bases, not a strand of base pairs) and allows DNA synthesis to  happen. That is, the <a href="#BM_(primer)%2Fi">primer</a> acts as the entry point for special enzymes <a href="#BM_(DNA%20polymerase)%2Fi">DNA polymerase</a>s. <a href="#BM_(DNA%20polymerase)%2Fi">DNA polymerase</a>s bind to the <a href="#BM_(primer)%2Fi">primer</a> to get access to the strand.</p>
</li>
<li>
<p><a name="BM_(replication%20fork)%2Fi"></a><strong>replication fork</strong> - The process of DNA replication requires that DNA's 2 complementing strands be unwound and split open. The area where the DNA starts to  split is called the <a href="#BM_(replication%20fork)%2Fi">replication fork</a>. In bacteria, the <a href="#BM_(replication%20fork)%2Fi">replication fork</a> starts at the <a href="#BM_(replication%20origin)%2Fi">replication origin</a> and keeps expanding until it reaches the <a href="#BM_(replication%20terminus)%2Fi">replication terminus</a>.  Special enzymes called <a href="#BM_(DNA%20polymerase)%2Fi">DNA polymerase</a>s walk over each unwound strand and create complementing strands.</p>
<p><img src="svgbob_fc7cf2c734fa0cab15b5746e25ad07e25f85ec64.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BM_(replication%20origin)%2Fi"></a><strong>replication origin</strong> (<a name="BM_%5Cb(ori)%5Cb%2Fi"></a><strong>ori</strong>) - The point in DNA at which replication starts.</p>
</li>
<li>
<p><a name="BM_(replication%20terminus)%2Fi"></a><strong>replication terminus</strong> (<a name="BM_%5Cb(ter)%5Cb%2Fi"></a><strong>ter</strong>) - The point in DNA at which replication ends.</p>
</li>
<li>
<p><a name="BM_(forward%20half-strand)%2Fi"></a><strong>forward half-strand</strong> / <a name="BM_(reverse%20half-strand%7Cbackward%20half-strand%7Cbackwards%20half-strand)%2Fi"></a><strong>reverse half-strand</strong> - Bacteria are known to have a single chromosome of circular / looping DNA. In this DNA, the <a href="#BM_(replication%20origin)%2Fi">replication origin</a> (<a href="#BM_%5Cb(ori)%5Cb%2Fi">ori</a>) is the region of DNA where replication starts, while the <a href="#BM_(replication%20terminus)%2Fi">replication terminus</a> (<a href="#BM_%5Cb(ter)%5Cb%2Fi">ter</a>) is where replication ends.</p>
<p><img src="svgbob_fb9438945a109c884df7ccc79d1d8051fd358a87.svg" alt="Kroki diagram output"></p>
<p>If you split up the DNA based on <a href="#BM_%5Cb(ori)%5Cb%2Fi">ori</a> and <a href="#BM_%5Cb(ter)%5Cb%2Fi">ter</a> being cutting points, you end up with 4 distinct strands. Given that the direction of a strand is <a href="#BM_(5')%2Fi">5'</a> to <a href="#BM_(3')%2Fi">3'</a>, if the direction of the strand starts at...</p>
<ul>
<li>
<p><a href="#BM_%5Cb(ori)%5Cb%2Fi">ori</a> and ends at <a href="#BM_%5Cb(ter)%5Cb%2Fi">ter</a>, it's called the <a href="#BM_(forward%20half-strand)%2Fi">forward half-strand</a>.</p>
<p><img src="svgbob_d97cf1f12de4bd77dbaf9eca708b0e9120e50b33.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a href="#BM_%5Cb(ter)%5Cb%2Fi">ter</a> and ends at <a href="#BM_%5Cb(ori)%5Cb%2Fi">ori</a>, it's called the <a href="#BM_(reverse%20half-strand%7Cbackward%20half-strand%7Cbackwards%20half-strand)%2Fi">reverse half-strand</a>.</p>
<p><img src="svgbob_0016146d0b3f1f6edf2724e9978d52de7057f5f4.svg" alt="Kroki diagram output"></p>
</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<ul>
<li><a href="#BM_(forward%20half-strand)%2Fi">Forward half-strand</a> is the same as <a href="#BM_(lagging%20half-strand)%2Fi">lagging half-strand</a>.</li>
<li><a href="#BM_(reverse%20half-strand%7Cbackward%20half-strand%7Cbackwards%20half-strand)%2Fi">Reverse half-strand</a> is the same as <a href="#BM_(leading%20half-strand)%2Fi">leading half-strand</a>.</li>
</ul>
</div>
</li>
<li>
<p><a name="BM_(leading%20half-strand)%2Fi"></a><strong>leading half-strand</strong> / <a name="BM_(lagging%20half-strand)%2Fi"></a><strong>lagging half-strand</strong> - Given the 2 strands tha make up a DNA molecule, the strand that goes in the...</p>
<ul>
<li>reverse direction (<a href="#BM_(3')%2Fi">3'</a> to <a href="#BM_(5')%2Fi">5'</a>) is called the <a href="#BM_(leading%20half-strand)%2Fi">leading half-strand</a>.</li>
<li>forward direction (<a href="#BM_(5')%2Fi">5'</a> to <a href="#BM_(3')%2Fi">3'</a>) is called the <a href="#BM_(lagging%20half-strand)%2Fi">lagging half-strand</a>.</li>
</ul>
<p>This nomenclature has to do with <a href="#BM_(DNA%20polymerase)%2Fi">DNA polymerase</a>. Since <a href="#BM_(DNA%20polymerase)%2Fi">DNA polymerase</a> can only walk in the reverse direction (<a href="#BM_(3')%2Fi">3'</a> to <a href="#BM_(5')%2Fi">5'</a>), it synthesizes the <a href="#BM_(leading%20half-strand)%2Fi">leading half-strand</a> in one shot. For the <a href="#BM_(lagging%20half-strand)%2Fi">lagging half-strand</a> (<a href="#BM_(5')%2Fi">5'</a> to <a href="#BM_(3')%2Fi">3'</a>), multiple <a href="#BM_(DNA%20polymerase)%2Fi">DNA polymerase</a>s have to used to synthesize DNA, each binding to the lagging strand and walking backwards a small amount to generate a small fragment of DNA (<a href="#BM_(Okazaki%20fragment)%2Fi">Okazaki fragment</a>). the process is much slower for the <a href="#BM_(lagging%20half-strand)%2Fi">lagging half-strand</a>, that's why it's called lagging.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<ul>
<li><a href="#BM_(leading%20half-strand)%2Fi">Leading half-strand</a> is the same as <a href="#BM_(reverse%20half-strand%7Cbackward%20half-strand%7Cbackwards%20half-strand)%2Fi">reverse half-strand</a>.</li>
<li><a href="#BM_(lagging%20half-strand)%2Fi">Lagging half-strand</a> is the same as <a href="#BM_(forward%20half-strand)%2Fi">forward half-strand</a>.</li>
</ul>
</div>
</li>
<li>
<p><a name="BM_(Okazaki%20fragment)%2Fi"></a><strong>Okazaki fragment</strong> - A small fragment of DNA generated by <a href="#BM_(DNA%20polymerase)%2Fi">DNA polymerase</a> for <a href="#BM_(forward%20half-strand)%2Fi">forward half-strand</a>s. DNA synthesis for the <a href="#BM_(forward%20half-strand)%2Fi">forward half-strand</a>s can only happen in small pieces. As the fork open ups every ~2000 nucleotides, <a href="#BM_(DNA%20polymerase)%2Fi">DNA polymerase</a> attaches to the end of the fork on the <a href="#BM_(forward%20half-strand)%2Fi">forward half-strand</a> and walks in reverse to generate that small segment (<a href="#BM_(DNA%20polymerase)%2Fi">DNA polymerase</a> can only walk in the reverse direction).</p>
</li>
<li>
<p><a name="BM_(DNA%20ligase)%2Fi"></a><strong>DNA ligase</strong> - An enzyme that sews together short segments of DNA called <a href="#BM_(Okazaki%20fragment)%2Fi">Okazaki fragment</a>s by binding the phosphate group on the end of one strand with the deoxyribose group on the other strand.</p>
</li>
<li>
<p><a name="BM_(DnaA%20box)%2Fi"></a><strong>DnaA box</strong> - A <a href="#BM_(sequence)%2Fi">sequence</a> in the <a href="#BM_%5Cb(ori)%5Cb%2Fi">ori</a> that the DnaA protein (responsible for DNA replication) binds to.</p>
</li>
<li>
<p><a name="BM_(single%20stranded%20DNA%7Csingle-stranded%20DNA)%2Fi"></a><strong>single stranded DNA</strong> - A single strand of DNA, not bound to a strand of its reverse complements.</p>
<p><img src="svgbob_03d83c0a0dd86c50ead48a0a8bc87eebf4353039.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA)%2Fi"></a><strong>double stranded DNA</strong> - Two strands of DNA bound together, where each strand is the reverse complement of the other.</p>
<p><img src="svgbob_b05df825cb791aaf67d96b4e629e42c02b75f509.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi"></a><strong>gene</strong> - A segment of DNA that contains the instructions for either a protein or functional RNA.</p>
</li>
<li>
<p><a name="BM_(gene%20product)%2Fi"></a><strong>gene product</strong> - The final synthesized material resulting from the instructions that make up a <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">gene</a>. That synthesized material either being a protein or functional RNA.</p>
</li>
<li>
<p><a name="BM_(transcription%7Ctranscribed%7Ctranscribe)%2Fi"></a><strong>transcription</strong> - The process of transcribing a <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">gene</a> to RNA. Specifically, the enzyme RNA polymerase copies the segment of DNA that makes up that <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">gene</a> to a strand of RNA.</p>
<p><img src="svgbob_0fed5f4215fb0a5da3d93da589650b84df3f9c09.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BM_(translation%7Ctranslated%7Ctranslate)%2Fi"></a><strong>translation</strong> - The process of translating mRNA to protein. Specifically, a ribosome takes in the mRNA generated by <a href="#BM_(transcription%7Ctranscribed%7Ctranscribe)%2Fi">transcription</a> and outputs the protein that it codes for.</p>
<p><img src="svgbob_aeaffd032a869fcce0f71f969f22f2191880a88c.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BM_(gene%20expression)%2Fi"></a><strong>gene expression</strong> - The process by which a <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">gene</a> is synthesized into a <a href="#BM_(gene%20product)%2Fi">gene product</a>. When the <a href="#BM_(gene%20product)%2Fi">gene product</a> is...</p>
<ul>
<li>a protein, the <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">gene</a> is <a href="#BM_(transcription%7Ctranscribed%7Ctranscribe)%2Fi">transcribed</a> to mRNA and <a href="#BM_(translation%7Ctranslated%7Ctranslate)%2Fi">translated</a> to a protein.</li>
<li>functional RNA, the <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">gene</a> is <a href="#BM_(transcription%7Ctranscribed%7Ctranscribe)%2Fi">transcribed</a> to a type of RNA that isn't mRNA (only mRNA is <a href="#BM_(translation%7Ctranslated%7Ctranslate)%2Fi">translated</a> to a protein).</li>
</ul>
<p><img src="svgbob_78b3833e37ddc45358bf3ebf79daba1a9e2604eb.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BM_(regulatory%20gene)%2Fi"></a><strong>regulatory gene</strong> / <a name="BM_(regulatory%20protein)%2Fi"></a><strong>regulatory protein</strong> - The proteins <a href="#BM_(encode%7Cencoding%7Cdecode%7Cdecoding)%2Fi">encode</a>d by these <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">genes</a> effect <a href="#BM_(gene%20expression)%2Fi">gene expression</a> for certain other <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">genes</a>. That is, a <a href="#BM_(regulatory%20protein)%2Fi">regulatory protein</a> can cause certain other <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">genes</a> to be expressed more (promote <a href="#BM_(gene%20expression)%2Fi">gene expression</a>) or less (repress <a href="#BM_(gene%20expression)%2Fi">gene expression</a>).</p>
<p><a href="#BM_(regulatory%20gene)%2Fi">Regulatory gene</a>s are often controlled by external factors (e.g. sunlight, nutrients, temperature, etc..)</p>
</li>
<li>
<p><a name="BM_(feedback%20loop)%2Fi"></a><strong>feedback loop</strong> / <a name="BM_(negative%20feedback%20loop)%2Fi"></a><strong>negative feedback loop</strong> / <a name="BM_(positive%20feedback%20loop)%2Fi"></a><strong>positive feedback loop</strong> - A <a href="#BM_(feedback%20loop)%2Fi">feedback loop</a> is a system where the output (or some part of the output) is fed back into the system to either promote or repress further outputs.</p>
<p><img src="svgbob_3ba8fa4d05a4b9ef40e13dd6d9c7d60ecb9705ad.svg" alt="Kroki diagram output"></p>
<p>A <a href="#BM_(positive%20feedback%20loop)%2Fi">positive feedback loop</a> amplifies the output while a <a href="#BM_(negative%20feedback%20loop)%2Fi">negative feedback loop</a> regulates the output. <a href="#BM_(negative%20feedback%20loop)%2Fi">Negative feedback loop</a>s in particular are important in biology because they allow organisms to maintain homeostasis / equilibrium (keep a consistent internal state). For example, the system that regulates core temperatures in a human is a <a href="#BM_(negative%20feedback%20loop)%2Fi">negative feedback loop</a>. If a human's core temperature gets too...</p>
<ul>
<li>low, they shiver to drive the temperature up.</li>
<li>high, they sweat to drive the temperature down.</li>
</ul>
<p>In the example above, the output is the core temperature. The body monitors its core temperature and employs mechanisms to bring it back to normal if it goes out of range (e.g. sweat, shiver). The outside temperature is influencing the body's core temperature as well as the internal shivering / sweating mechanisms the body employs.</p>
<p><img src="svgbob_894d108e9621a523aaed2c3a3d5d13d20871f1f3.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BM_(circadian%20clock)%2Fi"></a><strong>circadian clock</strong> / <a name="BM_(circadian%20oscillator)%2Fi"></a><strong>circadian oscillator</strong> - A biological clock that synchronizes roughly around the earth's day-night cycle. This internal clock helps many species regulate their physical and behavioural attributes. For example, hunt during the night vs sleep during the day (e.g. nocturnal owls).</p>
</li>
<li>
<p><a name="BM_(upstream%20region)%2Fi"></a><strong>upstream region</strong> - The area just before some interval of DNA. Since the direction of DNA is <a href="#BM_(5')%2Fi">5'</a> to <a href="#BM_(3')%2Fi">3'</a>, this area is towards the <a href="#BM_(5')%2Fi">5'</a> end (upper end).</p>
</li>
<li>
<p><a name="BM_(downstream%20region)%2Fi"></a><strong>downstream region</strong> - The area just after some interval of DNA. Since the direction of DNA is <a href="#BM_(5')%2Fi">5'</a> to <a href="#BM_(3')%2Fi">3'</a>, this area is towards the <a href="#BM_(3')%2Fi">3'</a> end (lower end).</p>
</li>
<li>
<p><a name="BM_(transcription%20factor)%2Fi"></a><strong>transcription factor</strong> - A <a href="#BM_(regulatory%20protein)%2Fi">regulatory protein</a> that controls the rate of <a href="#BM_(transcription%7Ctranscribed%7Ctranscribe)%2Fi">transcription</a> for some <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">gene</a> that it has influence over (the copying of DNA to mRNA). The protein binds to a specific <a href="#BM_(sequence)%2Fi">sequence</a> in the <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">gene</a>'s <a href="#BM_(upstream%20region)%2Fi">upstream region</a>.</p>
</li>
<li>
<p><a name="BM_(motif)%2Fi"></a><strong>motif</strong> - A pattern that matches against many different <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s, where those matched <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s have some shared biological significance. The pattern matches a fixed k where each position may have alternate forms. The simplest way to think of a <a href="#BM_(motif)%2Fi">motif</a> is a regex pattern without quantifiers. For example, the regex <code>[AT]TT[GC]C</code> may match to ATTGC, ATTCC, TTTGC, and TTTCC.</p>
</li>
<li>
<p><a name="BM_(motif%20member)%2Fi"></a><strong>motif member</strong> <a name="BM_%5Cb(member)_MOTIF%2Fi"></a><strong></strong> - A specific nucleotide <a href="#BM_(sequence)%2Fi">sequence</a> that matches a <a href="#BM_(motif)%2Fi">motif</a>. For example, given a <a href="#BM_(motif)%2Fi">motif</a> represented by the regex <code>[AT]TT[GC]C</code>, the <a href="#BM_(sequence)%2Fi">sequence</a>s ATTGC, ATTCC, TTTGC, and TTTCC would be its <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a>s.</p>
</li>
<li>
<p><a name="BM_(motif%20matrix%7Cmotif%20matrices)%2Fi"></a><strong>motif matrix</strong> - A set of <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s stacked on top of each other in a matrix, where the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s are either...</p>
<ul>
<li><a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a>s of the same <a href="#BM_(motif)%2Fi">motif</a>,</li>
<li>or suspected <a href="#BM_%5Cb(member)_MOTIF%2Fi">member</a>s of the same <a href="#BM_(motif)%2Fi">motif</a>.</li>
</ul>
<p>For example, the <a href="#BM_(motif)%2Fi">motif</a> <code>[AT]TT[GC]C</code> has the following matrix:</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>T</td>
<td>T</td>
<td>G</td>
<td>C</td>
</tr>
<tr>
<td>A</td>
<td>T</td>
<td>T</td>
<td>C</td>
<td>C</td>
</tr>
<tr>
<td>T</td>
<td>T</td>
<td>T</td>
<td>G</td>
<td>C</td>
</tr>
<tr>
<td>T</td>
<td>T</td>
<td>T</td>
<td>C</td>
<td>C</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><a name="BM_(regulatory%20motif)%2Fi"></a><strong>regulatory motif</strong> - The <a href="#BM_(motif)%2Fi">motif</a> of a <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a>, typically 8 to 12 nucleotides in length.</p>
</li>
<li>
<p><a name="BM_(transcription%20factor%20binding%20site)%2Fi"></a><strong>transcription factor binding site</strong> - The physical binding site for a <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a>. A <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">gene</a> that's regulated by a <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a> needs a <a href="#BM_(sequence)%2Fi">sequence</a> located in its <a href="#BM_(upstream%20region)%2Fi">upstream region</a> that the <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a> can bind to: a <a href="#BM_(motif%20member)%2Fi">motif member</a> of that <a href="#BM_(transcription%20factor)%2Fi">transcription factor</a>'s <a href="#BM_(regulatory%20motif)%2Fi">regulatory motif</a>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>A <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">gene</a>'s <a href="#BM_(upstream%20region)%2Fi">upstream region</a> is the 600 to 1000 nucleotides preceding the start of the <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">gene</a>.</p>
</div>
</li>
<li>
<p><a name="BM_(cDNA)%2F"></a><strong>cDNA</strong> - A single strand of DNA generated from mRNA. The enzyme reverse transcriptase scans over the mRNA and creates the complementing single DNA strand.</p>
<p><img src="svgbob_97c5d076bf0a1cd98b75bbb88b72fc29c3b1b93d.svg" alt="Kroki diagram output"></p>
<p>The mRNA portion breaks off, leaving the <a href="#BM_(single%20stranded%20DNA%7Csingle-stranded%20DNA)%2Fi">single-stranded DNA</a>.</p>
<p><img src="svgbob_97e71090d31bdaa40278b0e705aef4e3555be8e3.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BM_(DNA%20microarray)%2Fi"></a><strong>DNA microarray</strong> / <a name="BM_(DNA%20array)%2Fi"></a><strong>DNA array</strong> - A device used to compare <a href="#BM_(gene%20expression)%2Fi">gene expression</a>. This works by measuring 2 mRNA samples against each other: a control sample and an experimental sample. The samples could be from...</p>
<ul>
<li>the same organism but at different times.</li>
<li>diseased and healthy versions of the same organism.</li>
<li>etc..</li>
</ul>
<p>Both mRNA samples are converted to <a href="#BM_(cDNA)%2F">cDNA</a> and are given fluorescent dyes. The control sample gets dyed green while the experimental sample gets dyed red.</p>
<p><img src="svgbob_6ce607591d81d0fd6c7507408e97fb8146e83baf.svg" alt="Kroki diagram output"></p>
<p>A sheet is broken up into multiple regions, where each region has the <a href="#BM_(cDNA)%2F">cDNA</a> for one specific <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">gene</a> from the control sample printed.</p>
<p><img src="svgbob_421210658cf3b4d0040b4815e879948ebfd7ccc5.svg" alt="Kroki diagram output"></p>
<p>The idea is that once the experimental <a href="#BM_(cDNA)%2F">cDNA</a> is introduced to that region, it should bind to the control <a href="#BM_(cDNA)%2F">cDNA</a> that's been printed to form <a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA)%2Fi">double-stranded DNA</a>. The color emitted in a region should correspond to the amount of <a href="#BM_(gene%20expression)%2Fi">gene expression</a> for the <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">gene</a> that region represents. For example, if a region on the sheet is fully yellow, it means that the <a href="#BM_(gene%20expression)%2Fi">gene expression</a> for that <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">gene</a> is roughly equal (red mixed with green is yellow).</p>
</li>
<li>
<p><a name="BM_(greedy%20algorithm)%2Fi"></a><strong>greedy algorithm</strong> - An algorithm that tries to speed things up by taking the locally optimal choice at each step. That is, the algorithm doesn't look more than 1 step ahead.</p>
<p>For example, imagine a chess playing AI that had a strategy of trying to eliminate the other player's most valuable piece at each turn. It would be considered greedy because it only looks 1 move ahead before taking action. Normal chess AIs / players look many moves ahead before taking action. As such, the greedy AI may be fast but it would very likely lose most matches.</p>
</li>
<li>
<p><a name="BM_(Cromwell's%20rule)%2Fi"></a><strong>Cromwell's rule</strong> - When a probability is based off past events, 0.0 and 1.0 shouldn't be used. That is, if you've...</p>
<ul>
<li>never seen an even occur in the past, it doesn't mean that there's a 0.0 probability of it occurring next.</li>
<li>always seen an event occur in the past, it doesn't mean that there's a 1.0 probability of it occurring next.</li>
</ul>
<p>Unless you're dealing with hard logical statements where prior occurrences don't come in to play (e.g. 1+1=2), you should include a small chance that some extremely unlikely event may happen. The example tossed around is "the probability that the sun will not rise tomorrow." Prior recorded observations show that that sun has always risen, but that doesn't mean that there's a 1.0 probability of the sun rising tomorrow (e.g. some extremely unlikely cataclysmic event may prevent the sun from rising).</p>
</li>
<li>
<p><a name="BM_(Laplace's%20rule%20of%20succession%7CLaplace's%20rule)%2Fi"></a><strong>Laplace's rule of succession</strong> - If some independent true/false event occurs n times, and s of those n times were successes, it's natural for people to assume the probability of success is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>s</mi><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{s}{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>. However, if the number of successes is 0, the probability would be 0.0. <a href="#BM_(Cromwell's%20rule)%2Fi">Cromwell's rule</a> states that when a probability is based off past events, 0.0 and 1.0 shouldn't be used. As such, a more appropriate / meaningful measure of probability is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow><mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{s+1}{n+2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2484389999999999em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>.</p>
<p>For example, imagine you're sitting on a park bench having lunch. Of the 8 birds you've seen since starting your lunch, all have been pigeons. If you were to calculate the probability that the next bird you'll see a crow, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>0</mn><mn>8</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{0}{8}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> would be flawed because it states that there's no chance that the next bird will be a crow (there obviously is a chance, but it may be a small chance). Instead, applying <a href="#BM_(Laplace's%20rule%20of%20succession%7CLaplace's%20rule)%2Fi">Laplace's rule</a> allows for the small probability that a crow may be seen next: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mn>0</mn><mo>+</mo><mn>1</mn></mrow><mrow><mn>8</mn><mo>+</mo><mn>2</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{0+1}{8+2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2484389999999999em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>.</p>
<p><a href="#BM_(Laplace's%20rule%20of%20succession%7CLaplace's%20rule)%2Fi">Laplace's rule of succession</a> is more meaningful when the number of trials (n) is small.</p>
</li>
<li>
<p><a name="BM_(pseudocount)%2Fi"></a><strong>pseudocount</strong> - When a zero is replaced with a small number to prevent unfair scoring. See <a href="#BM_(Laplace's%20rule%20of%20succession%7CLaplace's%20rule)%2Fi">Laplace's rule of succession</a>.</p>
</li>
<li>
<p><a name="BM_(randomized%20algorithm)%2Fi"></a><strong>randomized algorithm</strong> - An algorithm that uses a source of randomness as part of its logic. <a href="#BM_(randomized%20algorithm)%2Fi">Randomized algorithm</a>s come in two forms: <a href="#BM_(Las%20Vegas%20algorithm)%2Fi">Las Vegas algorithm</a>s and <a href="#BM_(Monte%20Carlo%20algorithm)%2Fi">Monte Carlo algorithm</a>s</p>
</li>
<li>
<p><a name="BM_(Las%20Vegas%20algorithm)%2Fi"></a><strong>Las Vegas algorithm</strong> - A <a href="#BM_(randomized%20algorithm)%2Fi">randomized algorithm</a> that delivers a guaranteed exact solution. That is, even though the algorithm makes random decisions it is guaranteed to converge on the exact solution to the problem its trying to solve (not an approximate solution).</p>
<p>An example of a <a href="#BM_(Las%20Vegas%20algorithm)%2Fi">Las Vegas algorithm</a> is randomized quicksort (randomness is applied when choosing the pivot).</p>
</li>
<li>
<p><a name="BM_(Monte%20Carlo%20algorithm)%2Fi"></a><strong>Monte Carlo algorithm</strong> - A <a href="#BM_(randomized%20algorithm)%2Fi">randomized algorithm</a> that delivers an approximate solution. Because these algorithms are quick, they're typically run many times. The approximation considered the best out of all runs is the one that gets chosen as the solution.</p>
<p>An example of a <a href="#BM_(Monte%20Carlo%20algorithm)%2Fi">Monte Carlo algorithm</a> is a genetic algorithm to optimize the weights of a deep neural network. That is, a step of the optimization requires running n different neural networks to see which gives the best result, then replacing those n networks with n copies of the best performing network where each copy has randomly tweaked weights. At some point the algorithm will stop producing incrementally better results.</p>
<p>Perform the optimization (the entire thing, not just a single step) thousands of times and pick the best network.</p>
</li>
<li>
<p><a name="BM_(consensus%20string%7Cconsensus%20sequence)%2Fi"></a><strong>consensus string</strong> - The <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> generated by selecting the most abundant column at each index of a <a href="#BM_(motif%20matrix%7Cmotif%20matrices)%2Fi">motif matrix</a>.</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> 1</td>
<td>A</td>
<td>T</td>
<td>T</td>
<td>G</td>
<td>C</td>
</tr>
<tr>
<td><a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> 2</td>
<td>A</td>
<td>T</td>
<td>T</td>
<td>C</td>
<td>C</td>
</tr>
<tr>
<td><a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> 3</td>
<td>T</td>
<td>T</td>
<td>T</td>
<td>G</td>
<td>C</td>
</tr>
<tr>
<td><a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> 4</td>
<td>T</td>
<td>T</td>
<td>T</td>
<td>C</td>
<td>C</td>
</tr>
<tr>
<td><a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> 5</td>
<td>A</td>
<td>T</td>
<td>T</td>
<td>C</td>
<td>G</td>
</tr>
<tr>
<td>consensus</td>
<td>A</td>
<td>T</td>
<td>T</td>
<td>C</td>
<td>C</td>
</tr>
</tbody>
</table>
<p>The generate <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> may also use a <a href="#BM_(hybrid%20alphabet%7Calternate%20alphabet%7Calternative%20alphabet)%2Fi">hybrid alphabet</a>. The <a href="#BM_(consensus%20string%7Cconsensus%20sequence)%2Fi">consensus string</a> for the same matrix above using <a href="#BM_(IUPAC%20nucleotide%20code)%2Fi">IUPAC nucleotide code</a>s: <code>WTTSS</code>.</p>
</li>
<li>
<p><a name="BM_(entropy)%2Fi"></a><strong>entropy</strong> - The uncertainty associated with a random variable. Given some set of outcomes for a variable, it's calculated as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>P</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>P</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">-\sum_{i=1}^{n} P(x_i) log P(x_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</p>
<p>This definition is for information theory. In other contexts (e.g. physics, economics), this term has a different meaning.</p>
</li>
<li>
<p><a name="BM_(genome)%2Fi"></a><strong>genome</strong> - All of the DNA for some organism.</p>
</li>
<li>
<p><a name="BM_(sequence)%2Fi"></a><strong>sequence</strong> - The ordered elements that make up some biological entity. For example, a DNA <a href="#BM_(sequence)%2Fi">sequence</a> contains the set of nucleotides and their positions for that DNA strand.</p>
</li>
<li>
<p><a name="BM_(sequencing%7Csequenced)%2Fi"></a><strong>sequencing</strong> - The process of determining which nucleotides are assigned to which positions in a strand of DNA or RNA.</p>
<p>The machinery used for DNA <a href="#BM_(sequencing%7Csequenced)%2Fi">sequencing</a> is called a <a href="#BM_(sequencer)%2Fi">sequencer</a>. A <a href="#BM_(sequencer)%2Fi">sequencer</a> takes multiple copies of the same DNA, breaks that DNA up into smaller fragments, and scans in those <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s. Each <a href="#BM_(fragment)_SEQ%2Fi">fragment</a> is typically the same size but has a unique starting offset. Because the starting offsets are all different, the original larger DNA <a href="#BM_(sequence)%2Fi">sequence</a> that can be constructed by finding <a href="#BM_(fragment)_SEQ%2Fi">fragment</a> with overlapping regions and stitching them together.</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> 1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>C</td>
<td>T</td>
<td>T</td>
<td>C</td>
<td>T</td>
<td>T</td>
</tr>
<tr>
<td><a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> 2</td>
<td></td>
<td></td>
<td></td>
<td>G</td>
<td>C</td>
<td>T</td>
<td>T</td>
<td>C</td>
<td>T</td>
<td></td>
</tr>
<tr>
<td><a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> 3</td>
<td></td>
<td></td>
<td>T</td>
<td>G</td>
<td>C</td>
<td>T</td>
<td>T</td>
<td>C</td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> 4</td>
<td></td>
<td>T</td>
<td>T</td>
<td>G</td>
<td>C</td>
<td>T</td>
<td>T</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> 5</td>
<td>A</td>
<td>T</td>
<td>T</td>
<td>G</td>
<td>C</td>
<td>T</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>reconstructed</td>
<td>A</td>
<td>T</td>
<td>T</td>
<td>G</td>
<td>C</td>
<td>T</td>
<td>T</td>
<td>C</td>
<td>T</td>
<td>T</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><a name="BM_(sequencer)%2Fi"></a><strong>sequencer</strong> - A machine that performs DNA or RNA <a href="#BM_(sequencing%7Csequenced)%2Fi">sequencing</a>.</p>
</li>
<li>
<p><a name="BM_(sequencing%20error)%2Fi"></a><strong>sequencing error</strong> - An error caused by a <a href="#BM_(sequencer)%2Fi">sequencer</a> returning a <a href="#BM_(fragment)_SEQ%2Fi">fragment</a> where a nucleotide was misinterpreted at one or more positions (e.g. offset 3 was actually a C but it got scanned in as a G).</p>
</li>
<li>
<p><a name="BM_%5Cb(read)_SEQ%2Fi"></a><strong>read</strong> - A segment of <a href="#BM_(genome)%2Fi">genome</a> scanned in during the process of <a href="#BM_(sequencing%7Csequenced)%2Fi">sequencing</a>.</p>
</li>
<li>
<p><a name="BM_(read-pair%7Cread%20pair)%2Fi"></a><strong>read-pair</strong> - A segment of <a href="#BM_(genome)%2Fi">genome</a> scanning in during the process of <a href="#BM_(sequencing%7Csequenced)%2Fi">sequencing</a>, where the middle of the segment is unknown. That is, the first k elements and the last k elements are known, but the d elements in between aren't known. The total size of the segment is 2k + d.</p>
<p><a href="#BM_(sequencer)%2Fi">Sequencer</a>s provide <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a>s as an alternative to longer <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a>s because the longer a <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> is the more errors it contains.</p>
<p>See <a href="#BM_(%5C(%5Cd%2B%2C%5Cs*%5Cd%2B%5C)-mer%7Ckd-mer%7Ckdmer%7C%5C(k%2C%5Cs*d%5C)-mer)%2Fi">kd-mer</a>.</p>
</li>
<li>
<p><a name="BM_(fragment)_SEQ%2Fi"></a><strong>fragment</strong> - A scanned <a href="#BM_(sequence)%2Fi">sequence</a> returned by a <a href="#BM_(sequencer)%2Fi">sequencer</a>. Represented as either a <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> or a <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a>.</p>
</li>
<li>
<p><a name="BM_(assembly%7Cassemble)%2Fi"></a><strong>assembly</strong> - The process of stitching together overlapping <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s to construct the <a href="#BM_(sequence)%2Fi">sequence</a> of the original larger DNA that those <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s came from.</p>
</li>
<li>
<p><a name="BM_(hybrid%20alphabet%7Calternate%20alphabet%7Calternative%20alphabet)%2Fi"></a><strong>hybrid alphabet</strong> - When representing a <a href="#BM_(sequence)%2Fi">sequence</a> that isn't fully conserved, it may be more appropriate to use an alphabet where each letter can represent more than 1 nucleotide. For example, the <a href="#BM_(IUPAC%20nucleotide%20code)%2Fi">IUPAC nucleotide code</a>s provides the following alphabet:</p>
<ul>
<li>A = A</li>
<li>C = C</li>
<li>T = T</li>
<li>G = G</li>
<li>W = A or T</li>
<li>S = G or C</li>
<li>K = G or T</li>
<li>Y = C or T</li>
<li>...</li>
</ul>
<p>If the <a href="#BM_(sequence)%2Fi">sequence</a> being represented can be either AAAC or AATT, it may be easier to represent a single string of AAWY.</p>
</li>
<li>
<p><a name="BM_(IUPAC%20nucleotide%20code)%2Fi"></a><strong>IUPAC nucleotide code</strong> - A <a href="#BM_(hybrid%20alphabet%7Calternate%20alphabet%7Calternative%20alphabet)%2Fi">hybrid alphabet</a> with the following mapping:</p>
<table>
<thead>
<tr>
<th>Letter</th>
<th>Base</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>Adenine</td>
</tr>
<tr>
<td>C</td>
<td>Cytosine</td>
</tr>
<tr>
<td>G</td>
<td>Guanine</td>
</tr>
<tr>
<td>T (or U)</td>
<td>Thymine (or Uracil)</td>
</tr>
<tr>
<td>R</td>
<td>A or G</td>
</tr>
<tr>
<td>Y</td>
<td>C or T</td>
</tr>
<tr>
<td>S</td>
<td>G or C</td>
</tr>
<tr>
<td>W</td>
<td>A or T</td>
</tr>
<tr>
<td>K</td>
<td>G or T</td>
</tr>
<tr>
<td>M</td>
<td>A or C</td>
</tr>
<tr>
<td>B</td>
<td>C or G or T</td>
</tr>
<tr>
<td>D</td>
<td>A or G or T</td>
</tr>
<tr>
<td>H</td>
<td>A or C or T</td>
</tr>
<tr>
<td>V</td>
<td>A or C or G</td>
</tr>
<tr>
<td>N</td>
<td>any base</td>
</tr>
<tr>
<td>. or -</td>
<td>gap</td>
</tr>
</tbody>
</table>
<p><a href="https://www.bioinformatics.org/sms/iupac.html">Source</a>.</p>
</li>
<li>
<p><a name="BM_(%5Cblogo%7Csequence%20logo)%2Fi"></a><strong>sequence logo</strong> - A graphical representation of how conserved a <a href="#BM_(sequence)%2Fi">sequence</a>'s positions are. Each position has its possible nucleotides stacked on top of each other, where the height of each nucleotide is based on how conserved it is. The more conserved a position is, the taller that column will be.</p>
<p>Typically applied to DNA or RNA, and May also be applied to other biological <a href="#BM_(sequence)%2Fi">sequence</a> types (e.g. <a href="#BM_(amino%20acid)%2Fi">amino acid</a>s).</p>
<p>The following is an example of a <a href="#BM_(%5Cblogo%7Csequence%20logo)%2Fi">logo</a> generated from a <a href="#BM_(motif)%2Fi">motif</a> <a href="#BM_(sequence)%2Fi">sequence</a>:</p>
<div style="border:1px solid black;">
<p></p>
<p>Generating logo for the following motif matrix...</p>
<p>TCGGGGGTTTTT<br>CCGGTGACTTAC<br>ACGGGGATTTTC<br>TTGGGGACTTTT<br>AAGGGGACTTCC<br>TTGGGGACTTCC<br>TCGGGGATTCAT<br>TCGGGGATTCCT<br>TAGGGGAACTAC<br>TCGGGTATAACC</p>
<p>Result...</p>
<p><img src="motif_logo_01b7e8763a84973751af52163d52f5bd.svg" alt="Motif Logo"></p>
</div>
<p></p>
</li>
<li>
<p><a name="BM_(transposon%7Ctransposable%20element%7Cjumping%20gene)%2Fi"></a><strong>transposon</strong> - A DNA <a href="#BM_(sequence)%2Fi">sequence</a> that can change its position within a <a href="#BM_(genome)%2Fi">genome</a>, altering the <a href="#BM_(genome)%2Fi">genome</a> size. They come in two flavours:</p>
<ul>
<li>Class I (retro<a href="#BM_(transposon%7Ctransposable%20element%7Cjumping%20gene)%2Fi">transposon</a>) - Behaves similarly to copy-and-paste where the <a href="#BM_(sequence)%2Fi">sequence</a> is duplicated. DNA is <a href="#BM_(transcription%7Ctranscribed%7Ctranscribe)%2Fi">transcribed</a> to RNA, followed by that RNA being reverse <a href="#BM_(transcription%7Ctranscribed%7Ctranscribe)%2Fi">transcribed</a> back to DNA by an enzyme called reverse transcriptase.</li>
<li>Class II (DNA <a href="#BM_(transposon%7Ctransposable%20element%7Cjumping%20gene)%2Fi">transposon</a>) - Behaves similarly to cut-and-paste where the <a href="#BM_(sequence)%2Fi">sequence</a> is moved. DNA is physically cut out by an enzyme called transposases and placed back in at some other location.</li>
</ul>
<p>Often times, <a href="#BM_(transposon%7Ctransposable%20element%7Cjumping%20gene)%2Fi">transposon</a>s cause disease. For example, ...</p>
<ul>
<li>insertion of a <a href="#BM_(transposon%7Ctransposable%20element%7Cjumping%20gene)%2Fi">transposon</a> into a <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">gene</a> will likely disable that <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">gene</a>.</li>
<li>after a <a href="#BM_(transposon%7Ctransposable%20element%7Cjumping%20gene)%2Fi">transposon</a> leaves a <a href="#BM_(%5Cbgenes%5Cb%7C%5Cbgene%5Cb)%2Fi">gene</a>, the gap likely won't be repaired correctly.</li>
</ul>
</li>
<li>
<p><a name="BM_(adjacency%20list)%2Fi"></a><strong>adjacency list</strong> - An internal representation of a graph where each node has a list of pointers to other nodes that it can forward to.</p>
<p><img src="svgbob_5b40f65c78645193c91742f02934854ae8846ede.svg" alt="Kroki diagram output"></p>
<p>The graph above represented as an <a href="#BM_(adjacency%20list)%2Fi">adjacency list</a> would be...</p>
<table>
<thead>
<tr>
<th>From</th>
<th>To</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>B</td>
</tr>
<tr>
<td>B</td>
<td>C</td>
</tr>
<tr>
<td>C</td>
<td>D,E</td>
</tr>
<tr>
<td>D</td>
<td>F</td>
</tr>
<tr>
<td>E</td>
<td>D,F</td>
</tr>
<tr>
<td>F</td>
<td></td>
</tr>
</tbody>
</table>
</li>
<li>
<p><a name="BM_(adjacency%20matrix)%2Fi"></a><strong>adjacency matrix</strong> - An internal representation of a graph where a matrix defines the number of times that each node forwards to every other node.</p>
<p><img src="svgbob_5b40f65c78645193c91742f02934854ae8846ede.svg" alt="Kroki diagram output"></p>
<p>The graph above represented as an <a href="#BM_(adjacency%20matrix)%2Fi">adjacency matrix</a> would be...</p>
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>B</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>C</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>D</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>E</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>F</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><a name="BM_(Hamiltonian%20path%7CHamilton%20path)%2Fi"></a><strong>Hamiltonian path</strong> - A path in a graph that visits every node exactly once.</p>
<p>The graph below has the <a href="#BM_(Hamiltonian%20path%7CHamilton%20path)%2Fi">Hamiltonian path</a> ABCEDF.</p>
<p><img src="svgbob_5b40f65c78645193c91742f02934854ae8846ede.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BM_(Eulerian%20path)%2Fi"></a><strong>Eulerian path</strong> <a name="BM_(Eulerian)_PATH%2Fi"></a><strong></strong> - A path in a graph that visits every edge exactly once.</p>
<p>In the graph below, the <a href="#BM_(Eulerian%20path)%2Fi">Eulerian path</a> is (A,B), (B,C), (C,D), (D,E), (E,C), (C,D), (D,F).</p>
<p><img src="svgbob_87660b191d813d39c396985391b70507c8c1236b.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BM_(Eulerian%20cycle)%2Fi"></a><strong>Eulerian cycle</strong> <a name="BM_(Eulerian)_CYCLE%2Fi"></a><strong></strong> - An <a href="#BM_(Eulerian%20path)%2Fi">Eulerian path</a> that forms a cycle. That is, a path in a graph that is a cycle and visits every edge exactly once.</p>
<p>The graph below has an <a href="#BM_(Eulerian%20cycle)%2Fi">Eulerian cycle</a> of (A,B), (B,C) (C,D), (D,F), (F,C), (C,A).</p>
<p><img src="svgbob_244dd1930eb16ef58be2261f1ffb9277ad2d793a.svg" alt="Kroki diagram output"></p>
<p>If a graph contains an <a href="#BM_(Eulerian%20cycle)%2Fi">Eulerian cycle</a>, it's said to be an <a href="#BM_(Eulerian%20graph)%2Fi">Eulerian graph</a>.</p>
</li>
<li>
<p><a name="BM_(Eulerian%20graph)%2Fi"></a><strong>Eulerian graph</strong> <a name="BM_(Eulerian)_GRAPH%2Fi"></a><strong></strong> - For a graph to be <a href="#BM_(Eulerian)_GRAPH%2Fi">Eulerian</a>, it must have am <a href="#BM_(Eulerian%20cycle)%2Fi">Eulerian cycle</a>. For a graph to have an <a href="#BM_(Eulerian%20cycle)%2Fi">Eulerian cycle</a>, it must be both <a href="#BM_(balanced)_GRAPH%2Fi">balanced</a> and <a href="#BM_(strongly%20connected)%2Fi">strongly connected</a>.</p>
<p><img src="svgbob_d0af75d07c2969afc5f4088d18d3b7a327f26ef2.svg" alt="Kroki diagram output"></p>
<p>Note how in the graph above, ...</p>
<ul>
<li>
<p>every node is reachable from every other node (<a href="#BM_(strongly%20connected)%2Fi">strongly connected</a>),</p>
</li>
<li>
<p>every node has an <a href="#BM_(outdegree)%2Fi">outdegree</a> equal to its <a href="#BM_(indegree)%2Fi">indegree</a> (<a href="#BM_(balanced)_GRAPH%2Fi">balanced</a>).</p>
<table>
<thead>
<tr>
<th>Node</th>
<th><a href="#BM_(indegree)%2Fi">Indegree</a></th>
<th><a href="#BM_(outdegree)%2Fi">Outdegree</a></th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>B</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>C</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>D</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>F</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
</li>
</ul>
<p>In contrast, the following graphs are not <a href="#BM_(Eulerian%20graph)%2Fi">Eulerian graph</a>s (no <a href="#BM_(Eulerian%20cycle)%2Fi">Eulerian cycle</a>s exist):</p>
<ul>
<li>
<p><a href="#BM_(strongly%20connected)%2Fi">Strongly connected</a> but not <a href="#BM_(balanced)_GRAPH%2Fi">balanced</a>.</p>
<p><img src="svgbob_efdff1b3ec66000b9acf2ddc84c2d3684d318683.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a href="#BM_(balanced)_GRAPH%2Fi">Balanced</a> but not <a href="#BM_(strongly%20connected)%2Fi">strongly connected</a>.</p>
<p><img src="svgbob_48abea7e0377d91bfd845a85b2ee9615e9852bfd.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a href="#BM_(balanced)_GRAPH%2Fi">Balanced</a> but <a href="#BM_(disconnected)%2Fi">disconnected</a> (not <a href="#BM_(strongly%20connected)%2Fi">strongly connected</a>).</p>
<p><img src="svgbob_1f6d7503fdb3f3654b3c64f041254352c8d9a43e.svg" alt="Kroki diagram output"></p>
</li>
</ul>
</li>
<li>
<p><a name="BM_(disconnected)%2Fi"></a><strong>disconnected</strong> / <a name="BM_(connected)%2Fi"></a><strong>connected</strong> - A graph is <a href="#BM_(disconnected)%2Fi">disconnected</a> if you can break it out into 2 or more distinct sub-graphs without breaking any paths. In other words, the graph contains at least two nodes which aren't contained in any path.</p>
<p>The graph below is <a href="#BM_(disconnected)%2Fi">disconnected</a> because there is no path that contains E, F, G, or H and A, B, C, or D.</p>
<p><img src="svgbob_754a446a49b8209971f339d76f4fcc492acbb615.svg" alt="Kroki diagram output"></p>
<p>The graph below is <a href="#BM_(connected)%2Fi">connected</a>.</p>
<p><img src="svgbob_028c9291a4412afebe0b605b464987e2c9bf75ef.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BM_(strongly%20connected)%2Fi"></a><strong>strongly connected</strong> - A graph is <a href="#BM_(strongly%20connected)%2Fi">strongly connected</a> if every node is reachable from every other node.</p>
<p>The graph below is <strong>not</strong> <a href="#BM_(strongly%20connected)%2Fi">strongly connected</a> because neither A nor B is reachable by C, D, E, or F.</p>
<p><img src="svgbob_5b40f65c78645193c91742f02934854ae8846ede.svg" alt="Kroki diagram output"></p>
<p>The graph below is <a href="#BM_(strongly%20connected)%2Fi">strongly connected</a> because all nodes are reachable from all nodes.</p>
<p><img src="svgbob_244dd1930eb16ef58be2261f1ffb9277ad2d793a.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BM_(indegree)%2Fi"></a><strong>indegree</strong> / <a name="BM_(outdegree)%2Fi"></a><strong>outdegree</strong> - The number of edges leading into / out of a node of a directed graph.</p>
<p>The node below has an <a href="#BM_(indegree)%2Fi">indegree</a> of 3 and an <a href="#BM_(outdegree)%2Fi">outdegree</a> of 1.</p>
<p><img src="svgbob_7159ebaf654fe57b46d2f14a29a73d50e280afe6.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BM_(balanced%20node)%2Fi"></a><strong>balanced node</strong> <a name="BM_(balanced)_NODE%2Fi"></a><strong></strong> - A node of a directed graph that has an equal <a href="#BM_(indegree)%2Fi">indegree</a> and <a href="#BM_(outdegree)%2Fi">outdegree</a>. That is, the number of edges coming in is equal to the number of edges going out.</p>
<p>The node below has an <a href="#BM_(indegree)%2Fi">indegree</a> and <a href="#BM_(outdegree)%2Fi">outdegree</a> of 1. It is <a href="#BM_(balanced)_NODE%2Fi">balanced</a>.</p>
<p><img src="svgbob_7c49a4fbe8fc85173147545e7a459bca61c84f26.svg" alt="Kroki diagram output"></p>
<p></p>
</li>
<li>
<p><a name="BM_(balanced%20graph)%2Fi"></a><strong>balanced graph</strong> <a name="BM_(balanced)_GRAPH%2Fi"></a><strong></strong> - A directed graph where ever node is <a href="#BM_(balanced)_NODE%2Fi">balanced</a>.</p>
<p>The graph below is <a href="#BM_(balanced)_GRAPH%2Fi">balanced</a> because all nodes are <a href="#BM_(balanced)_NODE%2Fi">balanced</a>.</p>
<p><img src="svgbob_244dd1930eb16ef58be2261f1ffb9277ad2d793a.svg" alt="Kroki diagram output"></p>
<table>
<thead>
<tr>
<th>Node</th>
<th><a href="#BM_(indegree)%2Fi">Indegree</a></th>
<th><a href="#BM_(outdegree)%2Fi">Outdegree</a></th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>B</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>C</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>D</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>F</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p></p>
</li>
<li>
<p><a name="BM_(overlap%20graph)%2Fi"></a><strong>overlap graph</strong> - A graph representing the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s making up a string. Specifically, the graph is built in 2 steps:</p>
<ol>
<li>
<p>Each node is a <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>.</p>
<p><img src="svgbob_ba61508d2d4f3dfef58ce5783f8e22f49ddec891.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p>Each edge is between overlapping <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s (nodes), where the ...</p>
<ul>
<li>source node has the overlap in its suffix .</li>
<li>destination node has the overlap in its prefix.</li>
</ul>
<p><img src="svgbob_679d24959920acb04c059d6e53dee545fff77300.svg" alt="Kroki diagram output"></p>
</li>
</ol>
<p><a href="#BM_(overlap%20graph)%2Fi">Overlap graph</a>s used for <a href="#BM_(genome)%2Fi">genome</a> <a href="#BM_(assembly%7Cassemble)%2Fi">assembly</a>.</p>
</li>
<li>
<p><a name="BM_(de%20Bruijn%20graph)%2Fi"></a><strong>de Bruijn graph</strong> - A special graph representing the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s making up a string. Specifically, the graph is built in 2 steps:</p>
<ol>
<li>
<p>Each <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> is represented as an edge connecting 2 nodes. The ...</p>
<ul>
<li>source node represents the first 0 to n-1 elements of the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>,</li>
<li>destination node represents last 1 to n elements of the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>,</li>
<li>and edge represents the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>.</li>
</ul>
<p>For example, ...</p>
<p><img src="svgbob_8e6112b97be535a52f2be925bb5b56b546699aaa.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p>Each node representing the same value is merged together to form the graph.</p>
<p>For example, ...</p>
<p><img src="svgbob_cfa519e3b0b53ea602d7a16720f54ea9c85f3f08.svg" alt="Kroki diagram output"></p>
</li>
</ol>
<p><a href="#BM_(de%20Bruijn%20graph)%2Fi">De Bruijn graph</a>s are used for <a href="#BM_(genome)%2Fi">genome</a> <a href="#BM_(assembly%7Cassemble)%2Fi">assembly</a>. It's much faster to <a href="#BM_(assembly%7Cassemble)%2Fi">assemble</a> a <a href="#BM_(genome)%2Fi">genome</a> from a <a href="#BM_(de%20Bruijn%20graph)%2Fi">de Bruijn graph</a> than it is to from an <a href="#BM_(overlap%20graph)%2Fi">overlap graph</a>s.</p>
<p><a href="#BM_(de%20Bruijn%20graph)%2Fi">De Bruijn graph</a>s were originally invented to solve the <a href="#BM_(k-universal%7C%5Cd%2B-universal)%2Fi">k-universal</a> string problem.</p>
</li>
<li>
<p><a name="BM_(k-universal%7C%5Cd%2B-universal)%2Fi"></a><strong>k-universal</strong> - For some alphabet and k, a string is considered <a href="#BM_(k-universal%7C%5Cd%2B-universal)%2Fi">k-universal</a> if it contains every <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a> for that alphabet exactly once. For example, for an alphabet containing only 0 and 1 (binary) and k=3, a <a href="#BM_(k-universal%7C%5Cd%2B-universal)%2Fi">3-universal</a> string would be 0001110100 because it contains every <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">3-mer</a> exactly once:</p>
<ul>
<li>000: <strong>000</strong>1110100</li>
<li>001: 0<strong>001</strong>110100</li>
<li>010: 000111<strong>010</strong>0</li>
<li>011: 00<strong>011</strong>10100</li>
<li>100: 0001110<strong>100</strong></li>
<li>101: 00011<strong>101</strong>00</li>
<li>110: 0001<strong>110</strong>100</li>
<li>111: 000<strong>111</strong>0100</li>
</ul>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>This is effectively <a href="#BM_(assembly%7Cassemble)%2Fi">assembly</a>. There are a set of <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s and they're being stitched together to form a larger string. The only difference is that the elements aren't nucleotides.</p>
</div>
<p><a href="#BM_(de%20Bruijn%20graph)%2Fi">De Bruijn graph</a>s were invented in an effort to construct <a href="#BM_(k-universal%7C%5Cd%2B-universal)%2Fi">k-universal</a> strings for arbitrary values of k. For example, given the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s in the example above (000, 001, ...), a <a href="#BM_(k-universal%7C%5Cd%2B-universal)%2Fi">k-universal</a> string can be found by constructing a <a href="#BM_(de%20Bruijn%20graph)%2Fi">de Bruijn graph</a> from the <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s and finding a <a href="#BM_(Eulerian%20cycle)%2Fi">Eulerian cycle</a> in that graph.</p>
<p><img src="svgbob_f05ffef51444183bdc007d88010e832876608ed7.svg" alt="Kroki diagram output"></p>
<p>There are multiple <a href="#BM_(Eulerian%20cycle)%2Fi">Eulerian cycle</a>s in the graph, meaning that there are multiple <a href="#BM_(k-universal%7C%5Cd%2B-universal)%2Fi">3-universal</a> strings:</p>
<ul>
<li>0001110100</li>
<li>0011101000</li>
<li>1110001011</li>
<li>1100010111</li>
<li>...</li>
</ul>
<p>For larger values of k (e.g. 20), finding <a href="#BM_(k-universal%7C%5Cd%2B-universal)%2Fi">k-universal</a> strings would be too computationally intensive without <a href="#BM_(de%20Bruijn%20graph)%2Fi">De Bruijn graph</a>s and <a href="#BM_(Eulerian%20cycle)%2Fi">Eulerian cycle</a>s.</p>
</li>
<li>
<p><a name="BM_(coverage)_SEQ%2Fi"></a><strong>coverage</strong> - Given a substring from some larger <a href="#BM_(sequence)%2Fi">sequence</a> that was reconstructed from a set of <a href="#BM_(fragment)_SEQ%2Fi">fragment</a>s, the <a href="#BM_(coverage)_SEQ%2Fi">coverage</a> of that substring is the number of <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a>s used to construct it. The substring length is typically 1: the <a href="#BM_(coverage)_SEQ%2Fi">coverage</a> for each position of the <a href="#BM_(sequence)%2Fi">sequence</a>.</p>
<p><img src="svgbob_8dd35ba9a6498739b4dd8f3759fd49dec3d1e9c8.svg" alt="Kroki diagram output"></p>
</li>
<li>
<p><a name="BM_(read%20breaking%7Cread-breaking%7Cbreaking%20reads)%2Fi"></a><strong>read breaking</strong> - The concept of taking multiple <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a>s and breaking them up into smaller <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a>s.</p>
<p><img src="svgbob_d9e103b16312cfe660d19df9305a9361ac1241ac.svg" alt="Kroki diagram output"></p>
<p>When <a href="#BM_(read%20breaking%7Cread-breaking%7Cbreaking%20reads)%2Fi">read breaking</a>, smaller <a href="#BM_(%5Cd%2B-mer%7Ck-mer%7Ckmer)%2Fi">k-mer</a>s result in better <a href="#BM_(coverage)_SEQ%2Fi">coverage</a> but also make the <a href="#BM_(de%20Bruijn%20graph)%2Fi">de Bruijn graph</a> more tangled. The more tangled the <a href="#BM_(de%20Bruijn%20graph)%2Fi">de Bruijn graph</a> is, the harder it is to infer the full <a href="#BM_(sequence)%2Fi">sequence</a>.</p>
<p>In the example above, the average <a href="#BM_(coverage)_SEQ%2Fi">coverage</a>...</p>
<ul>
<li>for the left-hand side (original) is 2.1.</li>
<li>for the right-hand side (broken) is 4.</li>
</ul>
<p>See also: <a href="#BM_(read-pair%20breaking%7Cread%20pair%20breaking%7Cbreaking%20read-pairs%7Cbreaking%20read%20pairs)%2Fi">read-pair breaking</a>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>What purpose does this actually serve? Mimicking 1 long <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> as n shorter <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a>s isn't equivalent to actually having <a href="#BM_(sequencing%7Csequenced)%2Fi">sequenced</a> those n shorter <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a>s. For example, what if the longer <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a> being broken up has an error? That error replicates when breaking into n shorter <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a>s, which gives a false sense of having good <a href="#BM_(coverage)_SEQ%2Fi">coverage</a> and makes it seems as if it wasn't an error.</p>
</div>
</li>
<li>
<p><a name="BM_(read-pair%20breaking%7Cread%20pair%20breaking%7Cbreaking%20read-pairs%7Cbreaking%20read%20pairs)%2Fi"></a><strong>read-pair breaking</strong> - The concept of taking multiple <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a>s and breaking them up into <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a>s with a smaller k.</p>
<p><img src="svgbob_eb8f1251b4e293a9662ade2c0a4452a7c7884f2f.svg" alt="Kroki diagram output"></p>
<p>When <a href="#BM_(read-pair%20breaking%7Cread%20pair%20breaking%7Cbreaking%20read-pairs%7Cbreaking%20read%20pairs)%2Fi">read-pair breaking</a>, a smaller k results in better <a href="#BM_(coverage)_SEQ%2Fi">coverage</a> but also make the <a href="#BM_(de%20Bruijn%20graph)%2Fi">de Bruijn graph</a> more tangled. The more tangled the <a href="#BM_(de%20Bruijn%20graph)%2Fi">de Bruijn graph</a> is, the harder it is to infer the full <a href="#BM_(sequence)%2Fi">sequence</a>.</p>
<p>In the example above, the average <a href="#BM_(coverage)_SEQ%2Fi">coverage</a>...</p>
<ul>
<li>for the left-hand side (original) is 1.6.</li>
<li>for the right-hand side (broken) is 2.5.</li>
</ul>
<p>See also: <a href="#BM_(read%20breaking%7Cread-breaking%7Cbreaking%20reads)%2Fi">read breaking</a>.</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>What purpose does this actually serve? Mimicking 1 long <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a> as n shorter <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a>s isn't equivalent to actually having <a href="#BM_(sequencing%7Csequenced)%2Fi">sequenced</a> those n shorter <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a>s. For example, what if the longer <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a> being broken up has an error? That error replicates when breaking into n shorter <a href="#BM_(read-pair%7Cread%20pair)%2Fi">read-pair</a>s, which gives a false sense of having good <a href="#BM_(coverage)_SEQ%2Fi">coverage</a> and makes it seems as if it wasn't an error.</p>
</div>
</li>
<li>
<p><a name="BM_(contig)s%3F%5Cb%2Fi"></a><strong>contig</strong> - A long continuous piece of DNA. Derived by searching a directed graph for paths that are the longest possible stretches of nodes with 1 <a href="#BM_(indegree)%2Fi">indegree</a> and 1 <a href="#BM_(outdegree)%2Fi">outdegree</a>. That is, a path must either ...</p>
<ul>
<li>be a cycle where each node has an <a href="#BM_(indegree)%2Fi">indegree</a> and <a href="#BM_(outdegree)%2Fi">outdegree</a> of 1.</li>
<li>start and end at a node that doesn't have an <a href="#BM_(indegree)%2Fi">indegree</a> and <a href="#BM_(outdegree)%2Fi">outdegree</a> of 1.</li>
</ul>
<p>For example, in the following <a href="#BM_(de%20Bruijn%20graph)%2Fi">de Bruijn graph</a>, the <a href="#BM_(contig)s%3F%5Cb%2Fi">contig</a>s are: GTGG, GGT, and GGT:</p>
<p><img src="svgbob_a90b2398b01bdc55d3409e08bb813c748d346635.svg" alt="Kroki diagram output"></p>
<p>Assemblies often have gaps due to...</p>
<ul>
<li>repeats in the <a href="#BM_(genome)%2Fi">genome</a>, which make it impossible to fully <a href="#BM_(assembly%7Cassemble)%2Fi">assemble</a>.</li>
<li>poor <a href="#BM_(coverage)_SEQ%2Fi">coverage</a>, which may be cost prohibitive to fix (more <a href="#BM_%5Cb(read)_SEQ%2Fi">read</a>s required).</li>
</ul>
<p>As such, biologists / bioinformaticians have no choice but to settle on <a href="#BM_(contig)s%3F%5Cb%2Fi">contig</a>s.</p>
</li>
<li>
<p><a name="BM_(ribonucleotide)%2Fi"></a><strong>ribonucleotide</strong> - Elements that make up RNA, similar to how nucleotides are the elements that make up DNA.</p>
<ul>
<li>A = Adenine (same as nucleotide)</li>
<li>C = Cytosine (same as nucleotide)</li>
<li>G = Guanine (same as nucleotide)</li>
<li>U = Uracil (replace nucleotide Thymine)</li>
</ul>
</li>
<li>
<p><a name="BM_(antibiotic)%2Fi"></a><strong>antibiotic</strong> - A substance (typically an enzyme) for killing, preventing, or inhibiting the grow of bacterial infections.</p>
</li>
<li>
<p><a name="BM_(amino%20acid)%2Fi"></a><strong>amino acid</strong> - The building blocks of <a href="#BM_(peptide)%2Fi">peptide</a>s / proteins, similar to how nucleotides are the building blocks of DNA.</p>
<table>
<thead>
<tr>
<th>1 Letter Code</th>
<th>3 Letter Code</th>
<th><a href="#BM_(amino%20acid)%2Fi">Amino Acid</a></th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>Ala</td>
<td>Alanine</td>
</tr>
<tr>
<td>C</td>
<td>Cys</td>
<td>Cysteine</td>
</tr>
<tr>
<td>D</td>
<td>Asp</td>
<td>Aspartic acid</td>
</tr>
<tr>
<td>E</td>
<td>Glu</td>
<td>Glutamic acid</td>
</tr>
<tr>
<td>F</td>
<td>Phe</td>
<td>Phenylalanine</td>
</tr>
<tr>
<td>G</td>
<td>Gly</td>
<td>Glycine</td>
</tr>
<tr>
<td>H</td>
<td>His</td>
<td>Histidine</td>
</tr>
<tr>
<td>I</td>
<td>Ile</td>
<td>Isoleucine</td>
</tr>
<tr>
<td>K</td>
<td>Lys</td>
<td>Lysine</td>
</tr>
<tr>
<td>L</td>
<td>Leu</td>
<td>Leucine</td>
</tr>
<tr>
<td>M</td>
<td>Met</td>
<td>Methionine</td>
</tr>
<tr>
<td>N</td>
<td>Asn</td>
<td>Asparagine</td>
</tr>
<tr>
<td>P</td>
<td>Pro</td>
<td>Proline</td>
</tr>
<tr>
<td>Q</td>
<td>Gln</td>
<td>Glutamine</td>
</tr>
<tr>
<td>R</td>
<td>Arg</td>
<td>Arginine</td>
</tr>
<tr>
<td>S</td>
<td>Ser</td>
<td>Serine</td>
</tr>
<tr>
<td>T</td>
<td>Thr</td>
<td>Threonine</td>
</tr>
<tr>
<td>V</td>
<td>Val</td>
<td>Valine</td>
</tr>
<tr>
<td>W</td>
<td>Trp</td>
<td>Tryptophan</td>
</tr>
<tr>
<td>Y</td>
<td>Tyr</td>
<td>Tyrosine</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><a name="BM_(peptide)%2Fi"></a><strong>peptide</strong> - A short <a href="#BM_(amino%20acid)%2Fi">amino acid</a> chain of at least size two. <a href="#BM_(peptide)%2Fi">Peptide</a>s are considered miniature proteins, but when something should be called a <a href="#BM_(peptide)%2Fi">peptide</a> vs a protein is loosely defined: the cut-off is anywhere between 50 to 100 <a href="#BM_(amino%20acid)%2Fi">amino acid</a>s.</p>
</li>
<li>
<p><a name="BM_(polypeptide)%2Fi"></a><strong>polypeptide</strong> - A <a href="#BM_(peptide)%2Fi">peptide</a> of at least size 10.</p>
</li>
<li>
<p><a name="BM_(central%20dogma%20of%20molecular%20biology)%2Fi"></a><strong>central dogma of molecular biology</strong> - The overall concept of <a href="#BM_(transcription%7Ctranscribed%7Ctranscribe)%2Fi">transcription</a> and <a href="#BM_(translation%7Ctranslated%7Ctranslate)%2Fi">translation</a>: Instructions for making a protein are copied from DNA to RNA, then RNA feeds into the ribosome to make that protein (DNA → RNA → Protein).</p>
<p>Most, not all, <a href="#BM_(peptide)%2Fi">peptide</a>s are synthesized as described above. <a href="#BM_(non-ribosomal%20peptide)%2Fi">Non-ribosomal peptide</a>s are synthesized outside of the <a href="#BM_(transcription%7Ctranscribed%7Ctranscribe)%2Fi">transcription</a> and <a href="#BM_(translation%7Ctranslated%7Ctranslate)%2Fi">translation</a>.</p>
</li>
<li>
<p><a name="BM_(non-ribosomal%20peptide)%2Fi"></a><strong>non-ribosomal peptide</strong> <a name="BM_%5Cb(NRP)%5Cb%2Fi"></a><strong></strong> - A <a href="#BM_(peptide)%2Fi">peptide</a> that was synthesized by a protein called <a href="#BM_%5Cb(NRP)%5Cb%2Fi">NRP</a> synthetase rather than synthesized by a ribosome. <a href="#BM_%5Cb(NRP)%5Cb%2Fi">NRP</a> synthethase builds <a href="#BM_(peptide)%2Fi">peptide</a>s one <a href="#BM_(amino%20acid)%2Fi">amino acid</a> at a time without relying on <a href="#BM_(transcription%7Ctranscribed%7Ctranscribe)%2Fi">transcription</a> or <a href="#BM_(translation%7Ctranslated%7Ctranslate)%2Fi">translation</a>.</p>
<p><a href="#BM_(non-ribosomal%20peptide)%2Fi">Non-ribosomal peptide</a>s may be cyclic. Common use-cases for <a href="#BM_(non-ribosomal%20peptide)%2Fi">non-ribosomal peptide</a>s:</p>
<ul>
<li><a href="#BM_(antibiotic)%2Fi">antibiotic</a>s</li>
<li>anti-tumor agents</li>
<li>immunosuppressors</li>
<li>communication between bacteria (quorum sensing)</li>
</ul>
</li>
<li>
<p><a name="BM_(mass%20spectrometer%7Cmass%20spectrometry)%2Fi"></a><strong>mass spectrometer</strong> - A device that shatters molecules into pieces and weighs the resulting pieces (measured in <a href="#BM_(dalton)%2Fi">dalton</a>s). <a href="#BM_(mass%20spectrometer%7Cmass%20spectrometry)%2Fi">Mass spectrometry</a> can be used to <a href="#BM_(sequence)%2Fi">sequence</a> <a href="#BM_(peptide)%2Fi">peptide</a>s by inferring the <a href="#BM_(amino%20acid)%2Fi">amino acid</a> <a href="#BM_(sequence)%2Fi">sequence</a> from the collection of masses.</p>
</li>
<li>
<p><a name="BM_(experimental%20spectrum)%2Fi"></a><strong>experimental spectrum</strong> - Given a shattered molecule, a collection consisting of the each piece's mass as measured by a <a href="#BM_(mass%20spectrometer%7Cmass%20spectrometry)%2Fi">mass spectrometer</a>. For example, given the <a href="#BM_(peptide)%2Fi">peptide</a> ACDEFG, the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> may be...</p>
<ul>
<li>mass(A)</li>
<li>mass(AC)</li>
<li>mass(ACD)</li>
<li>mass(ACDE)</li>
<li>mass(ACDEF)</li>
</ul>
<p><a href="#BM_(experimental%20spectrum)%2Fi">Experimental spectrum</a> are the masses returned from an actual <a href="#BM_(mass%20spectrometer%7Cmass%20spectrometry)%2Fi">mass spectrometry</a> experiment, while <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a> are all possible masses for a <a href="#BM_(mass%20spectrometer%7Cmass%20spectrometry)%2Fi">mass spectrometry</a> experiment.</p>
</li>
<li>
<p><a name="BM_(theoretical%20spectrum)%2Fi"></a><strong>theoretical spectrum</strong> - A collection consisting of all possible masses measurable by a <a href="#BM_(mass%20spectrometer%7Cmass%20spectrometry)%2Fi">mass spectrometer</a> in addition to 0 and the mass of the entire molecule being measured. For example, given the <a href="#BM_(peptide)%2Fi">peptide</a> ACDEFG, the <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a> would be...</p>
<ul>
<li>mass() = 0</li>
<li>mass(A)</li>
<li>mass(AC)</li>
<li>mass(ACD)</li>
<li>mass(ACDE)</li>
<li>mass(ACDEF)</li>
<li>mass(ACDEFG)</li>
</ul>
<p><a href="#BM_(experimental%20spectrum)%2Fi">Experimental spectrum</a> are the masses returned from an actual <a href="#BM_(mass%20spectrometer%7Cmass%20spectrometry)%2Fi">mass spectrometry</a> experiment, while <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a> are all possible masses for a <a href="#BM_(mass%20spectrometer%7Cmass%20spectrometry)%2Fi">mass spectrometry</a> experiment.</p>
</li>
<li>
<p><a name="BM_(ideal%20spectrum)%2Fi"></a><strong>ideal spectrum</strong> - When the <a href="#BM_(experimental%20spectrum)%2Fi">experimental spectrum</a> matches the <a href="#BM_(theoretical%20spectrum)%2Fi">theoretical spectrum</a>.</p>
</li>
<li>
<p><a name="BM_(dalton)%2Fi"></a><strong>dalton</strong> <a name="BM_%5Cb(Da)%5Cb%2Fi"></a><strong></strong> - A unit of measurement used in physics and chemistry. 1 <a href="#BM_(dalton)%2Fi">Dalton</a> is approximately the mass of a single proton / neutron, derived by taking the mass of a carbon-12 atom and dividing it by 12.</p>
</li>
<li>
<p><a name="BM_(codon%7Cgenetic%20code)%2Fi"></a><strong>codon</strong> - A <a href="#BM_(sequence)%2Fi">sequence</a> of 3 <a href="#BM_(ribonucleotide)%2Fi">ribonucleotide</a>s that maps to an <a href="#BM_(amino%20acid)%2Fi">amino acid</a> or a stop marker. During <a href="#BM_(translation%7Ctranslated%7Ctranslate)%2Fi">translation</a>, the ribosome <a href="#BM_(translation%7Ctranslated%7Ctranslate)%2Fi">translate</a>s the RNA to a protein 3 <a href="#BM_(ribonucleotide)%2Fi">ribonucleotide</a>s at a time:</p>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The stop marker tells the ribosome to stop translating / the protein is complete.</p>
</div>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>The <a href="#BM_(codon%7Cgenetic%20code)%2Fi">codon</a>s are listed as <a href="#BM_(ribonucleotide)%2Fi">ribonucleotide</a>s (RNA). For nucleotides (DNA), swap U with T.</p>
</div>
<table>
<thead>
<tr>
<th>1 Letter Code</th>
<th>3 Letter Code</th>
<th><a href="#BM_(amino%20acid)%2Fi">Amino Acid</a></th>
<th><a href="#BM_(codon%7Cgenetic%20code)%2Fi">Codon</a>s</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>Ala</td>
<td>Alanine</td>
<td>GCA, GCC, GCG, GCU</td>
</tr>
<tr>
<td>C</td>
<td>Cys</td>
<td>Cysteine</td>
<td>UGC, UGU</td>
</tr>
<tr>
<td>D</td>
<td>Asp</td>
<td>Aspartic acid</td>
<td>GAC, GAU</td>
</tr>
<tr>
<td>E</td>
<td>Glu</td>
<td>Glutamic acid</td>
<td>GAA, GAG</td>
</tr>
<tr>
<td>F</td>
<td>Phe</td>
<td>Phenylalanine</td>
<td>UUC, UUU</td>
</tr>
<tr>
<td>G</td>
<td>Gly</td>
<td>Glycine</td>
<td>GGA, GGC, GGG, GGU</td>
</tr>
<tr>
<td>H</td>
<td>His</td>
<td>Histidine</td>
<td>CAC, CAU</td>
</tr>
<tr>
<td>I</td>
<td>Ile</td>
<td>Isoleucine</td>
<td>AUA, AUC, AUU</td>
</tr>
<tr>
<td>K</td>
<td>Lys</td>
<td>Lysine</td>
<td>AAA, AAG</td>
</tr>
<tr>
<td>L</td>
<td>Leu</td>
<td>Leucine</td>
<td>CUA, CUC, CUG, CUU, UUA, UUG</td>
</tr>
<tr>
<td>M</td>
<td>Met</td>
<td>Methionine</td>
<td>AUG</td>
</tr>
<tr>
<td>N</td>
<td>Asn</td>
<td>Asparagine</td>
<td>AAC, AAU</td>
</tr>
<tr>
<td>P</td>
<td>Pro</td>
<td>Proline</td>
<td>CCA, CCC, CCG, CCU</td>
</tr>
<tr>
<td>Q</td>
<td>Gln</td>
<td>Glutamine</td>
<td>CAA, CAG</td>
</tr>
<tr>
<td>R</td>
<td>Arg</td>
<td>Arginine</td>
<td>AGA, AGG, CGA, CGC, CGG, CGU</td>
</tr>
<tr>
<td>S</td>
<td>Ser</td>
<td>Serine</td>
<td>AGC, AGU, UCA, UCC, UCG, UCU</td>
</tr>
<tr>
<td>T</td>
<td>Thr</td>
<td>Threonine</td>
<td>ACA, ACC, ACG, ACU</td>
</tr>
<tr>
<td>V</td>
<td>Val</td>
<td>Valine</td>
<td>GUA, GUC, GUG, GUU</td>
</tr>
<tr>
<td>W</td>
<td>Trp</td>
<td>Tryptophan</td>
<td>UGG</td>
</tr>
<tr>
<td>Y</td>
<td>Tyr</td>
<td>Tyrosine</td>
<td>UAC, UAU</td>
</tr>
<tr>
<td>*</td>
<td>*</td>
<td><strong>STOP</strong></td>
<td>UAA, UAG, UGA</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><a name="BM_(reading%20frame)%2Fi"></a><strong>reading frame</strong> - The different ways of dividing a DNA string into <a href="#BM_(codon%7Cgenetic%20code)%2Fi">codon</a>s. Specifically, there are 6 different ways that a DNA string can be divided into <a href="#BM_(codon%7Cgenetic%20code)%2Fi">codon</a>s:</p>
<ul>
<li>You can start dividing at index 0, 1, or 2.</li>
<li>You can divide either the string or the reverse complementing string (<a href="#BM_(double%20stranded%20DNA%7Cdouble-stranded%20DNA)%2Fi">double-stranded DNA</a>).</li>
</ul>
<p>For example, given the the string ATGTTCCATTAA, the the following <a href="#BM_(codon%7Cgenetic%20code)%2Fi">codon</a> division are possible:</p>
<table>
<thead>
<tr>
<th>DNA</th>
<th>Start Index</th>
<th>Discard Prefix</th>
<th><a href="#BM_(codon%7Cgenetic%20code)%2Fi">Codon</a>s</th>
<th>Discard Suffix</th>
</tr>
</thead>
<tbody>
<tr>
<td>ATGTTCCATTAA</td>
<td>0</td>
<td></td>
<td>ATG, TTC, CAT, TAA</td>
<td></td>
</tr>
<tr>
<td>ATGTTCCATTAA</td>
<td>1</td>
<td>A</td>
<td>TGT, TCC, ATT</td>
<td>AA</td>
</tr>
<tr>
<td>ATGTTCCATTAA</td>
<td>2</td>
<td>AT</td>
<td>GTT, CCA, TTA</td>
<td>A</td>
</tr>
<tr>
<td>TTAATGGAACAT</td>
<td>0</td>
<td></td>
<td>TTA, ATG, GAA, CAT</td>
<td></td>
</tr>
<tr>
<td>TTAATGGAACAT</td>
<td>1</td>
<td>T</td>
<td>TAA, TGG, AAC</td>
<td>AT</td>
</tr>
<tr>
<td>TTAATGGAACAT</td>
<td>2</td>
<td>TT</td>
<td>AAT, GGA, ACA</td>
<td>T</td>
</tr>
</tbody>
</table>
<div style="margin:2em; background-color: #e0e0e0;">
<p><strong>⚠️NOTE️️️⚠️</strong></p>
<p>TTAATGGAACAT is the reverse complement of ATGTTCCATTAA.</p>
</div>
</li>
<li>
<p><a name="BM_(encode%7Cencoding%7Cdecode%7Cdecoding)%2Fi"></a><strong>encode</strong> - When a DNA string or its reverse complement is made up of the <a href="#BM_(codon%7Cgenetic%20code)%2Fi">codon</a>s required for an <a href="#BM_(amino%20acid)%2Fi">amino acid</a> <a href="#BM_(sequence)%2Fi">sequence</a>. For example, ACAGTA <a href="#BM_(encode%7Cencoding%7Cdecode%7Cdecoding)%2Fi">encode</a>s for the <a href="#BM_(amino%20acid)%2Fi">amino acid</a> <a href="#BM_(sequence)%2Fi">sequence</a>...</p>
<ul>
<li>Threonine-Valine</li>
<li>Tyrosine-Cysteine (derived from reverse complement)</li>
</ul>
</li>
</ul>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>

        </body></html>